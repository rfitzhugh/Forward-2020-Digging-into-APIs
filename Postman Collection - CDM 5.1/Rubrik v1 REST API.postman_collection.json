{
	"info": {
		"_postman_id": "7a158dca-f293-4981-ac89-d9744f165e2b",
		"name": "Rubrik v1 REST API",
		"description": "\nCopyright (c) 2017 Rubrik Inc. [Legal](#section/Legal)\n\n# Introduction\n\nWelcome to the Rubrikâ„¢ REST API documentation.\n\nThe Rubrik REST API provides a RESTful interface for working with Rubrik clusters and Rubrik Edge virtual appliances. The Rubrik REST API can be used to query, configure, and control nearly all of the operations of the Rubrik software.\n\nThrough authenticated and encrypted interaction with the Rubrik REST API server, perform any of the operations that are available through the Rubrik web UI and many bulk-type operations that might otherwise be difficult or impossible to perform.\n\nThis documentation provides reference information and examples of typical workflows for the Rubrik REST API. For more detailed information about working with Rubrik clusters and Rubrik Edge virtual appliances refer to the *Rubrik User Guide*.\n\nA quick way to become familiar with the Rubrik REST API, is to use the Rubrik REST API Explorer. [OpenAPI](#section/OpenAPI) describes this tool.\n\nRefer to the [changelog](#section/Changelog) to see information about changes within this version of the Rubrik REST API.\n\n# Changelog\n\n Revisions are listed with the most recent revision first.\n\n ### Changes to V1 API in Rubrik Version 5.1.1\n ## Breaking changes:\n\n ## New features:\n * Added `has_instances` parameter to GET `/mssql/hierarchy/{id}/descendants`\n   and GET `/mssql/hierarchy/{id}/children`. Added `hasInstances` field in the\n   response object.\n\n ### Changes to V1 API in Rubrik Version 5.1.0\n ## Breaking changes:\n\n ## New features:\n * Added `GET /archive/aws/s3/{id}/account_id` endpoint to get the\n   account ID of the AWS data location.\n * Added `DELETE /authorization/cache` endpoint to clear cached authorization\n   information.\n * Added `GET /syslog/export` endpoint to get all syslog export rules.\n * Added `POST /syslog/export` endpoint to add a syslog export rule.\n * Added `GET /syslog/export/{id}` endpoint to get a syslog export rule.\n * Added `PATCH /syslog/export/{id}` endpoint to update a syslog export rule.\n * Added `DELETE /syslog/export/{id}` endpoint to delete a syslog export rule.\n * Added `POST /syslog/export/test` endpoint to test a syslog export rule.\n * Added stubs for the `GET /event/latest` endpoint to V1 to\n   facilitate a future migration from internal to V1.\n * Added stubs for the `GET /event_series/{id}` endpoint to V1\n   to facilitate a future migration from internal to V1.\n * Added stubs for the `GET /event` endpoint to V1 to facilitate\n   a future migration from internal to V1.\n * Added optional query parameter 'snappableStatus' to /vmware/vcenter,\n   /vmware/compute_cluster, /vmware/host,  /host, /mssql/instance, and\n   /windows_cluster. This parameter enables a user to fetch the set of\n   protectable objects from the list of objects visible to that user.\n * Added optional field `alias` to HostSummary, HostRegister, and HostUpdate\n   schemas. This field will allow the user to specify an alias for each host\n   which can be used for search.\n * Added `POST /archive/location/{location_id}/reader/refresh/data_sources`\n   endpoint to refresh the metadata of a list of given data sources from\n   the given reader location.\n * Added `POST /managed_volume/snapshot/export/{id}/script` endpoint to\n   generate a script to create a directory to view all files in all channels\n   of a managed volume snapshot export.\n * Moved the `GET /blackout_window` endpoint from internal to V1.\n * Moved the `PATCH /blackout_window` endpoint from internal to V1.\n * Added `GET /certificate` endpoint to get all imported certificates.\n * Added `POST /certificate` endpoint to import a certificate.\n * Added `GET /certificate/{id}` endpoint to retrieve a certificate by id.\n * Added `PATCH /certificate/{id}` endpoint to update a certificate.\n * Added `GET /csr` endpoint to get all outstanding\n   Certificate-Signing-Requests.\n * Added `POST /csr` endpoint to generate a Certificate-Signing-Request.\n * Added 'DELETE /oracle/db/{id}/downloaded__snapshots' endpoint\n   to delete downloaded Oracle db snapshots and log snapshots.\n * Added unauthenticated endpoint `GET /saml/sso_status` to check\n   SAML SSO status. For example, we can check whether SSO is enabled or not.\n * Added optional field archivalTieringSpec to ArchivalSpecV2 to support\n   archival tiering. This enables the user to configure either Instant Tiering\n   or Smart Tiering (with a corresponding minimum accessible duration) on an\n   SLA domain with archival configured to an Azure archival location.\n * Updated endpoint /mssql/db to have a new optional query paramter,\n   indicating if backup task information should be included.\n * Added the `IoFilterSummary` object with `id`, `name`, `version`, `vendor`\n   fields and `summary`, `releaseDate` optional fields.\n * Added `GET /vmware/computer_cluster/request/{id}` endpoint to get the details\n   of an asynchronous request that involves a VMware compute cluster.\n * Added `PATCH /vmware/computer_cluster/{id}` endpoint to update\n   the configuredSlaDomainId for a VMware compute cluster with a specific ID.\n * Added `GET /vmware/compute_cluster/{id}/io_filter` to get the ioFilters on\n   the VMware compute cluster with a specific ID.\n * Added `POST /vmware/compute_cluster/{id}/install_io_filter` endpoint to\n   install the Rubrik ioFilter to the VMware compute cluster with a specific\n   ID.\n * Added `POST /vmware/compute_cluster/{id}/uninstall_io_filter` endpoint to\n   uninstall the Rubrik ioFilter from the VMware compute cluster with a\n   specific ID.\n * Added `POST /vmware/compute_cluster/{id}/upgrade_io_filter` endpoint to\n   upgrade the Rubrik ioFilter to the latest version for the VMware compute\n   cluster with a specific ID.\n * Moved the `GET /vmware/compute_cluster` endpoint from internal to V1.\n * Moved the `GET /vmware/compute_cluster/{id}` endpoint from internal to V1.\n * Added endpoint /saml/authn_request/{idp_name} for making SAML\n * Added an optional field 'isRetentionLocked' to 'POST /sla_domain',\n   'PUT /sla_domain/{id}' and 'PATCH /sla_domain/{id}' to allow users to manage\n   the Retention Lock capabilities of an SLA Domain.\n * Added endpoint 'POST /saml/authn_request/{idp_name}' for making SAML\n   authentication request for a given ID Provider.\n * Added endpoint 'POST /saml/rubrik_metadata' for downloading Rubrik SAML\n   metadata file.\n * Added a series of new endpoints /idp_auth_domain for managing SAML\n   Id Provider integration.\n * Moved the 'connectionStatus' field from VcenterDetail to VcenterSummary.\n * Added new optional query parameters 'data_sources' and 'snapshot_ids' to\n   'GET /sla_domain' endpoint. This allows users to filter SLA Domains based\n   on whether they can be assigned to specified data sources and snapshots.\n * Changed the existing endpoints `GET /mssql/db/` `GET /mssql/instance`\n   `GET /mssql/db/{id}` `PATCH /mssql/db/{id}` `GET /mssql/db/snapshot/{id}`\n   `GET /mssql/instance/{id}` `GET /mssql/instance/{id}` to return an\n   unprotectable reason as a string in the 'unprotectableReason' field instead\n   of a JSON struct.\n * Added a `PUT /host/certificate/{id}` endpoint to update the\n   certificate of the given host\n * Added `GET /vcd/vapp/template/snapshot/{snapshot_id}/export` to get\n   available options for a vApp template snapshot export.\n * Added `POST /vcd/vapp/template/snapshot/{snapshot_id}/export` to queue\n   export of a vApp template snapshot.\n * Added continuous data protection state for each VMware virtual machine.\n * Added optional field 'isIoFilterInstalled' to vCenter summary. Returns true\n   if any Rubrik IO filters are installed on any compute clusters that are\n   a part of the vCenter.\n * Added optional field `cloudStorageTier` to `BaseSnapshotSummary`, to indicate\n   the current storage tier of the archived copy of a snapshot.\n * Added `POST ` /vmware/vm/cdp endpoint to get live CDP info for a list of\n   virtual machines.\n * Added the optional field isEffectiveSlaDomainRetentionLocked to\n   FilesetSummary. The field is a Boolean that specifies whether the effective\n   SLA Domain of a fileset is retention locked.\n * Added optional field isEffectiveSlaDomainRetentionLocked to `Snappable`.\n   The parameter depicts if the effective SLA domain for the data source is\n   a Retention Lock SLA Domain.\n * Added optional field isConfiguredSlaDomainRetentionLocked to SlaAssignable.\n   The parameter depicts if the configured SLA domain for the object is a\n   Retention Lock SLA Domain.\n * Added required fields: isCdpEnabled(type: boolean) and cdpState(type:\n   CdpState Enum) to VirtualMachineDetails.\n * Added optional field `shouldUseAgent` to `RestoreFileJobConfig`\n   in `POST /vmware/vm/snapshot/{id}/restore_file` to specify\n   whether to use Rubrik Backup Service to restore file. Default value is true.\n * Moved the GET `/mssql/hierarchy/{id}/descendants` and\n   GET `/mssql/hierarchy/{id}/children` endpoints from internal to v1.\n   Added the `is_relic`, `is_live_mount` `is_clustered`, and\n   `is_log_shipping_secondary`\n   parameters. Changed acceptable values of `object_type` and `sort_by`\n   parameters. Added `hasPermissions`, `isInAvailabilityGroup`,\n   `descendantSlaDomains', `instanceChildren`,\n   `unprotectableReasons`, `isLiveMount`, `isLogShippingSecondary`,\n   `hostStatus`, `cbtEnabled`, `cbtEffectiveStatus`, `isClustered` and\n   `clusterInstanceAddress` fields in the\n   response object. Removed `replicaCount` field in the response object.\n   Added support for returning non-availability databases.\n   Changed `object_type` query parameter to take a comma-separated list of\n   object types.\n   Added the GET `/mssql/hierarchy/{id}` endpoint to get a specific hierarchy\n   object.\n * Added the POST `/mssql/sla_domain/assign` endpoint to assign SLA properties\n   to SQL Server objects.\n * Added isRetentionLocked to MssqlInstanceSummary.\n\n ### Changes to V1 API in Rubrik Version 5.0.3\n ## Deprecation:\n\n ## New features and improvements:\n * Added a new optional field 'oracleQueryUser' to HostRegister, HostUpdate\n   and HostDetail objects, for setting the Oracle username for account with\n   query privileges on the host. This applies the following endpoints:\n   POST /host/bulk, PATCH /host/{id}, and GET /host/{id}.\n\n ### Changes to V1 API in Rubrik Version 5.0.2\n ## Deprecation:\n\n ## New features and improvements:\n * Added `GET /oracle/db/{id}/restore_estimate` endpoint to provide an\n   estimate of the amount of data that must be downloaded for a restore\n   operation.\n * Introduced optional field `logicalSize` to `VirtualMachineDetail`. This\n   field gives the sum of logical sizes of all the disks in the virtual\n   machine.\n * Added optional parameter `ignore_connection_status` to\n   `GET /vmware/vcenter/{id}`. Set this parameter to skip calculating\n   connection status.\n\n ### Changes to V1 API in Rubrik Version 5.0.1\n ## Deprecation:\n\n ## New features and improvements:\n * Added `GET /cluster/{id}/security/encryption` endpoint to provide encryption\n   at rest status of the cluster.\n * Added `GET /vmware/host/{id}/datastore` endpoint to get the details\n   of datastores for an ESXi host.\n * Added `POST /vmware/vm/mount/{id}/relocate` endpoint to migrate datastore\n   for a virtual machine from Live Mount or Instant Recovery.\n * Added `America/Santiago`, `Australia/Adelaide` and `Australia/Brisbane` as\n   supported cluster time zones.\n\n ### Changes to V1 API in Rubrik Version 5.0.0\n ## Deprecation:\n * Deprecating query paramter `hostname` of `GET /host` and response property\n   `hostname` of `GET /host`, `POST /host`, `PUT /host/certificate/{id}`,\n   `GET /host/{id}`, `PATCH /host/{id}`, and `POST /host/{id}/refresh`.\n   Use `name` instead. Support for `hostname` is present in v1 and removed in v2.\n * Deprecating response property `isArchived` of `GET /mssql/db`,\n   `GET /mssql/db/{id}`, and `PATCH /mssql/db/{id}`. Use\n   `isDeleted` instead. Support for `isArchived` is present in v1 and removed in v2.\n * Deprecating parameter `datastoreName` of `Post /vmware/vm/snapshot/{id}/mount`.\n\n ## New features:\n * Added a new optional field 'oracleQueryUser' to HostRegister, HostUpdate\n   and HostDetail objects, for setting the Oracle username for account with\n   query privileges on the host. This change applies to the following endpoints:\n   POST /host/bulk, PATCH /host/{id}, and GET /host/{id}.\n * Added a new PUT endpoint to /ldap_service/{id}.\n * Added /cluster/{id}/snmp_mib_link endpoint.\n * Added a new optional field 'oracleSysDbaUser' to /host/{id} POST endpoint\n   during register host for setting the Oracle username for account with sysdba\n   privileges on this host.\n * Added a new optional field 'oracleSysDbaUser' to /host/{id} endpoint for\n   changing the Oracle username for account with sysdba privileges on this\n   host.\n * Added a new optional field 'mfaServerId' to /ldap_service endpoint for\n   associating a configured MFA server.\n * Added a new /sla_domain endpoint with the same functionality as /v1, but\n   added support for weekly and quarterly time units and modify the config of\n   monthly and yearly.\n * Added a new optional field 'isArrayEnabled' to 'FilesetTemplateCreate'\n   for creation of storage array-enabled fileset templates. We also include\n   this new field in 'FilesetTemplateDetail'.\n * Added a new optional field 'arraySpec' to 'FilesetCreate' for\n   creation of storage array-enabled filesets. We also include\n   this new field in the responses of the `GET /fileset/{id}` and\n   `GET /fileset` endpoints.\n * Added ability to use the /host/{id} endpoint to specify a host level\n   setting for enabling or disabling CBT backups of SQL Server databases,\n   along with new optional fields 'mssqlCbtEnabled', 'mssqlCbtEffectiveStatus'\n   and 'mssqlCbtDriverInstalled'.\n * Added ability to use the /host/{id} endpoint to instruct the Rubrik cluster\n   to remove the CBT driver from a Windows host that has CBT backups of SQL\n   Server databases disabled.\n * Added new optional field 'isPassthrough' to 'POST /fileset' endpoint to\n   indicate if we want to take a direct archive backup.\n * Added a new field unprotectable_reasons to GET /mssql/db/{id} and\n   GET /mssql/instance/{id}. This field keeps track of the reasons that a\n   SQL Server database or instance cannot be protected by Rubrik.\n * Added ability to use the /host/{id} endpoint to specify a host level\n   setting for enabling or disabling VFD backups of volumes on Windows hosts.\n * Added ability to use the /host/{id} endpoint to instruct the Rubrik cluster\n   to remove the VFD driver from a Windows host that has VFD backups of volumes\n   disabled.\n * Added new optional field 'isOverwrite' to ExportMssqlDbJobConfig for\n   'POST /mssql/db/{id}/export' endpoint to enable overwriting an existing\n   database while using the export operation.\n * Added a new optional field 'allowOverwrite' to the\n   'POST /mssql/db/{id}/export' endpoint to allow overwriting an existing\n   database during the export.\n * Added a new field 'hasAttachingDisk' to 'GET /vmware/vm/snapshot/mount' and\n   'GET /vmware/vm/snapshot/mount/{id}' that indicates to the user whether\n   this is an attaching disk mount job.\n * Added a new field 'attachingDiskCount' to 'GET /vmware/vm/snapshot/mount'\n   and 'GET /vmware/vm/snapshot/mount/{id}' that indicate to the user how many\n   disks are attached.\n * Removed optional field 'clusterInstanceAddress' from\n   'PATCH /mssql/instance/{id}' endpoint since host-centric discovery for\n   cluster instances eliminates the need to edit the instance address.\n * Added new field `missedSnapshotTimeUnits` in `MissedSnapshot`\n * Added new field 'vmxFileContent' in getSnapshotDetail\n * Added new optional fields 'organizationId' and 'organizationName' to\n   `/host/{id}` and `/host` endpoints to get the organization a host is\n   assigned to due to Envoy.\n * Added new field 'vmwareTagList' in getSnapshotDetail\n * Added new endpoint GET /cluster/{id}/certificate to get the cluster cert.\n * Added new optional field PATCH /vmware/vm/{id} to indicate whether or not\n   to refresh the in-memory cache after updates to a virtual machine record.\n * Added new field 'shouldRecoverTags' in MountSnapshotJobConfigV1\n * Added new field 'shouldRecoverTags' in InstantRecoveryJobConfig\n * Added new field 'shouldRecoverTags' in ExportSnapshotJobConfig\n * Added a new optional field 'operating_system' to 'GET /host'.\n * Added a new optional field 'apiEndpoint' to 'NasBaseConfig'.\n * Added new optional field 'enableSymlinkResolution' to FilesetSummary in\n   'POST /fileset', \"GET /fileset\" and \"PATCH /fileset/{id}\" endpoints to\n   indicate if we want to resolve symlinks during metadata scan.\n * Added new optional field 'enableHardlinkSupport' to FilesetSummary and\n   FilesetCreate in 'POST /fileset', \"GET /fileset\" and \"PATCH /fileset/{id}\"\n   endpoints to enable recognition and deduplication of hardlinks in\n   fileset backup.\n\n ## Improvements:\n * Added optional 'apiToken' and 'apiEndpoint' fields to NasConfig to support\n   Pure FlashBlade devices.\n * Added a new field 'guestOsName' to GET /vmware/vm. This allows users to\n   filter virtual machines based on the guest operating system name.\n * Enhanced GET /vmware/vm/snapshot/{id} response by adding disk details\n   such as fileName and deviceKey.\n * Added isMountAllowed field to the response of GET\n   /mssql/db/{id}/recoverable_range. This helps identify which recoverable\n   ranges support Live Mount, which is affected by whether a database snapshot\n   contains filestreams.\n * Added optional query parameters limit and offset to support pagination for\n   GET /mssql/db endpoint.\n * Added optional query parameters sortOrder and sortBy to enable users to\n   sort the results of GET /mssql/db endpoint by effectiveSlaDomainId and name.\n\n ### Changes to V1 API in Rubrik Version 4.2\n ## Breaking changes:\n * The input field OperatingSystemType value `Linux` is replaced by `UnixLike`\n   in FilesetTemplateCreateDefinition, used by POST /fileset-template, and\n   in FilesetTemplatePatchDefinition, used by PATCH /fileset_template/{id}.\n * The input field operating_system_type value `Linux` is replaced by `UnixLike`\n   in GET /fileset-template and GET /host.\n\n ## New features:\n * Added a new /ldap_service endpoint for managing Active Directory integration.\n * Added a new optional field 'nasBaseConfig' to GET /api/v1/host. This field\n   allows NAS (Isilon/NetApp) api credential to be displayed and edited.\n * GET /host/{id}/search now returns search results for filesets, Windows volume\n   groups, and storage array volume groups belonging to the host. Previously,\n   the endpoint would only return fileset search results.\n * Added endpoints for actions related to log shipping configurations:\n   POST /mssql/db/{id}/log_shipping to create, GET /mssql/db/log_shipping to\n   query, GET /mssql/db/log_shipping/{id} to retrieve individual details,\n   DELETE /mssql/db/log_shipping/{id} to delete, and POST\n   /mssql/db/log_shipping/{id}/reseed to reseed an unhealthy secondary\n   database.\n * Added `Africa/Johannesburg`, `Africa/Lagos` and `Africa/Nairobi` as\n   supported cluster time zones.\n ## Improvements:\n * Added 2 new optional fields `apiHostname` and `zoneName` to POST /host\n   and GET /host. These fields allow different zones to be configured for\n   Isilon NAS.\n * Added a new field 'geolocation' to GET /cluster/{id} and PATCH /cluster/{id}.\n   These allow users to view and modify the geolocation of the cluster,\n   respectively.\n * Added a new field `guestOsType` to the `VirtualMachineDetail`\n   object used in response of `GET /vmware/vm/{id}`\n * Added an optional organizationId field to the HostRegister request in POST\n   /host to allow users with the global admin RBAC role to add a host to an\n   organization specified by the value of the organizationId field.\n * Added canLiveMount field to the responses of `GET /mssql/db/snapshot/{id}`\n   and `GET /mssql/db/{id}/snapshot`.\n * Added an optional field `agentStatus` to `VirtualMachineSummary` object used\n   in response of `GET /vmware/vm` endpoint. This allows user to check the\n   Rubrik Backup Service connection status of the corresponding VMware VM.\n * Added the `POST /vmware/vm/{id}/register_agent` endpoint.\n * Added a new field 'createDatastoreOnly' to POST\n   /vmware/vm/snapshot/{id}/mount. This allows user to mount snapshot to vmware\n   datastore only, without create a virtual machine.\n * Added a new field `numWindowsVolumeGroups` to the `SlaDomainDetail` and\n   `SlaDomainSummary` objects used in response to `GET /sla_domain` endpoints.\n * Added new optional field 'shouldRefreshCacheAfterUpdate' for PATCH\n   /vmware/vm/{id} to indicate whether or not to refresh the in-memory cache\n   after updates to a virtual machine record.\n\n ### Changes to V1 API in Rubrik Version 4.1\n\n ## Breaking changes:\n * The 'allowedBackupWindow' and 'firstFullBackupWindow' input field for\n   /sla_domain now take the cluster time zone instead of UTC.\n\n ## New features:\n * Added POST /host/{id}/refresh endpoint to refresh hosts without\n   registering them again\n * Added GET /fileset/snapshot/{id} endpoint to retrieve details of a\n   fileset snapshot.\n * Added POST /mssql/db/{id}/log_backup endpoint for taking on-demand\n   log backup of SQL Server databases.\n * Added a new optional query parameter 'is_agentless' to\n   GET /windows_cluster. This allows users to filter all clusters that\n   do not have any hosts with Rubrik connectors installed. If this\n   parameter is omitted, all clusters are returned.\n * Added a new field 'isAgentless' to GET /windows_cluster. This indicates\n   whether all the hosts on this windows cluster do not have Rubrik connector\n   installed. If even one host has Rubrik connector installed, this will\n   be set to false.\n * Added a new optional 'organization_id' query parameter on POST /session.\n   This allows users to specify the organization to which they intend to\n   authenticate. If this parameter is omitted, an organization is chosen\n   automatically.\n * Added a new 'organizationId' field to the response on POST /session. This\n   indicates the organization to which the user has authenticated.\n * Added a new field 'moid' on GET /vmware/vm. This allows users to search\n   VMWare VMs by Managed Object ID. The list of results of the call can now\n   additionally be sorted in ascending/descending order by moid.\n * Added new fields 'replicas' and 'availabilityGroupId' on GET /mssql/db\n   and GET /mssql/db/{id}. If a database is an availability database,\n   it will have some number of replicas, which are copies of the database\n   running on different instances. Otherwise, there will only be one\n   replica, which represents the single copy of the database. The field\n   'availabilityGroupId' will be set only for availability databases\n   and points to the availability group of the database. Also deprecated\n   several fields on these endpoints, as they should now be accessed via\n   the 'replicas' field.\n * Added a field 'cloudInstantiationSpec' on GET /vmware/vm and PATCH\n   /vmware/vm/{id} to allow enabling/disabling/updating specs for automatic\n   conversion to cloud image on a per VM basis\n * Added a new optional query parameter 'availabilityGroupId' to GET /mssql/db,\n   in order to filter databases by their availability group ID.\n * Added a new field 'timezone' to GET /cluster/{id} and PATCH /cluster/{id}.\n   These calls show and change, the current time zone setting of the cluster.\n * Add a new field 'ignoreErrors' to POST /vmware/vm/snapshot/{id}/restore_file\n   that will let job to ignore file errors during restore jobs.\n * Added `Asia/Kolkata` and `Asia/Kathmandu` as supported cluster time zones.\n\n ### Changes to V1 API in Rubrik version 4.0\n\n New features:\n * Added a new field 'name' on GET /sla_domain. This allows users to search\n   SLA Domains by name. Users can also sort the SLA Domain summary results\n   in ascending/descending order by name\n * The Rubrik cluster generates a unique ID for each virtual machine when a\n   vCenter Server is added. When a virtual machine changes to another vCenter\n   Server or unregisters and registers with the same vCenter Server, a new\n   unique ID is generated for that virtual machine. When this happens, the\n   virtual machine object associated with the original ID becomes a relic.\n   In this release we have added the option conflictResolutionAuthz to\n   add/edit vCenter endpoints of the Rubrik REST APIs. This option can take\n   either 'AllowAutoConflictResolution' to authorize the linking of relic\n   virtual machine objects with the current virtual machine object of a\n   specific virtual machine, and makes the collective snapshot history\n   available through the current object. Or it can take 'NoConflictResolution'\n   to not allow linking. Default value is 'NoConflictResolution'.\n * Introduced endpoints for SQL Server Live Mounts: POST /mssql/db/{id}/mount,\n   GET /mssql/db/mount, GET /mssql/db/mount/{id}, and\n   DELETE /mssql/db/mount/{id}. These allow users to create, query for, and\n   delete Live Mounts for SQL Server databases.\n * Added the isLiveMount field to the response of GET /mssql/db. Added an\n   optional is_live_mount query parameter to filter by this field.\n * Added links field to the paginated responses of\n   GET /vmware/vm, /vmware/vm/mount and /fileset endpoints. This allows users\n   to navigate between pages by following the href in links.prev and links.next.\n * Introduced optional caCerts parameter for the vCenter post/put/patch\n   endpoints to specify trusted CA certs to use when connecting to a vCenter\n   server and associated ESX hosts.\n * Modified PATCH /mssql/instance/{id} endpoint to support SQL db\n   auto-protection, added fields configuredSlaDomainId,\n   logBackupFrequencyInSeconds, logRetentionHours, and copyOnly to the PATCH\n   request, as well as configuredSlaDomainId, configuredSlaDomainName,\n   logBackupFrequencyInSeconds, logRetentionHours, and copyOnly to the GET and\n   PATCH responses.\n * Added GET /vmware/vcenter/{id} endpoint to allow fetching details of a\n   single vCenter server, including its refresh and delete status.\n * Introduced optional parameter keepMacAddresses to\n   POST /vmware/vm/snapshot/{id}/mount, /vmware/vm/snapshot/{id}/export, and\n   /vmware/vm/snapshot/{id}/instant_recovery endpints.\n   This allows new VMs to have the same MAC address as their source VMs.\n * Introduced optional parameters offset and limit to support\n   pagination for Browse end-point.\n * Added `nodeId` to `AsyncRequestStatus` to improve debugging job failures.\n\n\n ### Changes to V1 API in Rubrik version 3.2\n\n New features:\n * Added an option to preserve the virtual machine moid during instant recovery.\n   Use this option cautiously. It will permanently overwrite the source\n   virtual machine. The source virtual machine cannot be recovered if the\n   operation fails. It will not create a new virtual machine and rename\n   the original one so we could fall back to the original in case of a failure\n   in the process. This is not exposed in the Web UI and the API user should\n   be careful to not destroy the original virtual machine by accident.\n * Introduced shareId into /fileset endpoints to support\n   the creation of filesets based on network shares.\n * Introduced optional config parameter for all on demand\n   snapshot endpoints. The config parameter includes an optional slaId field.\n   The policies of the specified SLA Domain determine the retention of backups\n   on the local Rubrik cluster, the retention target, and the archival location.\n * Introduced optional parameters to endpoint /mssql/db/{id}/export,\n   so that physical filenames and logical filenames can be changed\n   for exported databases. These two parameters are newFilename and\n   newLogicalName.\n * Introduced optional config parameter for the VM patch endpoint\n   (PATCH /vmware/vm/{id}) to specify a guest credential for a\n   specific VM.\n * Introduced optional query parameters to endpoint /host, to\n   support infix searching by hostname and sort order of results.\n * Introduced slaId and slaName field to all snapshot summary/details object.\n   These fields specify the SLA Domain object that is associated with the\n   snapshot.\n\nBug Fixes:\n * Made path parameter required in GET /fileset/snapshot/{id}/browse\n   and GET /vmware/vm/snapshot/{id}/browse. Previously, an error was\n   thrown when path wasn't passed in. This solves that bug.\n\n ### Changes to V1 API in Rubrik version 3.1\n Initial GA release\n\n# Overview #\nThe Rubrik REST API provides a means to work with Rubrik clusters and Rubrik Edge virtual appliances using text-based representations of the resource objects that are managed by the Rubrik software.\n\nIn its simplest form, the RESTful architecture used by the Rubrik REST API has the following workflow:\n1. Client authenticates with the Rubrik REST API server and starts a session.\n2. Client sends an HTTP request to the URI for a resource object.\n3. Server handles the request and sends an HTTP response with a JSON formatted response body.\n\nThis overview section provides a basic description of the HTTP requests and responses used with the Rubrik REST API. The [Authentication](#section/Authentication) section provides information about how a client authenticates with the Rubrik REST API server.\n\n## Documentation conventions\n\nThe descriptions in this documentation use 'Rubrik cluster' to refer to both Rubrik clusters and Rubrik Edge virtual appliances.\n\nThe documentation uses a dollar symbol to indicate a variable in body text and code samples. Some examples:\n* `$cluster_address` to represent a Rubrik cluster IP or resolvable host name\n* `$snapshot_id` to represent the ID of a specific snapshot\n* `$request_id` to represent the ID of a specific asynchronous request\n\nTo shorten the path shown in a code sample, the documentation sometimes replaces a longer variable form with the variable form `{id}`. This variable form represents the `id` value for an associated member string in a response body or request URL.\n\nThe documentation use the term 'snappable' to refer to all objects that have data that can be protected by a Rubrik cluster or a Rubrik Edge appliance. For example, all of the following are 'snappables':\n* Virtual machines\n* File systems\n* SQL Server databases\n\n## Versioning\n\nThe Rubrik REST API structures the request URL to include the version of the API. This ensures that backwards incompatible improvements in a new version are not unintentionally used with an earlier version of the API.\n\nThe URL of a request includes a segment that identifies the version of the API. In the URL, the version segment always follows immediately after the Rubrik REST API server name or IPv4 address.\n\nFor example, for a Rubrik cluster with the server address `$cluster_address` a request to the cluster endpoint for Rubrik REST API v1 would look like this:\n`https://$cluster_address/api/v1/cluster`\n\nIn this URL, the `v1` represents the version number for Rubrik REST API v1.\n\nThe Rubrik REST API increments the version number when the new version includes a change that is not backward compatible.\n\nExamples of changes that are not backward compatible include:\n* Resource type removed\n* Required parameter added to an existing resource type\n* Required parameter removed from an existing resource type\n* Renamed resource or parameter\n* Authentication requirement added for a previously unauthenticated resource\n\nWhen the Rubrik REST API has changes that are not backward compatible, those changes appear in a new version. For example, incompatible changes to v1 appear in v2. The Rubrik REST API server makes v2 endpoints available on the path: `https://$cluster_address/api/v2/`. The Rubrik REST API server continues to provide the v1 endpoints on the path: `https://$cluster_address/api/v1/`.\n\n### Changes within a version\n\nBackward compatible changes can be added to the Rubrik REST API as part of an update of the Rubrik CDM software on a Rubrik cluster or Rubrik Edge appliance. When this occurs, the version number remains the same and the URL segment that identifies the API version does not change. The [Changelog](#section/Changelog) that is provided in the docs for each version of the Rubrik REST API describes the changes that are made within that version.\n\nExamples of backward compatible changes include:\n* New API resource added\n* New optional request parameters added to existing resources\n* New properties added to existing responses\n\n## Architecture\n\nThe Rubrik REST API architecture centers around logical entities called *resource objects*. Resource objects can be discrete entities or can contain a hierarchy of other, dependent, resource objects. A dependent, or child, resource object is referenced through the parent object.\n\nFor example, a virtualization environment is a resource object that contains virtual machines as child resource objects. The virtual machines, in turn, contain snapshots as child resource objects. To address this hierarchy, the path to a snapshot must include the parent objects.\nAs shown here those parent objects are the virtualization environment (`vmware`) and the virtual machine (`vm`): `/vmware/vm/snapshot`.\n\nWhen a request addresses a specific resource object the path must include the  `id` of that specific object.\n\nFor example, to address a specific snapshot with the `id` value of `123-456` the path would be: `/vmware/vm/snapshot/123-456`.\n\nThe full URL for the request would be: `https://$cluster_address/api/v1/vmware/vm/snapshot/123-456`\n\nThe path in this example points to a specific snapshot with the `id` value of `123-456`.\n\nThe `id` is an opaque value which is generated by the Rubrik REST API. It does not follow any specific format.\n\n### API base path\n\nEach endpoint in the Rubrik REST API exists on one of two possible base paths:\n* `https://$cluster_address/api/v1/`\n* `https://$cluster_address/api/internal/`\n\nThe `/api/v1` base path provides the most commonly used endpoints. Rubrik considers these endpoints to be stable. Rubrik designs new releases of the Rubrik REST API to provide as much backward compatibility for these endpoints as possible. After an upgrade to a new version of the Rubrik CDM software, or to a new version of the Rubrik REST API, existing calls to endpoints on the `/api/v1` base path will normally continue to work.\n\nThe primary purpose of the `/api/internal` base path is to provide endpoints that are used by the Rubrik cluster. These endpoints are *internal* in the sense that the Rubrik CDM software uses them to provide a wide variety of cloud data management features. The evolution and improvement of the Rubrik CDM software can cause changes to these endpoints, removal of these endpoints, or addition of new `/api/internal` endpoints. Rubrik does not attempt to make the `/api/internal` endpoints backward compatible.\n\n### Requests\n\nTo perform a task, the Rubrik REST API uses an HTTP request. Most requests perform one of these actions:\n* Get an instance of an object from a list\n* Add an instance of an object to a list\n* Perform an operation on an object using the `id` of the object.\n\nThe following table describes the HTTP method and endpoint excerpts for some typical HTTP requests.\n\n**Note:** The endpoints shown here would be appended to the base URL: `https://$cluster_address/vmware`.\n\n| Method | Endpoint | Description |\n| ------ | --- | ----------- |\n| GET | `/vm/snapshot` | Returns a list of snapshots. |\n| POST | `/vm/snapshot` | Creates a new snapshot resource object. |\n| GET | `/vm/snapshot/{id}` | Returns information about the snapshot that is identified by `id`. |\n| PATCH | `/vm/snapshot/mount/{id}` | Changes the power status of the mounted snapshot that is identified by `id`. |\n| PUT | `/vcenter/{id}` | Provides a request body with a complete update of the properties of the vCenter Server object that is identified by `id`. |\n| DELETE | `/vm/snapshot/{id}` | Deletes the snapshot that is identified by `id`. |\n| GET | `/vm/{id}/missed_snapshot` | Returns the value of `missed_snapshot` for a snapshot that is identified by `id`. |\n| POST | `/vm/snapshot/{id}/mount` | Performs a `mount` operation using the snapshot that is identified by `id`. |\n\n#### Reserved ID alias\n\nThe alias `me` can be used with some endpoints as a shorthand replacement for the current, or local, value of that resource object type. For example, for the resource object type `/cluster` the alias `me` can be substituted for the `id` of the Rubrik cluster that is hosting the current session. For the resource object type `/session` the alias `me` can be substituted for the `id` of the current session.\n\nIn filters, use the alias `local` to refer to the Rubrik cluster that is hosting the current session.\n\n#### Timestamp\n\nThe Rubrik REST API uses a timestamp to express all time values. The timestamp meets the standards of ISO 8601 and uses Coordinated Universal Time (UTC). Timestamps take the form: YYYY-MM-DDTHH:MM:SSZ, with YYYY for the four digit year value, MM for the two digit month value, DD for the two digit day of the month value, HH for the two digit hour value using a 24-hour clock, MM for the two digit minute value, and SS for the two digit second value. The T stands for time and the Z stands for Zulu time, another name for UTC.\n\n**Example:** Timestamp in a JSON-formatted response body\n\n```bash\n{\n  \"createdTimestamp\": \"2016-02-11T18:02:24Z\"\n}\n```\n\n### Responses\n\nThe Rubrik REST API server responds to all requests by sending an HTTP response message. The response contains a status code and, when appropriate, a JSON object in the response body.\n\n#### Status codes\n\nThe Rubrik REST API server includes an HTTP status code with every response. The following table describes the status codes supported by the Rubrik REST API server.\n\n| Status code | Description |\n| ----------- | ----------- |\n| 200&nbsp;OK | Request succeeded. Not used for a DELETE request, or for a POST request that creates a resource. |\n| 201&nbsp;Created | POST request to create a resource object succeeded. |\n| 202&nbsp;Accepted | Request was successfully accepted for further processing. |\n| 204&nbsp;No&nbsp;Content | Request succeeded and the response body is empty. Used for successful DELETE requests and for successful POST requests that do not return content. |\n| 400&nbsp;Bad&nbsp;Request | Request failed because it was malformed. The request may be garbled, or it may be missing required parameters. |\n| 401&nbsp;Unauthorized | The requestor has insufficient authorization to perform the requested action. |\n| 403&nbsp;Forbidden | The requested action is blocked in the current context. |\n| 404&nbsp;Not&nbsp;Found | The request references a resource object that is unknown to the Rubrik REST API server. |\n| 415&nbsp;Unsupported Media Type | The HTTP header of the request specifies a media type that is not supported by the Rubrik REST API server. |\n| 422&nbsp;Unprocessable Entity | The request specifies a correct media type and contains correct syntax but cannot be processed because of semantical errors. |\n| 500&nbsp;Internal Server Error | The Rubrik REST API server encountered an unhandled error. |\n| 503&nbsp;Service Unavailable Error | The Rubrik REST API server is temporarily unavailable. |\n\n#### Response body\n\nThe JSON object included in a response body can contain members (`{string : value}`) and arrays (`[elements]`). Also, members and arrays can be nested within members and arrays.\n\nWhen a response includes a resource object, the object always includes an `id` member in the form `id : $id`. The value of the `id` member is the unique ID of the resource.\n\nWhen a response includes a large array (or list) of elements, the Rubrik REST API server encloses the array in a `ListResponse` structure. The `ListResponse` structure breaks a lengthy array into 'pages' of information to make the information easier to manage. Refer to 'Working with lists' for information about managing arrays with large numbers of values.\n\n#### Status code 400 responses\n\nThe Rubrik REST API server sends a response containing the HTTP status code '400 Bad Request' when the server cannot process the request. This can be caused by malformed request syntax, invalid request message framing, or deceptive request routing.\n\nThe Rubrik REST API server returns a '400 Bad Request' when:\n* Request does not conform with the format specified in OpenAPI definition files. For example, the request is missing required fields.\n* Request is malformed. For example, the request has a malformed `id`.\n* Request contains unsupported `enum` values.\n\n#### Status code 422 responses\n\nThe Rubrik REST API server sends a response containing the HTTP status code '422 Unproccessable entity' when the request is syntactically correct but has semantic errors.\n\nFor example, when a request refers to an archival location that is not available. Although the request is properly formed, the Rubrik REST API server cannot act on the request because of the missing archival location, and the server returns '422 Unproccessable entity'.\n\nThe Rubrik REST API server also returns '422 Unproccessable entity' when invalid credentials are submitted during login. In that situation, the request may be correctly formed but the action cannot be completed by using the supplied values.\n\nThe following table describes the members of a '422 Unproccessable entity' response object.\n\n| Member | Optional | Description |\n| ------ | --- | ----------- |\n| `type` | No | Error category. Possible values include: vcenter_error, oracle_error, rubrik_error |\n| `message` | No | Plain text explanation of the cause of the error. |\n| `code` | Yes | A short text string representing the cause of the error. |\n| `param` | Yes | The request member that is the source of the error, such as `backup_window`. |\n\n## Working with lists\n\nWhen a request returns a large list of elements, the response array can be encapsulated within a `ListResponse` object. The `ListResponse` object is a pagination structure for the elements in the response array. The `ListResponse` object allows the response array to be addressed through smaller subsets of the array, or 'pages'.\n\nTo work with a `ListResponse` object, form a request that calls for a specific page of the results by specifying an offset value and a limit. The response includes the elements from the list starting at the offset value and continuing to the limit. When the limit is very large, or unspecified, the Rubrik REST API server returns as many elements as can be handled by the available memory.\n\nThe `ListResponse` object consists of the members described in the following table.\n\n| Member | Optional | Description |\n| ------ | --- | ----------- |\n| `hasMore` | No | Indicates whether the array contains elements that are not provided by the current response. `true` if more elements are available for the original request and `false` if the last element is in the current response. |\n| `data` | No | An array of the requested elements. Can be all or some of the elements requested. The elements can be members, arrays, or objects. |\n| `total` | Yes | Total number of elements. |\n| `links` | Yes | When `hasMore` is true, provides a request URL for the next page of results. When appropriate, also provides a request URL for the previous page of results. The request URLs provided by `links` retain the query parameters from the original request. For example, a request URL would retain a value specified by `limit` and a value specified by `search`. The exception to this is the value specified by `offset`, which the Rubrik REST API server uses to specify next and previous pages. |\n\nControl the contents of a `ListResponse` object by including the following optional query parameters with the original request:\n* `limit`\nDefines the maximum number of a elements to include in the `data` array of the response. Available memory may prevent the return of all elements for very large `limit` values. When that occurs, the response includes `\"hasMore\": true`.\n* `offset`\nIndex reference point to use when determining the elements to include in a response. Include the next element after the index number specified by `offset`. The default value is `0`, which means the list page that is provided in the response starts with first element in the list.\n\nFor example, if the total number of elements in response to a query are 100, and the request includes the following query parameters: `limit=10` and `offset=30`, then the response will include a list page with elements 31-40.\n\nWhen the `ListResponse` object provides `next` and `prev`, use the URL specified by `next` to request the next page of elements or use the URL specified by `prev` to request the previous page of elements.\n\n**Example:** Request for all snapshots from a Rubrik cluster\n\nThe initial request uses the query parameter `limit=1`.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1\"\n```\n\nThe response returns the first element and `\"hasMore\": true` indicates that more than one snapshot meets the request.\n\n```bash\n{\n  \"hasMore\": true,\n  \"status\": \"RUNNING\",\n  \"data\": [\n    {\n      \"id\": \"1\",\n      \"name\": \"Windows2012\"\n    }\n  ],\n  \"links\": {\n    \"next\": {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&offset=1\"\n    }\n  }\n}\n\n```\n\nTo obtain the next element, the request is reissued with the query parameters set to: `limit=1&offset=1`. This could also be achieved by using the URL specified by `next` to request the next page.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&offset=1\"\n```\n\nThe response returns the second element in the array. Since there are elements before and after the element in the response, the `links` member contains both a `next` request URL and a `prev` request URL.\n\n```bash\n{\n  \"hasMore\": false,\n  \"status\": \"RUNNING\",\n  \"data\": [\n    {\n      \"id\": \"2\",\n      \"name\": \"Windows2016\"\n    }\n  ],\n  \"links\": {\n    \"prev\": {\n       \"href\": \"https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&offset=0\",\n      \"rel\": \"prev\"\n    },\n    \"next\": {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&offset=2\",\n      \"rel\": \"next\"\n    }\n  }\n}\n```\n\n## Asynchronous requests\n\nThe Rubrik REST API server uses asynchronous (async) API requests for tasks that take longer to run. By using async requests the Rubrik REST API server avoids blocking the requestor from performing other tasks while the async tasks run.\n\nThe response to an async request includes a task object in the response body. The following table describes the members of a task object.\n\n| Member | Optional | Description |\n| ------ | --- | ----------- |\n| `id` | No |  ID assigned to the task.  |\n| `status` | No |  Status of the task: 'RUNNING', 'SUCCEEDED', 'CANCELED', or 'FAILED'.   |\n| `error` | No | Message describing reason for canceled or failed task, or 'None'. |\n| `startTime` | Yes | Timestamp when the Rubrik cluster schedules the task. |\n| `endTime` | Yes | Timestamp when the task ends. |\n| `progress` | Yes | Percentage of the task that is complete. |\n| `links` | No | Polling request array that provides information about how to poll the task. |\n\nThe following table describes the polling request array in the `links` member.\n\n| Member | Optional | Description |\n| ------ | --- | ----------- |\n| `href` | No | URL to send requests to when polling the task. |\n| `rel` | No | Provides a value of 'self' to indicate that the array refers to the resource represented by the parent JSON object. |\n\nWhen an async task is completed the Rubrik REST API server adds a second array to the `links` member in the response that is sent. The second array provides information about how to request the result of the async task.\n\nThe following table describes the results array in the `links` member.\n\n| Member | Optional | Description |\n| ------ | --- | ----------- |\n| `href` | No | URL to send a request to for the result of the task. |\n| `rel` | No | Provides a value of 'result' to indicate that the array refers to the resource represented by the parent JSON object. |\n\n**Example:** Starting a mount task and polling the task status\n\nTo initiate a mount operation, send a POST request to the mount endpoint. Include an object containing the details of the snapshot.\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/mount\"\n```\n\nThe Rubrik REST API server returns a task object for the mount operation. The task object describes the task status as 'RUNNING' and provides the `links` member which contains the polling request array.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"RUNNING\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\nUsing the information provided in the task object, send a GET request to poll the task status.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"RUNNING\",\n  \"error\": \"None\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\nContinue to poll the task object until the status changes to 'SUCCEEDED'.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\"\n```\n\nWhen the task object status changes to 'SUCCEEDED', the `links` member of the request includes a results array that provides a URL for the task results.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"SUCCEEDED\",\n  \"error\": \"None\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",\n      \"rel\": \"self\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/$mounted_vm_id\",\n      \"rel\": \"result\"\n    }\n  ]\n}\n```\n\n# OpenAPI\nThe Rubrik REST API specification conforms to the OpenAPI 2.0 Specification. Tools that work with the OpenAPI 2.0 Specification can be used with the Rubrik REST API specification.\n\nDevelopment releases (pre-1.0) of the Rubrik REST API specification made reference to 'swagger'. The previous release of the OpenAPI 2.0 Specification was named the Swagger 1.2 Specification.\n\nDownload the Rubrik REST API specification for your tools. [Download](./api-docs)\n\n## Rubrik REST API Explorer\nThe Rubrik REST API Explorer is a browser-based API client hosted by the Rubrik cluster. The Explorer has the Rubrik REST API specification built in. You can use the Explorer to try out Rubrik REST API calls and view the responses.\n\n**IMPORTANT:** The Explorer interacts with the Rubrik cluster through the API calls you make. Use care when making calls that modify or delete configurations and data.\n\nTo access the Rubrik REST API Explorer, click: [Rubrik REST API Explorer](./playground/)\n\n# Authentication\n\nThe Rubrik REST API server requires that all API calls use the HTTPS protocol.\nTo meet the security requirements of that protocol, the Rubrik REST API server\nuses a self-signed certificate. A Certificate Authority cannot validate a\nself-signed certificate. Configure client tools to ignore the certificate\nvalidation error.\n\nThe Rubrik REST API server requires authentication and authorization for each\nAPI call, except calls made to the following endpoints:\n\n* [/cluster/me/version](#operation/getClusterVersion)\n* [/cluster/me/api_version](#operation/getClusterApiVersion)\n\n## Authentication session\nRubrik REST API server authenticates a session using either of the following\nmethods:\n\n* BasicAuth\n* Token\n\nThe Rubrik REST API server requires that you use an authorized username and\npassword for the Rubrik cluster. Usernames are managed by either the Rubrik\ncluster or by your LDAP service.\n\n### BasicAuth authentication\n\nBasicAuth authentication uses the HTTP Basic Authentication method and requires\nyou to include the user credentials with each API call. Since each API call\nmade using the BasicAuth method is separately authenticated, you do not need\nto manage the session state. You also do not need to log out of a session,\nsince this method does not create a session.\n\nTo use the BasicAuth method, provide the user credentials in the\n'Authorization' header of an API call.\n\nUse the string `Basic` followed by the Base64 encoding of `<username:password>`\nas the user credentials, where `<username:password>` is the username for an\nAdmin account on the host Rubrik cluster, a colon, and the account password.\n\n**Example:** Using curl to retrieve a session ID\n\nThis example uses the local Admin username 'admin' and the password 'pass' to\nretrieve: a session ID, the Rubrik server software version, and the API\nversion.\n\nThe curl command shown here takes `<username:password>`, adds 'Basic ' to the\nstring, and Base64 encodes the result.\n\n The command includes the following arguments:\n * `-k` to bypass an alert about the self-signed certificate\n * `-u` to flag the `<username:password>` string\n * `-X` to flag the HTTP method `GET`\n\n```bash\ncurl -k -u admin:pass -X GET \"https://$cluster_address/api/v1/cluster/me\"\n```\nThe Rubrik REST API server returns the following response body.\n```bash\n{\n  \"id\": \"$cluster_id\",\n  \"version\": \"3.1.0\",\n  \"apiVersion\": \"1.0\"\n}\n```\n\n### Token authentication\n\nToken authentication creates a token at the beginning of a session and then\nuses that token to authenticate the API calls that are made during the session.\nThe token remains valid for the session - normally 30 minutes after the last\nactivity. You can close a session and invalidate the session token at any time\nby making a DELETE call to `/session/{id}` where `{id}` is the session ID or\n`me` for the current session ID.\n\n**Example:** Token authentication in a session\n\nThis example uses the local Admin username 'admin' and the password 'pass'. To\nopen a session, first use the [BasicAuth](#section/BasicAuth) method to\nauthenticate a POST call to [/session](#operation/createSession).\n\n```bash\ncurl -k -u admin:pass -X POST \"https://$cluster_address/api/v1/session\"\n```\n\nThe response body includes an array with the session token.\n\n```bash\n{\n  \"id\": \"$session_id\",\n  \"token\": \"$token_id\",\n  \"userId\": \"$user_id\"\n}\n```\nFor all subsequent calls during the session, include the token in the\nAuthorization header using the form: `Authorization: Bearer $token_id` where\n`$token_id` is the value of the `token` member from the response array.\n\nIn this curl command, the GET request to\n[/cluster](#operation/getPublicClusterInfo) uses `-H` to provide the\n`Authorization: Bearer $token_id` value.\n\n```bash\ncurl -k -H \"Authorization: Bearer $token_id\" -X GET\n  \"https://$cluster_address/api/v1/cluster/me\"\n```\n\nThe response body contains an array with the session ID, the Rubrik\ncluster software version, and the API version.\n\n```bash\n{\n  \"id\": \"$cluster_id\",\n  \"version\": \"3.1.0\",\n  \"apiVersion\": \"1.0\"\n}\n```\n\nTo close the session and invalidate the session token, make a DELETE call to\n[/session](#operation/deleteSession) using the value of the `id` key or use\n`me`. The alias `me` represents the session specified in the Authorization\nheader.\n\n```bash\ncurl -k -H \"Authorization: Bearer $token_id\" -X DELETE\n  \"https://$cluster_address/api/v1/session/me\"\n```\n\n## LDAP Authentication\n\nThe Rubrik cluster can be integrated with an LDAP service for\nauthentication. The API endpoints provide support for adding, updating and\ndeleting a specific LDAP service as well as list all of the\nconfigured LDAP services.\n\n### Add a new LDAP service\nYou can add a new LDAP service by making a POST call to\n[/ldap_service](#operation/createLdapService). Adding a new LDAP\nservice requires information about the dynamic DNS name of the service, an\nadministrative user who is authorized to create a computer user account as\nwell as search for all the LDAP objects needed for use by the\nRubrik cluster. The Rubrik cluster resolves the dynamic DNS name using DNS\nSRV records while honoring the advertised priority values.\n\n**Example:** Adds a new LDAP service for use by the Rubrik cluster\n\nThis example adds an LDAP service that uses a dynamic DNS name\nof *example.com*, with a bind administrator user of *Administrator* with a\npassword of *VerySafe*.\n\n```bash\ncurl -k -u admin:pass -X POST -d '{\"dynamicDnsName\": \"example.com\",\n  \"bindUserName\": \"Administrator\", \"bindUserPassword\": \"VerySafe\"}'\n  'https://$cluster_address/api/v1/ldap_service'\n```\n\nThe response body includes the ID associated with this LDAP service.\n\n```bash\n{\n  \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n  \"domainType\": \"AD\",\n  \"name\": \"example.com\",\n  \"serviceAccount\": \"cluster10-c8D7A54$\",\n  \"initialRefreshStatus\": \"ongoing\"\n}\n```\n\nThe parameters associated with the LDAP service can be updated by\nmaking a PATCH request to [/ldap_service/{id}](#operation/patchLdapService)\nor a PUT request to [/ldap_service/{id}](#operation/putLdapService).\n\nFor example, you could add a prioritized list of authentication servers that\nsupercede the LDAP servers advertised for the dynamic DNS name. These\nauthentication servers can even be proxies that connect to the actual\nLDAP servers.\n\n**Example:** Add two new LDAP services\n\nThis example adds two LDAP servers called ad-proxy1.example.com\nand ad-proxy2.cloud.example.com.\n\n```bash\ncurl -k -u admin:pass -X PATCH -d '{ \"authServers\":\n[\"ldap://ad-proxy1.example.com:389\", \"ldap://ad-proxy2.example.com:389\"]}'\nhttps://$cluster_address/api/v1/ldap_service/499aeb71-f114-45a5-8456-91b9f6c45ddd\n```\n\nThe response body confirms a successful update.\n\n```bash\n{\n  \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n  \"domainType\": \"AD\",\n  \"name\": \"example.com\",\n  \"initialRefreshStatus\": \"success\"\n}\n```\n\n### List configured LDAP services\nYou can get a listing of all the configured authentication domains using\na GET request to [/ldap_service](#operation/queryLdapService).\n\n**Example:** Get the list of LDAP services.\n\n```bash\ncurl -k -u admin:pass -X GET 'https://$cluster_address/api/v1/ldap_service'\n```\n\nThe response body will contain the ID of all the authentication realms.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n      \"domainType\": \"AD\",\n      \"name\": \"example.com\",\n      \"serviceAccount\": \"cluster10-c8D7A54$\",\n      \"initialRefreshStatus\": \"success\"\n    },\n    {\n      \"id\": \"9fef084b-75f8-4c03-9efa-c73b55be5da8\",\n      \"domainType\": \"LOCAL\",\n      \"name\": \"local\",\n      \"initialRefreshStatus\": \"success\"\n    }\n  ],\n  \"total\": 2\n}\n\n```\n\n### Get information about a specific LDAP service\n\nYou can also get information about a specific LDAP service using\na GET request to [/ldap_service/{id}](#operation/getLdapService).\n\n**Example:** Get information about a configured LDAP service.\n\n```bash\ncurl -k -u admin:pass -X GET\n  'https://$cluster_address/api/v1/ldap_service/499aeb71-f114-45a5-8456-91b9f6c45ddd'\n```\n\nThe response body will contain information about the specified LDAP service.\n\n```bash\n{\n  \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n  \"domainType\": \"AD\",\n  \"name\": \"example.com\",\n  \"serviceAccount\": \"cluster10-c8D7A54$\",\n  \"initialRefreshStatus\": \"success\"\n}\n```\n\n### Delete an LDAP service\nAny LDAP service that is configured to a Rubrik cluster can\nbe removed by issuing a DELETE request to\n[/ldap_service/{id}](#operation/deleteLdapService).\n\n**Example:** Remove an LDAP service\n\n```bash\ncurl -k -u admin:pass -X DELETE\nhttps://$cluster_address/api/v1/ldap_service/499aeb71-f114-45a5-8456-91b9f6c45ddd\n\n```\n\n## SAML ID Provider Authentication\n\nThe Rubrik cluster can be integrated with a SAML ID Provider authentication\ndomain for authentication. The Rubrik REST API provides API endpoints for\nmanaging and configuring the ID Provider authentication domain with\nthe Rubrik cluster. The Rubrik REST API also provides API endpoints for\ncreating the SAML authentication request\nand handling the SAML authentication response.\n\n### Add a new SAML ID Provider Authentication Domain\nYou can add a new ID Provider by making a POST call to\n[/idp_auth_domain](#operation/createIdProviderAuthDomain).\nAdding a new ID Provider requires the ID Provider metadata XML file\nin base64 encoding, and a human-friendly name for the ID Provider.\n\n**Example:** Adds a new ID Provider for use by the Rubrik cluster\n\n```bash\ncurl -k -u admin:pass -X POST -d '{\"name\": \"new-idp\",\n  \"metadataXmlBase64\": \"1VZbj6LYFn438T9UPI+mi7slpqsnm2sBQgm...\"}'\n  'https://$cluster_address/api/v1/idp_auth_domain'\n```\n\nThe response body includes the ID associated with this Active Directory.\n\n```bash\n{\n  \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n  \"name\": \"new-idp\",\n  \"entityId\": \"http://www.example.com/idp1\",\n  \"ssoUrl\": \"https://www.example.com/idp1/sso\",\n  \"signCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDrDCCApSg...\\n-----END CERTIFICATE-----\"\n}\n```\n\n### Update an existing SAML ID Provider Authentication Domain\nThe name and metadata associated with the ID Provider can be updated by\nmaking a PATCH request to\n[/idp_auth_domain/{id}](#operation/updateIdProviderAuthDomain).\nThis API call can update either of the two parameters.\n\n**Example:** Update name of the ID Provider\n\nThis example update the name of ID Provider \"new-idp\" as \"updated-idp\",\nand update metadata with new ID Provider \"http://www.example.com/idp2\"\n\n```bash\ncurl -k -u admin:pass -X PATCH -d '{ \"name\": \"updated-idp\",\n  \"metadataXmlBase64\": \"1VZbj6AQwTIr4deKspU/zyR9fxqPPebgQ...\"}'\n  'https://$cluster_address/api/v1/idp_auth_domain/499aeb71-f114-45a5-8456-91b9f6c45ddd'\n```\n\nThe response body confirms a successful update.\n\n```bash\n{\n  \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n  \"name\": \"updated-idp\",\n  \"entityId\": \"http://www.example.com/idp2\",\n  \"ssoUrl\": \"https://www.example.com/idp2/sso\",\n  \"signCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDrDCCtchA...\\n-----END CERTIFICATE-----\"\n}\n```\n\n### List configured ID Provider Authentication Domains\nYou can get a listing of all the configured ID Providers using\na GET request to [/idp_auth_domain](#operation/queryIdProviderAuthDomain).\n\n**Example:** Get the list of ID Provider authentication domains.\n\n```bash\ncurl -k -u admin:pass -X GET 'https://$cluster_address/api/v1/idp_auth_domain'\n```\n\nThe response body contains the ID of all the ID provider\nauthentication domains.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n      \"name\": \"new-idp\",\n      \"entityId\": \"http://www.example.com/idp1\",\n      \"ssoUrl\": \"https://www.example.com/idp1/sso\",\n      \"signCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDrDCCApSg...\\n-----END CERTIFICATE-----\"\n    },\n    {\n      \"id\": \"9fef084b-75f8-4c03-9efa-c73b55be5da8\",\n      \"name\": \"another-idp\",\n      \"entityId\": \"http://www.example.com/idp2\",\n      \"ssoUrl\": \"https://www.example.com/idp2/sso\",\n      \"signCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDrDCCtchA...\\n-----END CERTIFICATE-----\"\n    }\n  ],\n  \"total\": 2\n}\n\n```\n\n### Get information about a specific SAML ID Provider Authentication Domain\nYou can also get information about a specific ID Provider using\na GET request to [/idp_auth_domain/{id}](#operation/getIdProviderAuthDomain).\n\n**Example:** Get information about a configured ID Provider.\n\n```bash\ncurl -k -u admin:pass -X GET\n  'https://$cluster_address/api/v1/idp_auth_domain/499aeb71-f114-45a5-8456-91b9f6c45ddd'\n```\n\nThe response body contains information about this ID provider\nauthentication domain.\n\n```bash\n{\n  \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",\n  \"name\": \"new-idp\",\n  \"entityId\": \"http://www.example.com/idp1\",\n  \"ssoUrl\": \"https://www.example.com/idp1/sso\",\n  \"signCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDrDCCApSg...\\n-----END CERTIFICATE-----\"\n}\n```\n\n### Delete an ID Provider Authentication Domain\nAny ID Provider authentication domain that is configured\nto a Rubrik cluster can be removed by issuing a DELETE request to\n[/idp_auth_domain/{id}](#operation/deleteIdProviderAuthDomain).\n\n**Example:** Remove the ID Provider authentication domain\n\n```bash\ncurl -k -u admin:pass -X DELETE\nhttps://$cluster_address/api/v1/idp_auth_domain/499aeb71-f114-45a5-8456-91b9f6c45ddd\n```\n\n### Download Rubrik SAML Metadata\nGenerate the Rubrik SAML service provider metadata file and\nget the URL of the file by issuing a GET request to\n[/saml/rubrik_metadata](#operation/configRubrikSamlMetadata).\n\n**Example:**  Generate the Rubrik SAML metadata file without providing\nan address for the host at the endpoint. The cluster chooses\na floating IP as the host address.\n\n```bash\ncurl -k -u admin:pass -X POST -d '{}'\n  'https://$cluster_address/api/v1/saml/rubrik_metadata'\n```\n\n**Example:** Generate the Rubrik SAML metadata file and specify\nan address for the host at the endpoint.\n\n```bash\ncurl -k -u admin:pass -X POST -d '{\"hostAddress\": \"my.rubrik.saml.sp.com\"}'\n  'https://$cluster_address/api/v1/saml/rubrik_metadata'\n```\n\n### Check SAML SSO Status ###\nSend a GET request to unauthenticated endpoint\n[/saml/sso_status](#operation/getSamlSsoStatus) to check SAML SSO status.\nThe status is represented by an object that contains 1) a Boolean value that\ndetermines whether or not SSO is enabled. 2) an optional String value that\nindicates the name of the default IdP authentication domain for SSO login.\nThe default IdP will be configured when there is only one IdP configured in\nthe cluster.\n\n**Example:** Check SAML SSO status\n\n```bash\ncurl -k -X GET 'https://$cluster_address/api/v1/saml/sso_status'\n```\n\n### Make SAML Authentication Request\nSend a POST request to [/saml/authn_request](#operation/makeSamlAuthnRequest)\nto generate a signed SAML authentication request for the authentication domain\nof a specified ID Provider. The request can include optional parameters to\nspecify a redirection resource path  and to specify that the request\nis a test of the configuration for the ID Provider. The response provides\nthe data that is required for a SAML SSO authentication request for\nthe ID Provider. This is an unauthenticated API.\n\n**Example:** Make the SAML authentication request for ID Provider my-idp-1\n\n```bash\ncurl -k -X POST https://$cluster_address/api/v1/saml/authn_request/my-idp-1\n  -d '{\"redirectPath\": \"/web/bin/index.html#/welcome\", \"isForIdpTest\": false}'\n```\n\n# Authorization\n\nThis section provides details on authorizing calls to the Rubrik CDM REST API.\n\n## Clearing the authorization cache\nStale authorization information cached on the Rubrik CDM API server can cause\nAPI call failures. Clearing the cache on the node targeted by an API call can\nprevent this error.\n\nTo clear the cache, send a DELETE request to the\n[`/authorization/cache`](#operation/deleteAuthzCache) endpoint.\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/authorization/cache\"\n```\n\n# Rubrik certificate management\n\nThis section explains how to manage certificates.\n\n## Retrieving all imported certificates\n\nTo retrieve all imported certificates from the cluster, send a GET request to\nthe [`/certificate`](#operation/queryCertificates) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/certificate\"\n```\n\nThe Rubrik REST API server returns an array of objects with the certId,\nthe name, the description, the certificate, whether the certificate has\na private key, the expiration time, and what objects are using the certificate.\n\n```bash\n{\n  \"certId\": \"$certId\",\n  \"name\": \"$certName\",\n  \"hasKey\": true,\n  \"expiration\": \"$certExpiration\",\n  \"usedBy\": {}\n}\n```\n\n## Importing a certificate\n\nTo import a certificate, send a POST request to the\n[`/certificates`](#operation/importCertificate) endpoint.\n\n```bash\ncurl -X POST -d '{\n  \"name\": \"certName\",\n  \"pemFile\": \"$pemFile\",\n  \"description\": \"$description\"\n}' \"https://$cluster_address/api/v1/certificate\"\n```\n\nThe Rubrik REST API server returns an object with the certId, the name,\nthe description, the certificate, whether the certificate has a private key,\nthe expiration time, and what objects are using the certificate.\n\n```bash\n{\n  \"certId\": \"$certId\",\n  \"name\": \"$certName\",\n  \"hasKey\": true,\n  \"expiration\": \"$certExpiration\",\n  \"usedBy\": {}\n}\n```\n\n## Retrieving a certificate\n\nTo retrieve a certificate, send a GET request to the\n[`/certificate/{id}`](#operation/exportCertificate) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/certificate/$cert_id\"\n```\n\nThe Rubrik REST API server returns an object with the certId, the name,\nthe description, the certificate, whether the certificate has a private key,\nthe expiration time, and what objects are using the certificate.\n\n## Updating a certificate\n\nTo update a certificate, send a PATCH request to the\n[`/certificate/{id}`](#operation/updateCertificate) endpoint.\n\n```bash\ncurl -X POST -d '{\n  \"name\": \"certName\",\n  \"pemFile\": \"$pemFile\",\n  \"description\": \"$description\"\n}' \"https://$cluster_address/api/v1/certificate/$cert_id\"\n```\n\nThe Rubrik REST API server returns an object with the certId, the name,\nthe description, the certificate, whether the certificate has a private key,\nthe expiration time, and what objects are using the certificate.\n\n## Generating a Certificate Signing Request (CSR)\n\nTo generate a CSR, send a POST request to the\n[`/csr`](#operation/generateCsr) endpoint.\n\n```bash\ncurl -X POST -d '{\n  \"hostnames\": \"$hostnames\",\n  \"name\": \"$name\",\n  \"organizations\": \"$organization\",\n  \"organizationUnit\": \"$organizationUnit\",\n  \"country\": \"$country\",\n  \"state\": \"$state\",\n  \"city\": \"$city\"\n}' \"https://$cluster_address/api/v1/csr\"\n```\nHostnames and name are required. The Rubrik REST API server will respond with\nthe information provided in the POST request, in addition to the CSR to be\nsigned.\n\n## Retrieving all outstanding Certificate Signing Requests\n\nTo retrieve all outstanding CSRs, send a GET request to the\n[`/csr`](#operation/getAllCsrs) endpoint.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/csr\"\n```\nThe Rubrik REST API server returns an array of objects with the csrId,\nthe name, the CSR, and all information provided to generate the CSR.\n\n## Deleting a Certificate Signing Request (CSR)\n\nTo delete a CSR, send a DELETE request to the\n[`/csr/{id}`](#operation/deleteCsr) endpoint.\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/csr/$csr_id\"\n```\n\n# Rubrik cluster management\n\nThis section explains how to retrieve basic information about a Rubrik cluster, as well as how to update the name of a cluster.\n\n## Retrieving Rubrik Cluster Information\n\n\n**Example:** Retrieving publicly available information about a Rubrik cluster\n\nTo retrieve information about a Rubrik cluster, send a GET request to the [`/cluster/$cluster_id`](#operation/getPublicClusterInfo) endpoint. The Rubrik REST API server responds with the publicly available information for the specified Rubrik cluster.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id\"\n```\n\nThe Rubrik REST API server returns an array with the session ID, the Rubrik cluster software version, the API version, the Rubrik cluster name, and the Rubrik cluster time zone.\n\n```bash\n{\n  \"id\": \"$cluster_id\",\n  \"version\": \"4.1.0\",\n  \"apiVersion\": \"1.0\",\n  \"name\": \"$cluster_name\",\n  \"timezone\": {\n    \"timezone\": \"$cluster_timezone\"\n  }\n}\n```\nTo retrieve the cluster certificate, send a GET request to the\n[`/cluster/{id}/certificate`](#operation/getClusterCertificate) endpoint.\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/certificate\"\n```\nTo request only the current software version of the Rubrik cluster, send a GET request to the [`/cluster/$cluster_id/version`](#operation/getClusterVersion) endpoint.\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/version\"\n```\n\nTo request only the current REST API version running on the cluster, send a GET request to [`/cluster/$cluster_id/api_version`](#operation/getClusterApiVersion)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/api_version\"\n```\n\nTo get the download link for Rubrik SNMP MIB file, send a GET request to [`/cluster/$cluster_id/snmp_mib_link`](#operation/getRubrikSnmpMibDownloadLink)\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/snmp_mib_link\"\n```\n\nTo retrieve the encryption at rest status of the cluster, send a GET request to the [`/cluster/$cluster_id/encryption`](#operation/getEncryptionStatus) endpoint.\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/security/encryption\"\n```\n\n## Changing the Rubrik cluster name or time zone\n\nTo change the name or the current time zone of a Rubrik cluster, send a PATCH request to the [`/cluster/$cluster_id`](#operation/updateCluster) endpoint.  Specify the new name as the value of `$cluster_name`, and specify the new time zone as the value of `$cluster_timezone`.\n\n**Example:** Changing the name and the time zone of a Rubrik cluster\n\n```bash\ncurl -X PATCH \\\n  -d '{ \"clusterName\": $cluster_name, \"timezone\": { \"timezone\": $cluster_timezone } }' \\\n  \"https://$cluster_address/api/v1/cluster/$cluster_id\"\n```\n\nThe response provides the attributes of the specified Rubrik cluster object, including the new name, and the new time zone.\n\n```bash\n{\n  \"id\": \"$cluster_id\",\n  \"version\": \"4.1.0\",\n  \"apiVersion\": \"1.0\",\n  \"name\": \"$cluster_name\",\n  \"timezone\": {\n      \"timezone\": \"$cluster_timezone\"\n  }\n}\n```\n\n# Passwords\n\n## Setting password requirements\n\nTo set cluster-wide password requirements, send a PATCH request to\n[`/cluster/{id}/security/password_requirements`]\n(#operation/patchPasswordRequirements).\nThe following parameters are optional:\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"id\": \"$cluster_id\",\n    \"minLength\": \"$min_length\",\n    \"minUpperCase\": \"$min_upper_case\",\n    \"minLowerCase\": \"$min_lower_case\",\n    \"minNumerics\": \"$min_numerics\",\n    \"minSpecial\": \"$min_special\",\n    \"useZxcvbn\": \"$use_zxcvbn\" }' \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/password_requirements\"\n```\n\nThe Rubrik REST API server responds with a summary of the password requirements:\n```bash\n{\n  \"id\": \"$cluster_id\",\n  \"minLength\": \"$min_length\",\n  \"maxLength\": \"$max_length\",\n  \"minUpperCase\": \"$min_upper_case\",\n  \"minLowerCase\": \"$min_lower_case\",\n  \"minNumerics\": \"$min_numerics\",\n  \"minSpecial\": \"$min_special\",\n  \"useZxcvbn\": \"$use_zxcvbn\"\n}\n```\n\n## Getting current password requirements\n\nTo retrieve the existing cluster-wide password requirments,\nsend a GET request to\n[`/cluster/{id}/security/password_requirements`]\n(#operation/queryPasswordRequirements)\n\n```bash\ncurl -X GET \\\n  -d '{\n    \"id\": \"$cluster_id\" }' \\\n  \"https://$cluster_address/api/v1/cluster/{id}/security/password_requirements\"\n\n```\n\nThe Rubrik REST API server responds with a summary of the password requirements:\n```bash\n{\n  \"id\": \"$cluster_id\",\n  \"minLength\": \"$min_length\",\n  \"maxLength\": \"$max_length\",\n  \"minUpperCase\": \"$min_upper_case\",\n  \"minLowerCase\": \"$min_lower_case\",\n  \"minNumerics\": \"$min_numerics\",\n  \"minSpecial\": \"$min_special\",\n  \"useZxcvbn\": \"$use_zxcvbn\"\n}\n```\n\n# Event\n\n## DO NOT USE. WILL RELEASE IN FUTURE.\n## Get latest events and event series info for event series\nSend a GET request to [`/event/latest`](#operation/queryLatestEventsV1)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/event/latest\"\n```\n\n## DO NOT USE. WILL RELEASE IN FUTURE.\n## Get information for all events\nSend a GET request to [`/event`](#operation/queryEventV1)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/event\"\n```\n## DO NOT USE. WILL RELEASE IN FUTURE.\n## Get all events and relevant information associated with an event series\nSend a GET request to [`/event_series/{id}`](#operation/queryEventSeriesByIdV1)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1//event_series/{id}\"\n```\n\n# SLA Domains\n\nRubrik clusters provide automated data management and protection through SLA Domains.\nAn SLA Domain defines the data management and protection policies for their assigned snappables (virtual machines, file systems, and applications).\n\nTo provide policy based management and protection of a snappable, add the snappable to an SLA Domain, or to multiple SLA Domains.\n\n## Retrieving SLA Domains\n\nBefore assigning snappables to SLA Domains, get a list of the SLA Domains that exist on a Rubrik cluster. For a new Rubrik cluster, the list shows only the default SLA Domains. When custom SLA Domains are added to the Rubrik cluster, the list is modified to include those SLA Domains.\n\n**Example:** Retrieving SLA Domains from a Rubrik cluster\n\nSend a GET request to [`/sla_domain`](#operation/querySlaDomain).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/sla_domain\"\n```\n\nThe Rubrik REST API server returns a `ListResponse` object of all SLA Domains.\nAt a minimum, the `ListResponse` object includes the default SLA Domains: Gold, Silver, and Bronze.\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$gold_sla_id\",\n      \"name\": \"Gold\"\n    },\n    {\n      \"id\": \"$silver_sla_id\",\n      \"name\": \"Silver\"\n    },\n    {\n      \"id\": \"$bronze_sla_id\",\n      \"name\": \"Bronze\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 3\n}\n```\n\nTo obtain more details about a specific SLA domain send a GET request with the `id` of one of the SLA Domains to the `/sla_domain/{id}` endpoint:  [`/sla_domain/{id}`](#operation/getSlaDomain)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/sla_domain/$bronze_sla_id\"\n```\nThe Rubrik REST API server responds with the details of the specified SLA Domain.\n\n```bash\n{\n  \"id\": \"$bronze_sla_id\",\n  \"primaryClusterId\": \"$cluster_id\",\n  \"name\": \"Bronze\",\n  \"frequencies\": [\n    {\n      \"timeUnit\": \"Daily\",\n      \"frequency\": 1,\n      \"retention\": 32\n    },\n    {\n      \"timeUnit\": \"Monthly\",\n      \"frequency\": 1,\n      \"retention\": 12\n    },\n    {\n      \"timeUnit\": \"Yearly\",\n      \"frequency\": 1,\n      \"retention\": 2\n    }\n  ],\n  \"allowedBackupWindows\": [],\n  \"firstFullAllowedBackupWindows\": [],\n  \"archivalSpecs\": [],\n  \"replicationSpecs\": [\n    {\n      \"locationId\": \"$repl_location_id\",\n      \"retentionLimit\": 0\n    }\n  ],\n  \"numDbs\": 0,\n  \"numFilesets\": 7,\n  \"numLinuxHosts\": 3,\n  \"numWindowsHosts\": 2,\n  \"numVms\": 1,\n  \"isDefault\": false,\n  \"uiColor\": \"#cc8366\"\n}\n```\n\n## Working with SLA Domains\n\nTo work with an SLA Domain, obtain the `id` of that SLA Domain. As described in [Retrieving SLA Domains](#section/SLA-Domains/Retrieving-SLA-Domains), start by sending a GET request to [`/sla_domain`](#operation/querySlaDomain).\n\nThe Rubrik REST API server responds with a `ListResponse` object that contains all of the SLA Domains on the specfied Rubrik cluster. From that list object, find the data array element that has the `name` value of the selected SLA Domain. In the same array element as the `name` value, note the value of the `id` string.\n\n## Creating SLA Domains\n\nTo create an SLA domain send a POST request to [`/sla_domain`](#operation/createSlaDomain). Include the attributes for the SLA Domain in the request body.\n\nThe following table describes the required and optional attributes to include in the request body when creating an SLA Domain.\n\n| Attribute | Req'd | JSON Type | Description |\n| ------ | --- | ----- | ----------- |\n| `name` | Yes | String | Name of the SLA Domain.  |\n| `frequencies` | Yes | Array | Each member defines a policy by specifying: `timeUnit`, `frequency`, and `retention`. Requires at least one member in the array.  |\n| `allowedBackupWindows` | Yes | Array | Each member defines a backup window using values for `startTimeAttributes` and `durationInHours`. The time specified in `startTimeAttributes` uses the Rubrik cluster time zone. To specify multiple backup windows, add an array member for each window. To create an SLA Domain without a backup window, specify a null array value: `[]`.  |\n| `firstFullAllowedBackupWindows` | Yes | Array | Each member defines a period when first full backups are allowed by specifying: `startTimeAttributes` and `durationInHours`. Several first full backup windows can be specified by adding an array member for each one. Create an SLA Domain without a first full backup window by specifying a null array value: `[]`.  |\n| `localRetentionLimit` | No | String | Specify an integer value to set the number of days to retain a local copy of a snapshot. When an archival location is specified, specify `0` to enable Instant Archiving. |\n| `archivalSpecs` | No | Array | Defines the archival location for the SLA Domain by specifying: `locationId` and `archivalThreshold`. Currently limited to one array member. |\n| `replicationSpecs` | No | Array | Defines the replication location for the SLA Domain by specifying: `locationId` and `retentionLimit`. Currently limited to one array member. |\n\n**Example:** Creating an SLA Domain for daily backups\n\nCreate an SLA Domain that takes a backup once a day and retains the backup for seven days. Do not set a backup window or a first full backup window. Do not include archival or replication.\n\n```bash\ncurl -X POST \\\n  -d '{\n  \"name\": \"Daily SLA\",\n  \"frequencies\": [\n    {\n      \"timeUnit\": \"Day\",\n      \"frequency\": 1,\n      \"retention\": 7\n    }\n  ],\n  \"allowedBackupWindows\": [],\n  \"firstFullAllowedBackupWindows\": [] }' \\\n  \"https://$cluster_address/api/v1/sla_domain\"\n```\nThe response confirms the attributes of the SLA Domain and provides the `id` of the new SLA Domain.\n\n```bash\n{\n  \"id\": \"$sla_id\",\n  \"name\": \"Daily SLA\",\n  \"frequencies\": [\n    {\n      \"timeUnit\": \"Day\",\n      \"frequency\": 1,\n      \"retention\": 7\n    }\n  ],\n  \"allowedBackupWindows\": [],\n  \"firstFullAllowedBackupWindows\": []\n}\n```\n## Modifying SLA Domains\n\nTo modify the attributes of an SLA domain send a PUT request to [`/sla_domain/{id}`](#operation/updateSlaDomain). Include in the request body the new attributes.\n\n**Example:** Modifying the daily backup SLA Domain\n\nChange the SLA Domain that was created in [Creating SLA Domains](#section/SLA-Domains/Creating-SLA-Domains) to increase the retention to 14 days.\n\n```bash\ncurl -X PUT \\\n  -d '{\n  \"name\": \"Daily SLA\",\n  \"frequencies\": [\n    {\n      \"timeUnit\": \"Day\",\n      \"frequency\": 1,\n      \"retention\": 14\n    }\n  ],\n  \"allowedBackupWindows\": [],\n  \"firstFullAllowedBackupWindows\": [] }' \\\n  \"https://$cluster_address/api/v1/sla_domain/$sla_id\"\n```\nThe response confirms the new attribute.\n\n```bash\n{\n  \"id\": \"$sla_id\",\n  \"name\": \"Daily SLA\",\n  \"frequencies\": [\n    {\n      \"timeUnit\": \"Day\",\n      \"frequency\": 1,\n      \"retention\": 14\n    }\n  ],\n  \"allowedBackupWindows\": [],\n  \"firstFullAllowedBackupWindows\": []\n}\n```\n## Patching SLA Domains\n\nTo patch the attributes of an SLA domain, send a PATCH request to\n[`/sla_domain/{id}`](#operation/patchSlaDomain). Include in the request body\nonly the attributes that needs to be patched.\n\n**Example:** Patching the daily backup SLA Domain\n\nPatch the SLA Domain that was created in [Creating SLA Domains]\n(#section/SLA-Domains/Creating-SLA-Domains) to change the archival\nspecifications.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n  \"archivalSpecs\": [\n    {\n        \"locationId\": \"some-valid-archived-location-id\",\n        \"archivalThreshold\": 14\n    }\n  ]}' \\\n  \"https://$cluster_address/api/v1/sla_domain/$sla_id\"\n```\nThe response confirms the new attribute and also includes the other\nattributes that were not changed.\n\n```bash\n{\n  \"id\": \"$sla_id\",\n  \"name\": \"Daily SLA\",\n  \"frequencies\": [\n    {\n      \"timeUnit\": \"Day\",\n      \"frequency\": 1,\n      \"retention\": 7\n    }\n  ],\n  \"archivalSpecs\": [\n    {\n      \"locationId\": \"some-valid-archived-location-id\",\n      \"archivalThreshold\": 14\n    }\n  ],\n  \"allowedBackupWindows\": [],\n  \"firstFullAllowedBackupWindows\": []\n}\n```\n## Deleting SLA Domains\n\nTo delete an SLA domain send a DELETE request to [`/sla_domain/{id}`](#operation/deleteSlaDomain).\n\n**Example:** Deleting an SLA Domain\n\nDelete an SLA Domain with the `id` of `$sla_id`.\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/sla_domain/$sla_id\"\n```\nThe Rubrik REST API server responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.\n\n## Inherited protection\n\nThe Rubrik REST API uses the reserved value `INHERIT` with the `configuredSlaDomainId` string to identify a snappable that derives its protection policy from a parent object. Examples of this:\n* VMware virtual machine inherits from vCenter Server\n* SQL Server database inherits from SQL Server instance\n\nEvery snappable that can be protected through an SLA Domain is represented by an object that has a `configuredSlaDomainId` attribute and an `effectiveSlaDomainId` attribute. The `configuredSlaDomainId` attribute contains either the value of a direct SLA Domain assignment or the reserved value `INHERIT`.\n\nThe `effectiveSlaDomainId` attribute contains the value of the SLA Domain setting that the Rubrik cluster actually applies to the snappable. When the value of the `configuredSlaDomainId` attribute is `INHERIT`, the value of the `effectiveSlaDomainId` attribute is derived from a parent object of the snappable. In all other cases, the value of the `effectiveSlaDomainId` attribute is the same as the value of the `configuredSlaDomainId` attribute.\n\n\n## SLA Domain assignments\n\nTo assign a snappable to an SLA Domain, use the endpoint that is provided for that type of snappable.\n* VMware virtual machines  \nSend a PATCH request to  [`/vmware/vm/{id}`](#operation/updateVm). [VMware virtual machines](#section/VMware-virtual-machines) provides more information about this.\n* Linux or Windows filesets  \nSend a PATCH request to  [`/fileset/{id}`](#operation/updateFileset). [Filesets](#section/Filesets) provides more information about this.\n* SQL Server databases  \nSend a PATCH request to  [`/mssql/db/{id}`](#operation/updateMssqlDb). [SQL Server databases](#section/SQL-Server-databases) provides more information about this.\n\n# Virtual machines\n\nThe Rubrik cluster protects virtual machines running in a VMware vSphere\nenvironment through the VADP APIs. The Rubrik cluster also works with\nthe Rubrik Backup Service running on the virtual machine to provide:\n\n* Optimal performance when restoring files and folders to the virtual machine\n* Application consistent snapshots of a Windows virtual machine\n\n\n## vCenter servers\n\nA Rubrik cluster normally protects and manages virtual machines through the vCenter Server that administers those virtual machines. After a vCenter server is added to a Rubrik cluster, the Rubrik cluster automatically discovers the virtual machines that are administered by that vCenter server.\n\n### Retrieving vCenter Servers\n\nRequest a list of the vCenter servers that are registered with a Rubrik cluster by sending a GET request to  [`/vmware/vcenter`](#operation/queryVcenter).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vcenter\"\n```\n\nThe Rubrik REST API server responds with the first page of a `ListResponse` object.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$vcenter_id0\",\n      \"hostname\": \"$vcenter_address0\",\n      \"username\": \"$vcenter_admin0\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"primaryClusterId\": \"$cluster_id\",\n      \"caCerts\": \"$ca_certs0\"\n    },\n    {\n      \"id\": \"$vcenter_id1\",\n      \"hostname\": \"$vcenter_address1\",\n      \"username\": \"$vcenter_admin1\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"primaryClusterId\": \"$cluster_id\",\n      \"caCerts\": \"$ca_certs1\"\n    }\n  ],\n  \"total\": 2\n}\n```\nDepending on the number of registered vCenter Servers, all of the entries on the list may not be included on the first page. [Working with lists](#section/Overview/Working-with-lists) describes how to work with a ListResponse object to obtain additional pages of the list.\n\n\n### Adding a vCenter server\n\nTo add a vCenter server, send a POST request to [`/vmware/vcenter`](#operation/createVcenter).\nInclude in the body of the request the address of the vCenter server and credentials for a user account (`username`) that has the required permissions. The Rubrik User Guide provides details about creating an account with the required permissions.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"hostname\": \"$vcenter_address\",\n    \"username\": \"$vcenter_admin\",\n    \"password\": \"$vcenter_password\" }' \\\n  \"https://$cluster_address/api/v1/vmware/vcenter\"\n```\n\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"RUNNING\",\n  \"error\": \"None\",\n  \"progress\": \"$request_progress\"\n  \"links\": [\n    {\n      href: \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      rel: \"self\"\n    }\n  ]\n}\n```\n\nUsing the information provided in the task object, send a GET request to the [`/vmware/vcenter/request/{id}`](#operation/getVcenterAsyncRequestStatus) endpoint to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the task finished successfully.\n\n### Retrieve vCenter Server details\nGet the details for a vCenter Server that is registered with a Rubrik cluster by sending a GET request to [`/vmware/vcenter/{id}`](#operation/getVcenter).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vcenter/{id}\"\n```\n\nThe Rubrik REST API server responds with the details of the specified vCenter Server object.\n\n```bash\n{\n  \"id\": \"$id\",\n  \"hostname\": \"$vcenter_address0\",\n  \"username\": \"$vcenter_admin0\",\n  \"configuredSlaDomainId\": \"INHERIT\",\n  \"primaryClusterId\": \"$cluster_id\"\n}\n```\n\n### Modifying a vCenter Server entry\n\nTo change the information that a Rubrik cluster stores for a vCenter Server, send a PUT request to [`/vmware/vcenter/{id}`](#operation/updateVcenter). All of the members of the `VcenterConfig` object must be in the PUT request. Using the new values, include in the body of the PUT request each member (`{string : value}`) of the `VcenterConfig` object:\n* `\"hostname\": \"$vcenter_address\"`\n* `\"username\": \"$vcenter_admin\"`\n* `\"password\": \"$vcenter_password\"`\n\nTo change the configured SLA that is configured for a vCenter Server or to change CA certificates for the vCenter, send a PATCH request to[`/vmware/vcenter/{id}`](#operation/patchVcenter).\n\n```bash\ncurl -X PUT \\\n  -d '{\n    \"hostname\": \"$vcenter_address\",\n    \"username\": \"$vcenter_admin\",\n    \"password\": \"$vcenter_password\" }' \\\n  \"https://$cluster_address/api/v1/vmware/vcenter/$vcenter_id\"\n```\n\nThe Rubrik REST API server sends a response, with the updated details of the vCenter Server entry in the response body.\n\n```bash\n{\n  \"id\": \"$vcenter_id\",\n  \"hostname\": \"$vcenter_address\",\n  \"username\": \"$vcenter_admin\",\n  \"configuredSlaDomainId\": \"INHERIT\",\n  \"primaryClusterId\": \"$cluster_id\",\n  \"caCerts\": \"$ca_certs\"\n}\n```\n### Removing a vCenter Server entry\n\nTo remove a vCenter Server entry from a Rubrik cluster, first unmount any Live Mount and Instant Recovery virtual machines for the vCenter Server. Then send a DELETE request to [`/vmware/vcenter/{id}`](#operation/deleteVcenter).\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/vmware/vcenter/$vcenter_id\"\n```\nThe Rubrik REST API server initiates the asynchronous delete task and responds with a task object.\n\n```bash\n{\n    \"id\": \"$request_id\",\n    \"status\": \"RUNNING\",\n    \"error\": \"None\",\n    \"progress\": 0,\n    \"startTime\": \"$start_timestamp\",\n    \"endTime\": \"$end_timestamp\",\n    \"links\": [\n      {\n        \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n        \"rel\": \"self\"\n      }\n    ]\n  }\n```\nUsing the information provided in the task object, send a GET request to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the removal of the vCenter Server object finished successfully.\n\n\n\n### Metadata refresh\n\nThe Rubrik cluster regularly refreshes the metadata of the registered vCenter Servers. As part of a refresh operation, the Rubrik cluster discovers any changes or additions to the virtual machines that are administered by the vCenter Servers. Instead of waiting for a regular refresh, a metadata refresh can be manually initiated by sending a POST request to [`/vmware/vm/refresh`](#operation/createRefresh), using the Rubrik cluster ID (`$cluster_address`) and the vCenter Server ID (`$vcenter_id`).\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/vmware/vcenter/$vcenter_id/refresh\"\n```\n\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"RUNNING\",\n  \"error\": \"None\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\nUsing the information provided in the task object, send a GET request to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the metadata refresh completed successfully.\n\n## ESXi hypervisors\n\nRetrieve a list of all available ESXi hypervisors in the vSphere environment by sending a GET request to [`/vmware/host`](#operation/queryVmwareHost).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/host?primary_cluster_id=$cluster_id\"\n```\nThe value of `primary_cluster_id` is the `id` of a Rubrik cluster. Use `local` to retrieve a list for the Rubrik cluster that is hosting the current session.\n\nThe Rubrik REST API server responds with the first page of a `ListResponse` object.\n\n**Note:** To shorten the example, the response uses ellipsis to replace some members.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$esxi_id\",\n      \"name\": \"$esxi_name\",\n      \"datacenterId\": \"$datacenter_id\",\n      \"computeClusterId\": \"$compute_cluster_id\",\n      \"datastores\": [\n      ...\n      ],\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"primaryClusterId\": \"$cluster_id\"\n    }\n    ],\n  \"total\": 1\n}\n```\n\nRetrieve more details for an ESXi hypervisor by sending a GET request to [`/vmware/host/{id}`](#operation/getVmwareHost)\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/vmware/host/$esxi_id\"\n```\n\nThe Rubrik REST API server responds with the details for the specified ESXi hypervisor.\n\n**Note:** To shorten the example, the response uses ellipsis to replace some members.\n\n```bash\n{\n  \"id\": \"$esxi_id\",\n  \"moid\": \"$moid\",\n  \"name\": \"$esxi_name\",\n  \"computeClusterId\": \"$compute_cluster_id\",\n  \"datacenter\": {\n    \"id\": \"$datacenter_id\",\n    \"name\": \"$datacenter_name\",\n    \"vcenterId\": \"$vcenter_id\",\n    \"configuredSlaDomainId\": \"INHERIT\",\n    \"primaryClusterId\": \"$cluster_id\"\n  },\n  \"datastores\": [\n    ...\n  ],\n  \"virtualMachines\": [\n    ...\n  ],\n  \"configuredSlaDomainId\": \"INHERIT\",\n  \"primaryClusterId\": \"$cluster_id\"\n}\n```\n\nAdditionally, To change the SLA Domain that is configured for an ESXi hypervisor, send a PATCH request on [`/vmware/host`](#operation/updateVmwareHost)\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/vmware/host/$snapshot_id\"\n```\n\nRetrieve datastore details for an ESXi hypervisor by sending a GET request to [`/vmware/host/{id}/datastore`](#operation/getVmwareHostDatastore)\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/host/$esxi_id/datastore\"\n```\n\n\n## Virtual machine protection\n\nAfter a vCenter Server is registered, the Rubrik cluster acquires metadata for the virtual machines that are administered through that vCenter Server. Using the metadata, assign Rubrik cluster protection to the virtual machines.\n\nThe typical protection workflow involves the following tasks:\n1. Find the virtual machine resource object.\n2. (Optional) Enable scripts on the virtual machine.\n3. (Optional) Exclude specified vmdk files for the virtual machine.\n4. Assign the virtual machine to an SLA Domain.\n\n### Finding virtual machines\nGet a list of the virtual machine objects known to the Rubrik cluster by sending a GET request to [`/vmware/vm`](#operation/queryVm). The Rubrik REST API server returns a response that includes a `ListResponse` object. Use query parameters as part of the GET request, to filter the list and to work with the `ListResponse` object.\n\nA GET request that is sent to the [`/vmware/vm`](#operation/queryVm) endpoint accepts the query parameters that are described in the following table.\n| Parameter | Description |\n| --------- | ----------- |\n| `effective_sla_domain_id` | SLA Domain applied to the virtual machine, either directly or derived. Use `UNPROTECTED` for virtual machines that do not have a derived or direct SLA Domain. |\n| `primary_cluster_id` | The `id` of the primary Rubrik cluster for the virtual machine. Use `local` for the Rubrik cluster that is hosting the Rubrik REST API session. |\n| `limit` | Maximum number of a elements to include in the `data` array of the response. |\n| `offset` | Index reference point to use when determining the elements to include in the response. |\n| `is_relic` | Relic status of the virtual machine. `true` to specify only relic virtual machines. `false` to exclude relic virtual machines. Do not include the parameter to include both relic and non-relic virtual machines. |\n| `name` | String value to match in any part of the name of a virtual machine.  |\n| `moid` | String value to match in any part of the MOID of a virtual machine.  |\n| `sla_assignment` | SLA Domain assignment status of the virtual machine. Use `derived` for virtual machines that derive protection status from another resource object. Use `direct` for virtual machines that have a directly assigned SLA Domain. Use `unassigned` for virtual machines that do not have a direct or derived SLA Domain. |\n| `guest_os_name` | Filter by vm guest os name using infix search. |\n| `sort_by` | Perform an ASCII sort of the elements in the `ListResponse` object data array by a specified object value: `effective_sla_domain_id`, `name`, `moid`, `folderPath`, or `infraPath`. |\n| sort_order | Sort order for the elements in the ListResponse object data array. Use `asc` for ascending sort or `desc` for descending sort. |\n\n\n**Example:** Retrieving a list of virtual machine resource objects\n\nRetrieve a list of unprotected virtual machine resource objects that have 'test' in their name. Limit the first page of the response to the first object.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm?effective_sla_domain_id=UNPROTECTED&limit=1&offset=0&name=test\"\n```\nThe Rubrik REST API server responds with a `ListResponse` object. The first page has the first object of the 156 objects that matched the query parameters.\n\n**Note:** To shorten the example, the response uses ellipsis to replace some members.\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"$vm_id\",\n      \"moid\": \"$vm_moid\",\n      \"name\": \"abctest123\",\n      \"vcenterId\": \"$vcenter_id\",\n      \"hostName\": \"$esxi_host_name\",\n      \"hostId\": \"$esxi_host_id\",\n      \"clusterName\": \"$vcenter_cluster_name\",\n      \"powerStatus\": \"poweredOn\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"UNPROTECTED\",\n      \"effectiveSlaDomainName\": \"Unprotected\",\n      \"slaAssignment\": \"Unassigned\",\n      \"ipAddress\": \"$vm_ip\",\n      \"toolsInstalled\": true,\n      \"primaryClusterId\": \"$cluster_id\",\n      \"isReplicationEnabled\": false,\n      \"folderPath\": [\n        ...\n      ],\n      \"infraPath\": [\n        ...\n      ],\n      \"vmwareToolsInstalled\": true,\n      \"isRelic\": false,\n      \"maxNestedVsphereSnapshots\": -1,\n      \"snapshotConsistencyMandate\": \"UNKNOWN\",\n      \"physicalStorage\": 0,\n      \"guestCredentialAuthorizationStatus\": \"PENDING\"\n    }\n  ],\n  \"total\": 156\n}\n```\n\n### Retrieving more details for a virtual machine\nTo get detailed information for a specified virtual machine object, send a GET request to [`/vmware/vm/{id}`](#operation/getVm).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id\"\n```\nThe Rubrik REST API server responds with the details for the virtual machine object.\n\n**Note:** To shorten the example, the response uses ellipsis to replace some members.\n\n```bash\n{\n  \"id\": \"$vm_id\",\n  \"moid\": \"$vm_moid\",\n  \"name\": \"abctest123\",\n  \"powerStatus\": \"poweredOn\",\n  \"configuredSlaDomainId\": \"INHERIT\",\n  \"effectiveSlaDomain\": {\n    ...\n  },\n  \"slaAssignment\": \"Unassigned\",\n  \"blackoutWindowStatus\": {\n    \"isGlobalBlackoutActive\": false,\n    \"isSnappableBlackoutActive\": false\n  },\n  \"blackoutWindows\": {\n    ...\n    ],\n    \"snappableBlackoutWindows\": []\n  },\n  \"currentHost\": {\n    ...\n  },\n  \"virtualDiskIds\": [\n    ...\n  ],\n  \"snapshots\": [],\n  \"ipAddress\": \"$vm_ip\",\n  \"toolsInstalled\": true,\n  \"snapshotCount\": 0,\n  \"snapshotConsistencyMandate\": \"\",\n  \"maxNestedVsphereSnapshots\": -1,\n  \"primaryClusterId\": \"$cluster_id\",\n  \"isReplicationEnabled\": false,\n  \"isRelic\": false,\n  \"physicalStorage\": 0,\n  \"guestOsName\": \"$guest_os\",\n  \"guestCredentialAuthorizationStatus\": \"PENDING\",\n  \"isArrayIntegrationPossible\": false,\n  \"isArrayIntegrationEnabled\": false\n}\n```\n\n### Register Rubrik Backup Service\n\nTo register Rubrik Backup Service running on a specified virtual machine,\nsend a POST request to\n[`/vmware/vm/{id}/register_agent`](#operation/vmRegisterAgent).\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id/register_agent\"\n```\nThe Rubrik REST API server responds with an HTTP 204 response when the\nregistration is successful.\n\n\n### Enabling scripts\n\nA virtual machine object can be configured to start scripts on the guest operating system. A script can be started before the backup (`preBackupScript`), after the snapshot completes (`postSnapScript`), and after the backup task completes (`postBackupScript`). The *Rubrik User Guide* provides information about script requirements.\n\nTo configure a virtual machine object to start scripts, send a PATCH request to [`/vmware/vm/{id}`](#operation/updateVm). Since this is a PATCH request, only the elements of the virtual machine object that are modified or added should be included in the request body. All three script members are shown in the request body in this model, but all are optional.\n\n```bash\ncurl -X PATCH \\\n -d '{\n      \"preBackupScript\": {\n        \"scriptPath\": \"$pre_script_path\",\n        \"timeoutMs\": 10000,\n        \"failureHandling\": \"abort\"\n      },\n      \"postSnapScript\": {\n        \"scriptPath\": \"$postsnap_script_path\",\n        \"timeoutMs\": 10000,\n        \"failureHandling\": \"abort\"\n      },\n      \"postBackupScript\": {\n        \"scriptPath\": \"$postbackup_script_path\",\n        \"timeoutMs\": 10000,\n        \"failureHandling\": \"abort\"\n      }\n    }' \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id\"\n```\n\nThe Rubrik REST API server sends an HTTP 200 response that includes the modified or added members in the response body.\n\n#### Manually starting a virtual machine script\n\nFor testing or to run a script before running a backup, manually trigger the script by sending a POST request to [`/vmware/vm/{id}/guest_script/run`](#operation/runGuestOsScript). To manually start a script, the script must first be a part of the configuration of the virtual machine object. Use the value of the `phase` member to identify the script, as follows:\n* Use `PreBackup` for the script identified by the `preBackupScript` member.\n* Use `PostSnap` for the script identified by the `postSnapScript` member.\n* Use `PostBackup` for the script identified by the `postBackupScript` member.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"phase\": \"PreBackup\" }' \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id/guest_script/run\"\n```\nThe Rubrik REST API server responds with an HTTP 204 response when the script finishes with a 0 exit code.\n\n\n### Excluding a VMDK file\n\nThe Rubrik cluster can be configured to ignore some of the VMDK files of a virtual machine while protecting the other VMDK files of that virtual machine. To exclude a VMDK file, send a GET request to [`/vmware/vm/virtual_disk/{id}`](#operation/getVirtualDisk) using the `$disk_id` of the VMDK file.\n\nTo get the `$disk_id` values, send a GET request to [`/vmware/vm/{id}`](#operation/getVm). The response body has the `disk_id` values for the virtual machine in the `virtualDiskIds` array.\n\nAfter identifying the `$disk_id` for a VMDK file, obtain the current state of the VMDK file.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/virtual_disk/$disk_id\"\n```\nThe Rubrik REST API server responds with the value of `excludeFromSnapshots`.\n\n```bash\n{\n  \"id\": \"$disk_id\",\n  \"excludeFromSnapshots\": false\n}\n```\nWhen the value is `false` the Rubrik cluster is not configured to exclude the VMDK file. Change this value to `true` to instruct the Rubrik cluster to exclude the VMDK file from all subsequent snapshots of the virtual machine.\n\nSend a PATCH request to [`/vmware/vm/virtual_disk/{id}`](#operation/updateVirtualDisk) to change the value of `excludeFromSnapshots` to `true` and exclude the VMDK file.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"excludeFromSnapshots\": true }' \\\n  \"https://$cluster_address/api/v1/vmware/vm/virtual_disk/$disk_id\"\n```\n\nThe Rubrik REST API server responds with the updated `excludeFromSnapshots` value for the VMDK file.\n\n```bash\n{\n  \"id\": \"$disk_id\",\n  \"excludeFromSnapshots\": true\n}\n```\n\n### Assigning a virtual machine to an SLA Domain\nTo protect a virtual machine through the rules and policies of an SLA Domain send a PATCH request to [`/vmware/vm/{id}`](#operation/updateVm) with the value of `configuredSlaDomainId` set to the `$sla_domain_id`.\n\n**Note:** [Retrieving SLA Domains](#section/SLA-Domains/Retrieving-SLA-Domains) describes how to retrieve the SLA Domain objects on a Rubrik cluster.\n\n```bash\ncurl -X PATCH -d \\\n  '{\n    \"configuredSlaDomainId\": \"$sla_domain_id\"\n  }' \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id\"\n```\nThe Rubrik REST API server responds with confirmation of the assignment.\n\n```bash\n{\n  \"id\": \"$vm_id\",\n  \"configuredSlaDomainId\": \"$sla_domain_id\"\n}\n```\n## Snapshot management\n\nManaging snapshots includes the following possible actions:\n* Retrieving snapshot information\n* Retrieving snapshot details\n* Retrieving missed snapshot information\n* Creating on-demand snapshots\n* Expiring individual snapshots\n* Expiring all snapshots for a virtual machine\n\n### Retrieving snapshot information\n\nTo retrieve a list of the snapshots for a virtual machine, send a GET request to [`/vmware/vm/{id}/snapshot`](#operation/querySnapshot).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/$vm_id/snapshot\"\n```\nThe Rubrik REST API server responds with a `ListResponse` object.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"date\": \"$timestamp0\",\n      \"indexState\": 0,\n      \"cloudState\": 0,\n      \"vmName\": \"$vm_name\",\n      \"replicationLocationIds\": [],\n      \"id\": \"$snapshot_id0\",\n      \"consistencyLevel\": \"$consistency_level0\",\n      \"archivalLocationIds\": [],\n      \"isOnDemandSnapshot\": false\n    },\n    {\n      \"date\": \"$timestamp1\",\n      \"indexState\": 0,\n      \"cloudState\": 0,\n      \"vmName\": \"$vm_name\",\n      \"replicationLocationIds\": [],\n      \"id\": \"$snapshot_id1\",\n      \"consistencyLevel\": \"$consistency_level1\",\n      \"archivalLocationIds\": [],\n      \"isOnDemandSnapshot\": true\n    }\n ],\n \"total\": 2\n}\n```\nEach member of the data array includes the `id` of a snapshot. Use this value (`$snapshot_id`) to perform tasks with the snapshot, such as:\n* Browsing for data in the snapshot\n* Downloading data from the snapshot\n* Restoring data from the snapshot\n* Exporting data from the snapshot\n* Mounting a virtual machine from the snapshot\n\n### Retrieving snapshot details\n\nTo retrieve details for a specified snapshot send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id\"\n```\nThe Rubrik REST API server responds with the details of the specified snapshot.\n\n**Note:** To shorten the example, the response uses ellipsis to replace some members.\n\n```bash\n{\n  \"date\": \"$timestamp\",\n  \"indexState\": 0,\n  \"virtualMachine\": {\n   ...\n  },\n  \"vmName\": \"$vm_name\",\n  \"isCorrupt\": false,\n  \"replicationLocationIds\": [],\n  \"archivalLocationIds\": [],\n  \"snapshotDiskIds\": [\n    \"$vmdk_id\"\n  ],\n  \"isOnDemandSnapshot\": false,\n  \"cloudState\": 0,\n  \"id\": \"$snapshot_id\",\n  \"consistencyLevel\": \"1\",\n  \"config\": \"[]\"\n}\n```\n\n### Retrieving missed snapshot information\n\nThe Rubrik cluster stores information for missed snapshots. *Missed snapshots* are snapshot tasks that are not completed as required by the rules and policies of an SLA Domain.  Retrieve missed snapshot information for a virtual machine by sending  a GET request to [`/vmware/vm/{id}/missed_snapshot`](#operation/missedSnapshots).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/$vm_id/missed_snapshot\"\n```\nThe Rubrik REST API server responds with a `ListResponse` object.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"archivalLocationType\": [\n        \"missed\"\n      ],\n      \"missedSnapshotTime\": \"$timestamp0\"\n    },\n    {\n      \"archivalLocationType\": [\n        \"missed\"\n      ],\n      \"missedSnapshotTime\": \"$timestamp1\"\n    }\n  ],\n  \"total\": 2\n}\n```\n\n### Creating on-demand snapshots\n\nOn-demand snapshots can be created for both protected and unprotected virtual machines. To create an on-demand snapshot of a virtual machine send a POST request to [`/vmware/vm/{id}/snapshot`](#operation/createOnDemandBackup).\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id/snapshot\"\n```\nThe Rubrik REST API server initiates the asynchronous snapshot task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"status\": \"ACQUIRING\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\nUsing the information provided in the task object, send a GET request to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the on-demand snapshot finished successfully.\n\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\"\n```\nThe Rubrik REST API server sends a task object with `status=\"SUCCEEDED\"`.  The task object for a successful snapshot includes the URI for the snapshot: `https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id`.\n\n```bash\n{\n  \"id\":\"$request_id\",\n  \"status\":\"SUCCEEDED\",\n  \"startTime\":\"$timestamp0\",\n  \"endTime\":\"$timestamp1\",\n  \"links\":[\n    {\n      \"href\":\"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id\",\n      \"rel\":\"result\"\n    },\n   {\n      \"href\":\"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",\n      \"rel\":\"self\"\n   }\n  ]\n}\n```\n\n### Expiring individual snapshots\n\nOn-demand snapshots and snapshots for unprotected virtual machines can be expired by using the snapshot `id`. To expire an individual snapshot, send a DELETE request to [`/vmware/vm/snapshot/{id}`](#operation/deleteVmwareSnapshot). Include the query parameter `location` to specify whether to expire all copies of the snapshot, or only the local copy. Use `location=local` to expire only the copy of the snapshot on the specified Rubrik cluster. Use `location=all` to expire all copies of the snapshot, including replicas and archival copies.\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id?location=$snapshot_location\"\n```\nThe Rubrik REST API server expires the specified snapshot and responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.\n\nThe Rubrik REST API server responds with HTTP response code 422 'Unprocessable Entity', when the specified snapshot is not one of the following:\n* On-demand snapshot\n* Snapshot for an unprotected virtual machine\n\n### Expiring all snapshots for a virtual machine\n\nAll snapshots for an unprotected virtual machine can be expired by using the virtual machine `id`. To expire all snapshots for an unprotected virtual machine, send a DELETE request to [`/vmware/vm/{id}/snapshot`](#operation/deleteVmwareSnapshots). The Rubrik cluster expires all snapshots, replicas, and archival snapshots for the specified virtual machine.\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id/snapshot\"\n```\nThe Rubrik REST API server expires all snapshots for the specified virtual machine in all locations and responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.\n\nThe Rubrik REST API server responds with HTTP response code 422 'Unprocessable Entity', when the specified virtual machine is protected through an SLA Domain assignment.\n\n\n\n\n## Data recovery\nTo recover a file or folder from a snapshot, retrieve the `id` of the file or folder using either search or browse. Then use the `id` with one of the recovery methods:\n* Download the file or folder\n* Restore the file or folder to the source location\n* Export the file or folder to another host\n\n### Searching for data in snapshots\n\nSearch for files and folders across all indexed snapshots of a virtual machine by using the virtual machine `id`. Send a GET request to [`/vmware/vm/{id}/search`](#operation/searchVm) with the `path` query parameter. Use a path segment string or a name segment string for the value of `path`.\n\n**IMPORTANT:** The snapshot used in this task must be indexed. Indexing makes the file system structure of the data available to the Rubrik cluster. To determine whether a snapshot has been successfully indexed, send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot) as described in the 'Retrieving snapshot information' section of [Snapshot management](#section/Virtual-machines/Snapshot-management). Look at the value of `indexState`. A value of `1` means the snapshot has been indexed. A value of `0` means the snapshot has not been indexed.\n\nThe Rubrik REST API server uses the rules described in the following table when matching the value of `path` with folders and files in the indexed snapshots.\n| Type | Rule | Description |\n| ---- | ---- | ----------- |\n| Path delimiter | Forward slashes and backslashes are equally recognized as path delimiters. | In the value of path, `/` matches both `/` and `\\`, and `\\` matches both `/` and `\\`. |\n| Path segments | Path segments match all files and folders that begin with the same path segment. | For example, '/abc/x' matches files and folders at '/abc/' or '\\abc\\\\' with a filename or folder name that starts with 'x'. |\n| Name segments | Name segments match all files and folders that begin with the same name segment. | For example, 'xyz' matches files and folders with a filename or folder name that starts with 'xyz', in all path locations. |\n| Characters | Any character that the guest operating system accepts in a file path can be used.  | For example, the greater than symbol `>` and the lesser than symbol `<` are not allowed. |\n| Windows drive | To specify a full path on a Windows guest follow the Windows file system requirement. | For example, to specify the 'temp' folder on the 'D' drive of a Windows virtual machine, use: `D:\\temp`. |\n\n**Example:** Searching for files and folders\n\nSearch for all files and folders in '/usr/local/' with a name that starts with the later 'g'.\n\nSend a GET request to [`/vmware/vm/{id}/search`](#operation/searchVm) with `path=/usr/local/g`.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm/$vm_id/search?path=%2Fusr%2Flocal%2Fg\"\n```\nThe Rubrik REST API server responds with a `ListResponse` object. The data array has two members, a directory at: `/usr/local/games` and a file at: `/usr/local/gamehints`.\n\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"path\": \"/usr/local/games\",\n      \"filename\": \"games\",\n      \"fileVersions\": [\n        {\n          \"lastModified\": \"$timestamp0\",\n          \"size\": 4096,\n          \"snapshotId\": \"$snapshot_id0\",\n          \"fileMode\": \"directory\",\n          \"source\": \"cloud\"\n        }\n      ]\n    },\n    {\n    \"path\": \"/usr/local/gamehints\",\n    \"filename\": \"gamehints\",\n    \"fileVersions\": [\n      {\n        \"lastModified\": \"$timestamp1\",\n        \"size\": 14480,\n        \"snapshotId\": \"$snapshot_id1\",\n        \"fileMode\": \"file\",\n        \"source\": \"cloud\"\n      },\n      {\n        \"lastModified\": \"$timestamp2\",\n        \"size\": 14480,\n        \"snapshotId\": \"$snapshot_id2\",\n        \"fileMode\": \"file\",\n        \"source\": \"cloud\"\n      }\n    ]\n   }\n  ],\n  \"total\": 2\n}\n```\n\n### Browsing for data in snapshots\n\nBrowse for files and folders with an indexed snapshot by using the snapshot `id`. Send a GET request to  [`/vmware/vm/snapshot/{id}/browse`](#operation/browseVmwareSnapshot) with the `path` query parameter.  Use a path segment string for the value of `path`. The response provides a ListResponse object that includes all of the files and folders in the directory that is specified by the value of `path`.\n\n**IMPORTANT:** The snapshot used in this task must be indexed. Indexing makes the file system structure of the data available to the Rubrik cluster. To determine whether a snapshot has been successfully indexed, send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot) as described in the 'Retrieving snapshot information' section of [Snapshot management](#section/Virtual-machines/Snapshot-management). Look at the value of `indexState`. A value of `1` means the snapshot has been indexed. A value of `0` means the snapshot has not been indexed.\n\nThe Rubrik REST API server uses the rules described in the following table when matching the value of `path` with the path in the specified snapshot.\n| Type | Rule | Description |\n| ---- | ---- | ----------- |\n| Path delimiter | Forward slashes and backslashes are equally recognized as path delimiters. | In the value of path, `/` matches both `/` and `\\`, and `\\` matches both `/` and `\\`. |\n| Path description | The path description must end in a directory name, without an ending slash. | For example, '/abc/x' returns all files and folders in the directory at '/abc/x', but '/abc/x/' returns an HTTP 422 response. |\n| Characters | Any character that the guest operating system accepts in a file path can be used.  | For example, the greater than symbol `>` and the lesser than symbol `<` are not allowed. |\n| Windows drive | To specify a full path on a Windows guest follow the Windows file system requirement. | For example, to specify the 'temp' folder on the 'D' drive of a Windows virtual machine, use: `D:\\temp`. |\n\n**Example:** Browsing for files and folders\n\nRetrieve a ListResponse object with all of the files and folders in '/home'.\n\nSend a GET request to  [`/vmware/vm/snapshot/{id}/browse`](#operation/browseVmwareSnapshot) with `path=/home`.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/browse?path=%2Fhome&offset=0\"\n```\nThe Rubrik REST API server responds with a `ListResponse` object. The data array has two members, the directory: `ubuntu` and the file: `ubuntu.tar`.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"filename\": \"ubuntu\",\n      \"path\": \"ubuntu\",\n      \"lastModified\": \"$timestamp0\",\n      \"size\": 31892819777,\n      \"fileMode\": \"directory\",\n      \"statusMessage\": \"\"\n    },\n    {\n      \"filename\": \"ubuntu.tar\",\n      \"path\": \"ubuntu.tar\",\n      \"lastModified\": \"$timestamp1\",\n      \"size\": 4746675383,\n      \"fileMode\": \"file\",\n      \"statusMessage\": \"\"\n    }\n  ],\n  \"total\": 2\n}\n```\n### Downloading data from a snapshot\n\nData can be retrieved from a snapshot by creating a download link for an individual file and folder from the snapshot. To have the Rubrik cluster create a download link, send a POST request to [`/vmware/vm/snapshot/{id}/download`](#operation/createDownloadFileJob). Include in the request body the string/value pair: `\"path\":\"$path\"`, where `$path` is the full path to the file or folder. When `$path` refers to a folder, the Rubrik cluster creates a ZIP file of the folder and all that it contains.\n\nThe basic download work flow is:\n1. Send a POST request to start the asynchronous download task.\n2. Send a GET request to poll the task status.\n3. When the task succeeds, use the download link provided in the response body to retrieve the file or folder.\n\n**IMPORTANT:** The snapshot used in this task must be indexed. Indexing makes the file system structure of the data available to the Rubrik cluster. To determine whether a snapshot has been successfully indexed, send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot) as described in the 'Retrieving snapshot information' section of [Snapshot management](#section/Virtual-machines/Snapshot-management). Look at the value of `indexState`. A value of `1` means the snapshot has been indexed. A value of `0` means the snapshot has not been indexed.\n\n```bash\ncurl -X POST -d \\\n'{\n   \"path\": \"$full_source_path\"\n }' \\\n 'https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/download_file'\n```\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$download_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Restoring data from a snapshot\n\nTo restore a file or folder to the source virtual machine send a POST request to [`/vmware/vm/snapshot/{id}/restore_file`](#operation/createRestoreFileJob). With the request, include a request body. The following table describes the members of the request body.\n\n| Name | Description |\n| ---- | ----------- |\n| `path` | Full path of the file or folder. |\n| `domainName` | Authentication domain for the credentials being used to authenticate and authorize the action. |\n| `username` | Username of account to authenticate and authorize the action. |\n| `password` | Password for the account to authenticate and authorize the action. |\n| `restorePath` | Full path location for the restore of the file or folder. The action can create a directory at the end of the specified path, but cannot create directories that are specified within the path. |\n| `shouldUseAgent` | Instruct the Rubrik cluster to restore the file using Rubrik Backup Service running on virtual machine. Use `true` to restore using RBS and `false` to restore using `VMware tools`. |\n| `shouldSaveCredentials` | Instruct the Rubrik cluster to save the credentials included in the request. Use `true` to save the credentials and `false` to use the credentials only for the current request. |\n| `shouldRestoreXAttrs` | Instruct the Rubrik cluster to restore the\nextended attributes of all files and folders included in the `path`.\nWhen restoring to a Linux host, extended attributes are restored.\nWhen restoring to a Windows host, alternate data streams (ADS) are\nrestored. Use `true` to restore this metadata and `false` otherwise. |\n\n```bash\ncurl -X POST -d \\\n'{\n   \"path\": \"$full_source_path\",\n   \"domainName\": \"$auth_domain\",\n   \"username\": \"$username\",\n   \"password\": \"$password\",\n   \"restorePath\": \"$full_restore_path\",\n   \"shouldUseAgent\" : true,\n   \"shouldSaveCredentials\": true,\n   \"shouldRestoreXAttrs\": true\n }' \\\n \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/restore_file\"\n```\n\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$restore_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n\n## Snapshot mount operations\nSnapshot mount operations include the following possible actions:\n* Retrieving a snapshot from an archival location\n* Mounting a snapshot by using Instant Recovery\n* Mounting a snapshot by using Live Mount\n* Mounting a snapshot for a batch of virtual machines using Live Mount\n* Exporting a snapshot\n* Changing the properties of a mounted virtual machine\n* Removing a virtual machine mount\n* Migrating a datastore for a virtual machine from Live Mount or Instant Recovery\n\n### Retrieving a snapshot from an archival location\n\nTo work with a snapshot that is stored only at an archival location, first download the snapshot to the Rubrik cluster by sending a POST request to [`/vmware/vm/snapshot/{id}/download`](#operation/createDownloadSnapshotFromCloud).\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/download\"\n```\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$snap_download_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Mounting a snapshot by using Instant Recovery\n\nReplace a source virtual machine from a snapshot by using the Instant Recovery feature. To use Instant Recovery, send a POST request to [`/vmware/vm/snapshot/{id}/instant_recover`](#operation/createInstantRecovery). This request requires a snapshot `id` and can optionally include the parameters that are described in the following table.\n\n| Name | Description |\n| ---- | ----------- |\n| `hostId` | The `id` of an ESXi hypervisor. When not specified, the Rubrik cluster uses the original hypervisor. |\n| `vmName` | Assigns a specified name to the virtual machine. |\n| `removeNetworkDevices` | Determines whether the virtual machine has network devices. Use `true` to remove network devices from the virtual machine. Use `false` to keep the existing network devices. |\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"vmName\": \"$vm_name\",\n    \"hostId\": \"$esxi_id\",\n    \"removeNetworkDevices\": true\n   }' \\\n   \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/instant_recover\"\n```\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$instant_recovery_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Mounting a snapshot by using Live Mount\n\nMount a new virtual machine from a snapshot by using the Live Mount feature. To use Live Mount, send a POST request to [`/vmware/vm/snapshot/{id}/mount`](#operation/createMountV1). This request requires a snapshot `id` and can optionally include the parameters that are described in the following table.\n\n| Name | Description |\n| ---- | ----------- |\n| `hostId` | The `id` of an ESXi hypervisor. When not specified, the Rubrik cluster uses the original hypervisor. |\n| `vmName` | Assigns a specified name to the virtual machine. |\n| `dataStoreName` | Obsolete paraemeter. |\n| `disableNetwork` | Determines whether the virtual machine has access to the network. Use `true` to Mount the snapshot with network access disabled. Use `false` to allow the virtual machine to access the network. |\n| `removeNetworkDevices` | Determines whether the virtual machine has network devices. Use `true` to remove network devices from the virtual machine. Use `false` to keep the existing network devices. |\n| `powerOn` | Determines whether the virtual machine is powered on after mounting. Use `true` to power on the virtual machine. Use `false` to leave the virtual machine powered off after mounting. |\n\n\n```bash\ncurl -X POST \\\n  -d '{\n     \"hostId\": \"$esxi_id\",\n     \"vmName\": \"$vm_name\",\n     \"dataStoreName\": \"$datastore_name\",\n     \"disableNetwork\": $network_state,\n     \"removeNetworkDevices\": $network_devices_state,\n     \"powerOn\": $power_state\n   }'\\\n    \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/mount\"\n```\n\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$live_mount_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Mounting a snapshot for a batch of virtual machines using Live Mount\n\nMount a snapshot each for a batch of virtual machines. Send a POST request to\n[`/vmware/vm/batch_mount`](#operation/batchMountSnapshot). This request\nrequires a snapshots parameter, which is a list of the following type,\nwhere we expect on of `snapshotId`, `snapshotBeforeDate` or\n`snapshotAfterDate` to be set, and prefer them in that order.\n| Name | Description |\n| ---- | ----------- |\n| `vmId` | The `id` of the virtual machine. |\n| `snapshotId` | Snapshot `id`. This is an optional property. |\n| `snapshotBeforeDate` | Mount the newest snapshot prior to `date` |\n| `snapshotAfterDate` | Mount the oldest snapshot after to `date` |\n| `config` | Properties of the /vmware/vm/snapshot/`id`/mount endpoint. |\n\n\n```bash\ncurl -X POST \\\n  -d '{\n     \"snapshots\": [\n       {\n         \"vmId\": \"$vm_id\",\n         \"snapshotBeforeDate\": \"$timestamp\",\n         \"config\": {\n           \"hostId\": \"$esxi_id\",\n           \"vmName\": \"$vm_name\",\n           \"dataStoreName\": \"$datastore_name\",\n           \"disableNetwork\": $network_state,\n           \"removeNetworkDevices\": $network_devices_state,\n           \"powerOn\": $power_state\n         }\n       }\n     ]\n     }'\\\n      \"https://$cluster_address/api/v1/vmware/vm/batch_mount\"\n```\n\nThe Rubrik REST API server initiates a batch of mount jobs and\nresonds with objects tracking the job status.\n\n```bash\n{\n  \"responses\": [\n    {\n      \"id\": \"$live_mount_task_id\",\n      \"status\": \"QUEUED\",\n      \"progress\": 0,\n      \"startTime\": \"$timestamp\",\n      \"links\": [\n        {\n          \"href\": \"https://$cluster_address/api/v1/vmware/request/$request_id\",\n          \"rel\": \"self\"\n        }\n      ]\n    }\n  ]\n}\n```\n### Retrieving the ID of the mount\n\nAfter a mount task successfully completes, the `id` of the mount object can be retrieved by sending a GET request to [`/vmware/vm/request/{id}`](#operation/getAsyncRequestStatus) and using the `$request_id` value from the original request object for the Live Mount.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\"\n```\nThe Rubrik REST API server responds with a request object that includes the `id` of the mount object.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\",\n      \"rel\": \"result\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"SUCCEEDED\"\n}\n```\n### Retrieving active mounts\n\nTo retrieve a list of all of the active mounts for a Rubrik cluster, send a GET request to [`/vmware/vm/snapshot/mount`](#operation/queryMountV1).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/mount\"\n```\nThe Rubrik REST API server responds with a ListResponse object.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$mount_id\",\n      \"snapshotDate\": \"$snapshot_timestamp\",\n      \"vmId\": \"$source_vm_id\",\n      \"mountedVmId\": \"$mounted_vm_id\",\n      \"hostId\": \"$esxi_id\",\n      \"isReady\": true\n    }\n  ],\n  \"total\": 1\n}\n```\n### Retrieving the details for a mount\n\nTo retrieve details about a specific mount, send a GET request to [`/vmware/vm/snapshot/mount/{id}`](#operation/getMountV1).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\"\n```\nThe Rubrik REST API server responds with the details.\n\n```bash\n{\n  \"snapshotDate\": \"$timestamp\",\n  \"vmId\": \"$source_vm_id\",\n  \"isReady\": true,\n  \"hostId\": \"$esxi_id\",\n  \"id\": \"$mount_id\",\n  \"mountedVmId\": \"$mounted_vm_id\"\n}\n```\n\n### Exporting a snapshot\n\nTo export a snapshot send a POST request to \n[`/vmware/vm/snapshot/{id}/export`](#operation/createExportV1). This request\nrequires a snapshot `id` and the parameters that are described in the \nfollowing table.\n\n| Name | Description |\n| ---- | ----------- |\n| `datastoreId` | The `id` of a datastore for the specified ESXi hypervisor. |\n| `vmName` | Assigns a specified name to the virtual machine. |\n| `hostId` | The `id` of an ESXi hypervisor. |\n| `disableNetwork` | Determines whether the virtual machine has access to the network. Use `true` to Mount the snapshot with network access disabled. Use `false` to allow the virtual machine to access the network. |\n| `removeNetworkDevices` | Determines whether the virtual machine has network devices. Use `true` to remove network devices from the virtual machine. Use `false` to keep the existing network devices. |\n| `powerOn` | Determines whether the virtual machine is powered on after mounting. Use `true` to power on the virtual machine. Use `false` to leave the virtual machine powered off after mounting. |\n| `unregisterVm` | Determines whether to add the exported virtual machine to the vCenter Server inventory. Use `true` to remove the exported virtual machine from the associated vCenter Server inventory. Use `false` to add the exported virtual machine to the associated vCenter Server inventory. |\n\n\n```bash\ncurl -X  -d \\\n '{\n   \"datastoreId\": \"string\",\n   \"vmName\": \"string\",\n   \"hostId\": \"string\",\n   \"disableNetwork\": true,\n   \"removeNetworkDevices\": true,\n   \"powerOn\": true,\n   \"unregisterVm\": true\n }' \\\n \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/export\"\n```\n\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$export_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Changing power status of a mounted virtual machine\n\nTo change the power status of a mounted virtual machine send a PATCH request to [`/vmware/vm/snapshot/mount/{id}`](#operation/updateMount). Include in the request body, the member `\"powerStatus\": $power_state`. For `$power_state`, use `true` to power on the virtual machine, or use `false` to power off the virtual machine.\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"powerStatus\": $power_state }' \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\"\n```\n\nThe Rubrik REST API server responds with the mount details.\n\n```bash\n{\n  \"powerStatus\": \"$power_state\",\n  \"id\": \"$mount_id\",\n  \"snapshotDate\": \"$timestamp\",\n  \"vmId\": \"$vm_id\",\n  \"mountedVmId\": \"$mounted_vm_id\",\n  \"hostId\": \"$esxi_id\",\n  \"isReady\": true,\n  \"mountRequestId\": \"$mount_request_id\",\n  \"unmountRequestId\": \"$unmount_request_id\"\n}\n```\n\n### Removing a virtual machine mount\n\nTo remove a Live Mount send a DELETE request to [`/vmware/vm/snapshot/mount/{id}`](#operation/createUnmount). To remove a mount object after live migration of the virtual machine include the query parameter `force=true`.\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\"\n```\nThe Rubrik REST API server initiates the asynchronous request task and responds with a task object.\n\n```bash\n{\n  \"id\": \"$delete_mount_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n### Get recoverable ranges for a CDP-enabled virtual machine\n\nFor a list of time ranges to which a CDP-enabled virtual machine can recover, send a GET request to [`/vmware/vm/{id}/recoverable_range`](#operation/getVmwareRecoverableRanges). The time range start and end timestamps are specified as milliseconds from epoch.\nAny point-in-time recovery operation from version 2 of the API can use the time ranges returned by this API call for any CDP-enabled virtual machine.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/$vm_id/recoverable_range\n```\n\n```bash\n{\n  \"data\": [\n    \"beginTime\": \"2018-01-01T12:34:56.789Z\",\n    \"endTime\": \"2018-01-01T12:34:56.789Z\"\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\n### Get missed recoverable ranges for a CDP-enabled virtual machine\n\nFor a list of time ranges to which a CDP-enabled virtual machine cannot recover to, send a GET request to [`/vmware/vm/{id}/missed_recoverable_range`](#operation/getVmwareMissedRecoverableRanges). The time range start and end timestamps are specified as milliseconds from epoch.\nAny point-in-time recovery operation from version 2 of the API can use the time ranges returned by this API call for any CDP-enabled virtual machine.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/$vm_id/missed_recoverable_range\n```\n\n```bash\n{\n  \"data\": [\n    \"beginTime\": \"2018-01-01T12:34:56.789Z\",\n    \"endTime\": \"2018-01-01T12:34:56.789Z\"\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\n### Migrating a datastore for a virtual machine from Live Mount or Instant Recovery\n\nSend a POST request to [`/vmware/vm/snapshot/mount/{id}/relocate`](#operation/relocateMount) to migrate a datastore for a virtual machine created from Live Mount or Instant Recovery.\n\n\n### Get compute cluster information\n\nVMware compute cluster can be found by a GET on [`/vmware/compute_cluster`](#operation/queryComputeCluster).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/compute_cluster\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"compute_cluster_id\",\n      \"name\": \"compute_cluster_name\",\n      \"configuredSlaDomainId\": \"configured_sla_domain_id\",\n      \"configuredSlaDomainName\": \"configured_sla_domain_name\",\n      \"primaryClusterId\": \"primary_cluster_id\",\n      \"datacenterId\": \"datacenter_id\",\n      \"effectiveSlaDomainId\": \"effective_sla_domain_id\",\n      \"effectiveSlaDomainName\": \"effective_sla_domain_name\",\n      \"effectiveSlaSourceObjectId\": \"effective_sla_source_object_id\",\n      \"effectiveSlaSourceObjectName\": \"effective_sla_source_object_name\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nFurther details are acquired from GET [`/vmware/compute_cluster/{id}`](#operation/getComputeCluster).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_clustere_id\"\n```\n\n```bash\n{\n  \"id\": \"compute_cluster_id\",\n  \"name\": \"compute_cluster_name\",\n  \"configuredSlaDomainId\": \"configured_sla_domain_id\",\n  \"configuredSlaDomainName\": \"configured_sla_domain_name\",\n  \"primaryClusterId\": \"primary_cluster_id\",\n  \"datacenterId\": \"datacenter_id\",\n  \"effectiveSlaDomainId\": \"effective_sla_domain_id\",\n  \"effectiveSlaDomainName\": \"effective_sla_domain_name\",\n  \"effectiveSlaSourceObjectId\": \"effective_sla_source_object_id\",\n  \"effectiveSlaSourceObjectName\": \"effective_sla_source_object_name\"\n  \"moid\": \"compute_cluster_moid\",\n  \"hosts\": [\n    {\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"configuredSlaDomainId\": \"string\",\n      \"configuredSlaDomainName\": \"string\",\n      \"primaryClusterId\": \"string\",\n      \"datacenterId\": \"string\",\n      \"computeClusterId\": \"string\",\n      \"datastores\": [\n        {\n          \"id\": \"string\",\n          \"name\": \"string\",\n          \"capacity\": 0,\n          \"dataStoreType\": \"string\",\n          \"dataCenterName\": \"string\",\n          \"isLocal\": true\n         }\n      ],\n      \"effectiveSlaDomainId\": \"string\",\n      \"effectiveSlaDomainName\": \"string\",\n      \"effectiveSlaSourceObjectId\": \"string\",\n      \"effectiveSlaSourceObjectName\": \"string\"\n    }\n  ],\n\"virtualMachines\": [\n    {\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"configuredSlaDomainId\": \"string\",\n      \"configuredSlaDomainName\": \"string\",\n      \"primaryClusterId\": \"string\",\n      \"slaAssignment\": \"Derived\",\n      \"effectiveSlaDomainId\": \"string\",\n      \"effectiveSlaDomainName\": \"string\",\n      \"effectiveSlaSourceObjectId\": \"string\",\n      \"effectiveSlaSourceObjectName\": \"string\",\n      \"moid\": \"string\",\n      \"vcenterId\": \"string\",\n      \"hostName\": \"string\",\n      \"hostId\": \"string\",\n      \"clusterName\": \"string\",\n      \"snapshotConsistencyMandate\": \"UNKNOWN\",\n      \"powerStatus\": \"string\",\n      \"protectionDate\": \"2018-10-02T20:33:03.833Z\",\n      \"ipAddress\": \"string\",\n      \"agentStatus\": {\n        \"agentStatus\": \"string\",\n        \"disconnectReason\": \"string\"\n      },\n      \"toolsInstalled\": true,\n      \"isReplicationEnabled\": true,\n      \"folderPath\": [\n        {\n          \"id\": \"string\",\n          \"managedId\": \"string\",\n          \"name\": \"string\"\n        }\n      ],\n      \"infraPath\": [\n        {\n          \"id\": \"string\",\n          \"managedId\": \"string\",\n          \"name\": \"string\"\n        }\n      ],\n      \"vmwareToolsInstalled\": true,\n      \"isRelic\": true,\n      \"guestCredentialAuthorizationStatus\": \"string\",\n      \"cloudInstantiationSpec\": {\n        \"imageRetentionInSeconds\": 0\n      },\n      \"parentAppInfo\": {\n        \"id\": \"string\",\n        \"isProtectedThruHierarchy\": true\n      }\n    }\n  ]\n}\n```\n\nconfiguredSlaDomainId could be updated by a PATCH [`/vmware/compute_cluster/{id}`](#operation/updateComputeCluster).\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"sla_assignable\": $sla_domain }' \\\n  \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_clustere_id\"\n```\n\n```bash\n{\n  \"id\": \"compute_cluster_id\",\n  \"name\": \"compute_cluster_name\",\n  \"configuredSlaDomainId\": \"configured_sla_domain_id\",\n  \"configuredSlaDomainName\": \"configured_sla_domain_name\",\n  \"primaryClusterId\": \"primary_cluster_id\",\n  \"datacenterId\": \"datacenter_id\",\n  \"effectiveSlaDomainId\": \"effective_sla_domain_id\",\n  \"effectiveSlaDomainName\": \"effective_sla_domain_name\",\n  \"effectiveSlaSourceObjectId\": \"effective_sla_source_object_id\",\n  \"effectiveSlaSourceObjectName\": \"effective_sla_source_object_name\"\n  \"moid\": \"compute_cluster_moid\",\n  \"hosts\": [\n    {\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"configuredSlaDomainId\": \"string\",\n      \"configuredSlaDomainName\": \"string\",\n      \"primaryClusterId\": \"string\",\n      \"datacenterId\": \"string\",\n      \"computeClusterId\": \"string\",\n      \"datastores\": [\n        {\n          \"id\": \"string\",\n          \"name\": \"string\",\n          \"capacity\": 0,\n          \"dataStoreType\": \"string\",\n          \"dataCenterName\": \"string\",\n          \"isLocal\": true\n         }\n      ],\n      \"effectiveSlaDomainId\": \"string\",\n      \"effectiveSlaDomainName\": \"string\",\n      \"effectiveSlaSourceObjectId\": \"string\",\n      \"effectiveSlaSourceObjectName\": \"string\"\n    }\n  ],\n\"virtualMachines\": [\n    {\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"configuredSlaDomainId\": \"string\",\n      \"configuredSlaDomainName\": \"string\",\n      \"primaryClusterId\": \"string\",\n      \"slaAssignment\": \"Derived\",\n      \"effectiveSlaDomainId\": \"string\",\n      \"effectiveSlaDomainName\": \"string\",\n      \"effectiveSlaSourceObjectId\": \"string\",\n      \"effectiveSlaSourceObjectName\": \"string\",\n      \"moid\": \"string\",\n      \"vcenterId\": \"string\",\n      \"hostName\": \"string\",\n      \"hostId\": \"string\",\n      \"clusterName\": \"string\",\n      \"snapshotConsistencyMandate\": \"UNKNOWN\",\n      \"powerStatus\": \"string\",\n      \"protectionDate\": \"2018-10-02T20:33:03.833Z\",\n      \"ipAddress\": \"string\",\n      \"agentStatus\": {\n        \"agentStatus\": \"string\",\n        \"disconnectReason\": \"string\"\n      },\n      \"toolsInstalled\": true,\n      \"isReplicationEnabled\": true,\n      \"folderPath\": [\n        {\n          \"id\": \"string\",\n          \"managedId\": \"string\",\n          \"name\": \"string\"\n        }\n      ],\n      \"infraPath\": [\n        {\n          \"id\": \"string\",\n          \"managedId\": \"string\",\n          \"name\": \"string\"\n        }\n      ],\n      \"vmwareToolsInstalled\": true,\n      \"isRelic\": true,\n      \"guestCredentialAuthorizationStatus\": \"string\",\n      \"cloudInstantiationSpec\": {\n        \"imageRetentionInSeconds\": 0\n      },\n      \"parentAppInfo\": {\n        \"id\": \"string\",\n        \"isProtectedThruHierarchy\": true\n      }\n    }\n  ]\n}\n```\n\n### Query asynchronous job status for VMware compute cluster\n\nTo query the job status details of an asynchronous job that is related to an VMware compute cluster with a GET to [`/vmware/compute_cluster/request/{id}`](#operation/getAsyncRequestStatusForComputeCluster).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/compute_cluster/request/$job_id\"\n```\n\n```bash\n{\n  \"id\": \"string\",\n  \"status\": \"string\",\n  \"progress\": 0,\n  \"startTime\": \"2018-10-02T20:33:03.933Z\",\n  \"endTime\": \"2018-10-02T20:33:03.933Z\",\n  \"nodeId\": \"string\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n```\n\n### VMware IO filters operations\n\nAll IO filters on a specific VMware compute cluster can be found with a GET on [`/vmware/compute_cluster/{id}/io_filter`](#operation/getIoFilters).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/io_filter\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"version\": \"string\",\n      \"vendor\": \"string\",\n      \"releaseDate\": \"string\",\n      \"summary\": \"string\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nInstall the latest version of Rubrik IO filter to a specific VMware compute cluster with a POST on [`/vmware/compute_cluster/{id}/install_io_filter`](#operation/installIoFilter).\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/install_io_filter\"\n```\n\n```bash\n{\n  \"id\": \"string\",\n  \"status\": \"string\",\n  \"progress\": 0,\n  \"startTime\": \"2018-10-02T20:33:03.933Z\",\n  \"endTime\": \"2018-10-02T20:33:03.933Z\",\n  \"nodeId\": \"string\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n```\n\nUninstall the Rubrik IO filter from a specific VMware compute cluster with a POST on [`/vmware/compute_cluster/{id}/uninstall_io_filter`](#operation/uninstallIoFilter).\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/uninstall_io_filter\"\n```\n\n```bash\n{\n  \"id\": \"string\",\n  \"status\": \"string\",\n  \"progress\": 0,\n  \"startTime\": \"2018-10-02T20:33:03.933Z\",\n  \"endTime\": \"2018-10-02T20:33:03.933Z\",\n  \"nodeId\": \"string\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n```\n\nUpdate the Rubrik IO filter to the latest version for a specific VMware compute cluster with a POST on [`/vmware/compute_cluster/{id}/upgrade_io_filter`](#operation/upgradeIoFilter).\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/upgrade_io_filter\"\n```\n\n```bash\n{\n  \"id\": \"string\",\n  \"status\": \"string\",\n  \"progress\": 0,\n  \"startTime\": \"2018-10-02T20:33:03.933Z\",\n  \"endTime\": \"2018-10-02T20:33:03.933Z\",\n  \"nodeId\": \"string\",\n  \"error\": {\n    \"message\": \"string\"\n  },\n  \"links\": [\n    {\n      \"href\": \"string\",\n      \"rel\": \"string\"\n    }\n  ]\n}\n```\n\n### Getting Live CDP fields for a batch of CDP-enabled virtual machines\n\nSend a POST request to\n[`/vmware/vm/cdp`](#operation/getVmwareCdpLiveInfo).\nThe request takes a list of virtual machine IDs that correspond to CDP-enabled\nvirtual machines as a mandatory parameter named 'ids'.\n\n```bash\ncurl -X POST \\\n  -d '{\n     \"ids\": [\"id_1\", \"id_2\"]\n     }'\\\n      \"https://$cluster_address/api/v1/vmware/vm/cdp\"\n```\n\nThe Rubrik REST API server responds with a `ListResponse` object.\n\n```bash\n{\n  \"responses\": [\n    {\n    \"vmId\": \"id_1\",\n    \"localRecoveryPoint\": \"2018-01-01T12:34:56.789Z\",\n    \"remoteRecoveryPoint\": \"2018-01-01T12:34:56.789Z\"\n    },\n    {\n    \"vmId\": \"id_2\",\n    \"localRecoveryPoint\": \"\",\n    \"remoteRecoveryPoint\": \"\"\n    }\n  ]\n}\n```\n\n\n# Hosts\n\nRubrik clusters can protect file system data and application data through direct interaction with a host operating system. This method of protection does not require a virtual environment API. Instead, the Rubrik cluster works with the Rubrik Backup Service software that is running on supported Linux hosts and Windows hosts.\n\nIn some situations, the Rubrik cluster can directly interact with hosts without the Rubrik Backup Service, for example when providing protection of data on a network share.\n\n## Rubrik Backup Service\n\nThe Rubrik Backup Service software must be installed on a host to enable file system level protection and direct protection of supported applications. The Rubrik Backup Service software is signed by a specific Rubrik cluster and can only be used with that Rubrik cluster.\n\nThe following URLs provide access to the Rubrik Backup Service software on a Rubrik cluster:\n* Linux: https://$cluster_address/connector/rubrik-agent.x86_64.rpm\n* Windows: https://$cluster_address/connector/RubrikBackupService.zip\n\n**IMPORTANT:** The Rubrik User Guide describes how to install the Rubrik Backup Service software, and lists the permissions and settings that are required to allow the Rubrik Backup Service to provide support for specific operating systems, applications, and clusters.\n\n## Registering a host\nAfter installing the Rubrik Backup Service on a host, register the host with the Rubrik cluster. Registering initiates secure communication between the Rubrik cluster and the Rubrik Backup Service on the host. After a host is registered, the Rubrik Backup Service on the host sends detailed information about the host to the Rubrik cluster.\n\nThe Rubrik Backup Service scans a registered host for protectable objects, such as: applications, databases, and Windows clusters. The Rubrik Backup Service sends the results of the scan to the Rubrik cluster.\n\nTo register a host, send a POST request to [`/host`](#operation/registerHost) and include `hostname: $hostname`. The `$hostname` value must be the IPv4 address of the host or the resolvable hostname of the host.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"hostname\": \"$hostname\" }' \\\n  \"https://$cluster_address/api/v1/host\"\n```\nThe Rubrik REST API server responds with the details for the host, including the connection status.\n\n```bash\n{\n  \"id\": \"$host_id\",\n  \"name\": \"$hostname\",\n  \"hostname\": \"$hostname\", (deprecated)\n  \"primaryClusterId\": \"$cluster_id\",\n  \"agentId\": \"$agent_id\",\n  \"operatingSystem\": \"$os_version\",\n  \"operatingSystemType\": \"$os_type\",\n  \"status\": \"Connected\",\n  \"compressionEnabled\": false\n}\n```\n\n## Retrieving host information\n\nTo retrieve a current list of the hosts that are registered with a Rubrik cluster, send a GET request to [`/host`](#operation/queryHost).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/host\"\n```\n\nThe Rubrik REST API server responds with a ListResponse object that contains the first page of the current list.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$host_id0\",\n      \"name\": \"$hostname0\",\n      \"hostname\": \"$hostname0\", (deprecated)\n      \"primaryClusterId\": \"$cluster_id\",\n      \"operatingSystem\": \"$os_version0\",\n      \"operatingSystemType\": \"$os_type0\",\n      \"status\": \"Connected\"\n    },\n    {\n      \"id\": \"$host_id1\",\n      \"name\": \"$hostname1\",\n      \"hostname\": \"$hostname1\", (deprecated)\n      \"primaryClusterId\": \"$cluster_id\",\n      \"operatingSystem\": \"$os_version1\",\n      \"operatingSystemType\": \"$os_type1\",\n      \"status\": \"Connected\"\n    }\n  ],\n  \"total\": 2\n}\n```\nDepending on the number of registered hosts, the complete list of registered hosts may not be included on the first page. [Working with lists](#section/Overview/Working-with-lists) describes how to work with a ListResponse object to obtain additional pages of the list.\n\n\nTo retrieve the details for a specified host, send a GET request to [`/host/{id}`](#operation/getHost).\n\nAdding a host will cause Rubrik to communicate with the remote Rubrik agent and get detailed information about the host.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/host/$host_id0\"\n```\nThe Rubrik REST API server responds with the details of the specified host.\n\n```bash\n  {\n    \"id\": \"$host_id0\",\n    \"name\": \"$hostname0\",\n    \"hostname\": \"$hostname0\", (deprecated)\n    \"primaryClusterId\": \"$cluster_id\",\n    \"agentId\": \"$agent_id\",\n    \"operatingSystem\": \"$os_version0\",\n    \"operatingSystemType\": \"$os_type0\",\n    \"status\": \"Connected\",\n    \"compressionEnabled\": false\n  }\n```\n\n## Adding a host without the Rubrik Backup Service\n\nA host without the Rubrik Backup Service can be added by setting the `hasAgent` flag to `false`. This can be used to register a host that will be accessed through network shares.\n\n```bash\ncurl -X POST \\\n  -d '{ \\\n    \"hostname\": \"$hostname\",\n    \"hasAgent\": \"false\" }' \\\n  \"https://$cluster_address/api/v1/host\"\n```\n\n## Modifying a registered host\n\nTo change the FQDN or IPv4 address that the Rubrik cluster uses to connect with a registered host, send a PATCH request to [`/host`](#operation/updateHost). Use the value of `hostname` to specify the new FQDN or IPv4 address of the host. Optionally, also use this PATCH request to specify whether to compress the data that is transmitted to and from the host. Set the value of `compressionEnabled` to `true` to enable compression or set the value to `false` to turn compression off.\n\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"hostname\": \"$hostname\",\n    \"compressionEnabled\": true }' \\\n  \"https://$cluster_address/api/v1/host/$host_id\"\n```\n\nThe Rubrik REST API server responds with a confirmation of the new details of the registered host.\n\n```bash\n {\n  \"id\": \"$host_id\",\n  \"name\": \"$hostname\",\n  \"hostname\": \"$hostname\", (deprecated)\n  \"primaryClusterId\": \"$cluster_id\",\n  \"agentId\": \"$agent_id\",\n  \"operatingSystem\": \"$os_version\",\n  \"operatingSystemType\": \"$os_type\",\n  \"status\": \"Connected\",\n  \"compressionEnabled\": true\n }\n```\n## Removing a host\n\nRemove a host from the Rubrik cluster when the host no longer requires protection. The Rubrik cluster moves all of the unexpired backups for the host filesets of the host to Unmanaged Objects.\n\nTo remove a host send a DELETE request to [`/host/{id}`](#operation/deleteHost).\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/host/$host_id\"\n```\n\nThe Rubrik REST API server responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.\n\n## Refreshing a Host\n\nRefresh a host when changes made on the host do not appear in the\nRubrik web UI. The refresh requests updated information from the\nRubrik Backup Service that is running on the host.\n\nTo refresh a host send a POST request to\n[`/host/{id}/refresh`](#operation/refreshHost)\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/host/$host_id/refresh\"\n```\n\nThe Rubrik REST API server responds with HTTP response code 200 and\nincludes the updated properties of the host object in the response body.\n\n## Updating a Host Certificate\n\nWhen a host has a new certificate that is not registered with Rubrik\nthe Rubrik cluster will not communicate with that host until the\ncertificate is updated. In order to do that send a PUT request to\n[`/host/certificate/{id}`](#operation/updateCertificateHost)\n\n```bash\ncurl -X PUT \\\n  \"https://$cluster_address/api/v1/host/certificate/$host_id\"\n```\n\nThe Rubrik REST API server responds with the details of the specified host.\n\n## Windows Server Failover Clustering nodes\n\nTo begin working with Windows Server Failover Clustering (WSFC) clusters, register each WSFC node with the Rubrik cluster as described in [`Registering a host`](#section/Hosts/Registering-a-host). The scan performed by the Rubrik Backup Service on each WSFC node detects the WSFC cluster and provides information about the WSFC cluster to the Rubrik cluster.\n\nTo view WSFC cluster information, send a GET request to [`/windows_cluster`](#operation/queryWindowsCluster).\n\n**Note:** The variable `$cluster_address` refers to the FQDN or IPv4 address of the Rubrik cluster.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/windows_cluster\"\n```\nThe Rubrik REST API server responds with a ListResponse object that contains the first page of the list of WSFC clusters.\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"id\": \"$wsfc_id\",\n      \"name\": \"$wsfc_name\",\n      \"fqdn\": \"$wsfc_fqdn\",\n      \"hostIds\": [\n        \"$wsfc_node_id0\",\n        \"$wsfc_node_id1\"\n      ],\n      \"primaryClusterId\": \"$cluster_id\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\nTo retrieve detailed information about a WSFC cluster, send a GET request to: [`/windows_cluster/{id}`](#operation/getWindowsCluster), where `$cluster_id` is the `id` of the WSFC cluster.\n\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/windows_cluster/$cluster_id\"\n```\n\nThe Rubrik REST API server responds with the details for the specified WSFC cluster.\n\n```bash\n{\n  \"name\": \"$wsfc_name\",\n  \"id\": \"$wsfc_id\",\n  \"naturalId\": \"$cluster_natural_id\",\n  \"hostIds\": [\n  \"$wsfc_node_id0\",\n  \"$wsfc_node_id1\"\n  ],\n  \"fqdn\": \"$wsfc_fqdn\",\n  \"primaryClusterId\": \"$cluster_id\"\n}\n```\n\n# Filesets\n\nA fileset defines a set of files and folders on a Linux host or on a Windows host. The Rubrik cluster uses the filesets that are assigned to a host to determine the data to protect on that host.\n\nThe Rubrik cluster interprets a fileset based on the values provided in the\nInclude, Exclude, and Do Not Exclude arrays. The Rubrik cluster applies a\nset of rules to the values provided in these arrays and permits several\ntypes of values to be added to the arrays. The Do Not Exclude array specifies objects that should not be excluded from the fileset by the values in the Exclude array.\n\n## Fileset workflow\nThe basic workflow to follow when using filesets to protect data in host file systems is:\n1. Obtain and install the Rubrik Backup Service software on the host.  \nThe Rubrik user guide describes this task.\n2. Add the host to the Rubrik cluster.  \nThe [Hosts](#section/Hosts) section describes this task.\n3. Create a fileset template that defines a set of file system data to protect.  \nThe [Fileset templates](#section/Filesets/fileset_templates) section describes this task.\n4. Use a fileset template to assign a fileset to a host.\n5. Assign the host fileset to an SLA Domain.\n\n## Fileset templates\n\nTo get the current list of hosts we GET on the [`/fileset_template`](#operation/queryFilesetTemplate) endpoint.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"hostname\": \"$hostname\" }' \\\n  \"https://$cluster_address/api/v1/host\"\n```\n\n```bash\n{\n  \"id\": \"$host_id\",\n  \"hostname\": \"$hostname\",\n  \"status\": \"Connected\"\n}\n```\n\nTo get the current further details of hosts we GET on the [`/fileset_template/{id}`](#operation/getFilesetTemplate) endpoint.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"hostname\": \"$hostname\" }' \\\n  \"https://$cluster_address/api/v1/host\"\n```\n\n```bash\n{\n  \"id\": \"$host_id\",\n  \"hostname\": \"$hostname\",\n  \"status\": \"Connected\"\n}\n```\n\nFirst create a fileset template.\nA fileset template can be used to create fileset instances for various hosts.\nPerforming a POST on [`/fileset_template`](#operation/createFilesetTemplate)  with the necessary details will create a fileset template.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"name\": \"Users\",\n    \"includes\": [\"C:\\\\Users\"],\n    \"operatingSystemType\": \"Windows\"}' \\\n  \"https://$cluster_address/api/v1/fileset_template\"\n```\n\n```bash\n{\n  \"id\": \"$fileset_template_id\",\n  \"name\": \"Users\",\n  \"excludes\": [],\n  \"operatingSystemType\": \"Windows\",\n  \"includes\": [\n    \"C:\\\\Users\"\n  ]\n}\n```\n\nModify with PATCH on the [`/fileset_template/{id}`](#operation/updateFilesetTemplate) endpoint.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"hostname\": \"$hostname\" }' \\\n  \"https://$cluster_address/api/v1/host\"\n```\n\n```bash\n{\n  \"id\": \"$host_id\",\n  \"hostname\": \"$hostname\",\n  \"status\": \"Connected\"\n}\n```\n\nDelete with n the [`/fileset_template/{id}`](#operation/deleteFilesetTemplate) endpoint.\n\n```bash\ncurl -X DELETE \\\n  -d '{\n    \"hostname\": \"$hostname\" }' \\\n  \"https://$cluster_address/api/v1/host\"\n```\n## Fileset\n\nUsing a fileset template, a fileset can be created.\nThe fileset is an instance of the template that is assigned to a specific host.\n\nTo get the current list of hosts we GET on the [`/fileset`](#operation/queryFileset) endpoint.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"hostname\": \"$hostname\" }' \\\n  \"https://$cluster_address/api/v1/host\"\n```\n\n```bash\n{\n  \"id\": \"$host_id\",\n  \"hostname\": \"$hostname\",\n  \"status\": \"Connected\"\n}\n```\n\nTo get the current further details of hosts we GET on the [`/fileset/{id}`](#operation/getFileset) endpoint.\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"hostname\": \"$hostname\" }' \\\n  \"https://$cluster_address/api/v1/host\"\n```\n\n```bash\n{\n  \"id\": \"$host_id\",\n  \"hostname\": \"$hostname\",\n  \"status\": \"Connected\"\n}\n```\n\nA fileset can be created with a POST on [`/fileset`](#operation/createFileset).\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"templateId\": \"$fileset_template_id\",\n    \"hostId\": \"$host_id\" }' \\\n  \"https://$cluster_address/api/v1/fileset\"\n```\n\n```bash\n{\n  \"id\": \"$fileset_id\",\n  \"excludes\": [],\n  \"operatingSystemType\": \"Windows\",\n  \"includes\": [\n    \"C:\\\\Users\"\n  ],\n  \"hostId\": \"$host_id\",\n  \"templateId\": \"$fileset_template_id\",\n  \"configuredSlaDomainId\": \"UNPROTECTED\"\n}\n```\n\nA fileset can be deleted with a DELETE on [`/fileset`](#operation/deleteFileset).\n\n```bash\ncurl -X POST \\\n  -d '{\n    \"templateId\": \"fileset_template_id\",\n    \"hostId\": \"$host_id\" }' \\\n  \"https://$cluster_address/api/v1/fileset\"\n```\n\n```bash\n{\n  \"id\": \"$fileset_id\",\n  \"excludes\": [],\n  \"operatingSystemType\": \"Windows\",\n  \"includes\": [\n    \"C:\\\\Users\"\n  ],\n  \"hostId\": \"$host_id\",\n  \"templateId\": \"$fileset_template_id\",\n  \"configuredSlaDomainId\": \"UNPROTECTED\"\n}\n```\n## On demand backups of host filesets\n\nTo create an on-demand snapshot POST on [`/fileset/{id}/snapshot`](#operation/createFilesetBackupJob).\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/fileset/$fileset_id/snapshot\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/fileset/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\nOnce the snapshot has been taken you should be able to retrieve the `$snapshot_id` by querying [`/fileset/request`](#operation/getFilesetAsyncRequestStatus).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/fileset/request/$request_id\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id\",\n      \"rel\": \"result\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/fileset/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"SUCCEEDED\"\n}\n```\n\n\nOnce the snapshot has been taken you should be able to retrieve the `$snapshot_id` from the request.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/fileset/request/$request_id\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id\",\n      \"rel\": \"result\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/fileset/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"SUCCEEDED\"\n}\n```\n\nFor more information about a specific snapshot, send a GET request to\nthe [`/fileset/snapshot/{id}`](#operation/getFilesetSnapshot) endpoint.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id\"\n```\n\n```bash\n{\n  \"id\": \"$snapshot_id\"\n  \"date\": <timestamp1>,\n  \"expirationDate\": <timestamp2>,\n  \"sourceObjectType\": \"Fileset\",\n  \"isOnDemandSnapshot\": true,\n  \"cloudState\": 2,\n  \"consistencyLevel\": \"none\",\n  \"indexState\": 1,\n  \"replicationLocationIds\": [\n    \"$replication_location_id\"\n  ],\n  \"archivalLocationIds\": [\n    \"$archival_location_id\"\n  ],\n  \"slaId\": \"$sla_id\",\n  \"slaName\": \"sla\",\n  \"filesetName\": \"fileset\",\n  \"fileCount\": 10,\n  \"lastModified\": <timestamp3>,\n  \"size\": 533120\n}\n```\n\nTo delete a specific snapshot, send a DELETE request to the\n[`/fileset/snapshot/{id}`](#operation/deleteFilesetSnapshot) endpoint,\nwhere `{id}` is the ID of the snapshot.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id\"\n```\n\n```bash\n{\n}\n```\n\nDelete all snapshots for a specific vm with a DELETE on [`/fileset/{id}/snapshot`](#operation/deleteFilesetSnapshots).\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/fileset/$vm_id/snapshot\"\n```\n## SLA Domain protection of host filesets\n\nAssign a fileset to an SLA with a PATCH [`/fileset/{id}`](#operation/updateFileset).\n\n```bash\ncurl -X PATCH \\\n  -d '{ \n    \"configuredSlaDomainId\": \"$sla_domain_id\" }' \\\n  \"https://$cluster_address/api/v1/fileset/$fileset_id\"\n```\n\n```bash\n{\n  \"id\": \"$fileset_id\",\n  \"excludes\": [],\n  \"operatingSystemType\": \"Windows\",\n  \"includes\": [\n    \"C:\\\\Users\"\n  ],\n  \"hostId\": \"$host_id\",\n  \"templateId\": \"$fileset_template_id\",\n  \"configuredSlaDomainId\": \"$sla_domain_id\"\n}\n```\n\nMissed snapshot with a GET on [`/fileset/{id}/missed_snapshot`](#operation/getMissedFilesetSnapshots).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/fileset/$vm_id/missed_snapshot\"\n```\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"missedSnapshotTime\": \"2000-01-02T11:08:40.420Z\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\n## Search & Recovery\n\nOnce snapshots have been taken, they can be used to search for files and recover.\n\nA host-level file search can be performed with a GET on [`/host/{id}/search`](#operation/searchHost).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/host/$host_id/search?path=home\"\n```\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"path\": \"/home\",\n      \"filename\": \"home\",\n      \"fileVersions\": [\n        {\n          \"snapshotId\": \"$snapshot_id\",\n          \"lastModified\": \"2014-07-17T02:02:54+0000\",\n          \"size\": 533120\n        }\n      ]\n    }\n  ],\n  \"total\": 1\n}\n```\n\nFile search can be performed on a specific fileset using its `$fileset_id` with a GET on [`/fileset/{id}/search`](#operation/searchFileset) and specifying the file path with the `path` query parameter.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/fileset/$fileset_id/search?path=home\"\n```\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"path\": \"/home\",\n      \"filename\": \"home\",\n      \"fileVersions\": [\n        {\n          \"snapshotId\": \"$snapshot_id\",\n          \"lastModified\": \"2014-07-17T02:02:54+0000\",\n          \"size\": 533120\n        }\n      ]\n    }\n  ],\n  \"total\": 1\n}\n```\n\nGiven the snapshot one can browse files within the snapshot with GET on [`/fileset/snapshot/{id}/browse`](#operation/browseFilesetSnapshot).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/browse?path=%2Fhome&offset=0\"\n```\n\n```bash\n{\n  \"hasMore\": false,\n  \"data\": [\n    {\n      \"filename\": \"ubuntu\",\n      \"path\": \"ubuntu\",\n      \"lastModified\": \"2016-12-01T23:26:59+0000\",\n      \"size\": 529024,\n    }\n  ],\n  \"total\": 1\n}\n```\n\nTo retrieve files from the snapshot we can either download the entire snapshot or just individual files.\nA entire snapshot can be downloaded with POST on [`/fileset/snapshot/{id}/download`](#operation/createDownloadFilesetSnapshotFromCloud).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id\"\n```\n\nAlso individual files can be downloaded with POST on [`/fileset/snapshot/{id}/download`](#operation/createFilesetDownloadFileJob).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/download_file\"\n```\n\nBoth [`/fileset/snapshot/{id}/download`](#operation/createDownloadFilesetSnapshotFromCloud) and [`/fileset/snapshot/{id}/download`](#operation/createFilesetDownloadFileJob) return an async request that can be polled to retrieve the eventual download location.\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/fileset/request/$request_id\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"$download_url\",\n      \"rel\": \"result\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/fileset/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\nFiles from a snapshot can also be restored to a host with POST on [`/fileset/snapshot/{id}/restore_file`](#operation/createFilesetRestoreFileJob).\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"sourceDir\": \"/foo.txt\",\n    \"destinationDir\": \"/bar.txt\"\n  }' \\\n  \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/download_file\"\n```\n\nFiles can also be restored to a different host with POST on [`/fileset/snapshot/{id}/export_file`](#operation/createFilesetExportFileJob).\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"sourceDir\": \"/foo.txt\",\n    \"destinationDir\": \"/bar.txt\",\n    \"hostId\": \"$host_id\"\n  }' \\\n  \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/download_file\"\n```\n\n# SQL Server databases\n\nVersion 3.0 added support for Microsoft SQL backups.\nFirst add the hosts hosting the Microsoft SQL databases as specified in the [host protection](#section/Hosts) section.\nOnce the host has been added, instances and databases will be auto-discovered.\n\n## Instances\n\nMicrosoft SQL instances can be found by a GET on [`/mssql/instance`](#operation/queryMssqlInstance)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/instance\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$instance_id\",\n      \"name\": \"$instance_name\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"INHERIT\",\n      \"effectiveSlaDomainName\": \"Inherit\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nFurther details are acquired from [`/mssql/instance/{id}`](#operation/getMssqlInstance).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/instance/$instance_id\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$instance_id\",\n      \"name\": \"$instance_name\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"UNPROTECTED\",\n      \"effectiveSlaDomainName\": \"Unprotected\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nThe Rubrik cluster auto-detects most fields of the Microsoft SQL instance. However, certain fields such as the `clusterInstanceAddress` can be overridden with a PATCH to [`/mssql/instance/{id}`](#operation/updateMssqlInstance).\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"clusterInstanceAddress\": \"1.1.1.1\"\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/instance/$instance_id\"\n```\n\n```bash\n{\n  \"data\": [\n    '{\n      \"id\": \"$instance_id\",\n      \"name\": \"$instance_name\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"UNPROTECTED\",\n      \"effectiveSlaDomainName\": \"Unprotected\",\n      \"clusterInstanceAddress\": \"1.1.1.1\"\n  }' \\\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\n## Databases\n\nAll Microsoft SQL databases on an instance can be found with a GET on [`/mssql/db`](#operation/queryMssqlDb).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/db?instance_id=$instance_id\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$db_id\",\n      \"name\": \"$db_name\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"UNPROTECTED\",\n      \"effectiveSlaDomainName\": \"Unprotected\",\n      \"instanceId\": \"$instance_id\"\n      \"instanceName\": \"$instance_name\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\nFurther details are acquired from [`/mssql/db/{id}`](#operation/getMssqlDb).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/db/$db_id\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$db_id\",\n      \"name\": \"$db_name\",\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"UNPROTECTED\",\n      \"effectiveSlaDomainName\": \"Unprotected\",\n      \"instanceId\": \"$instance_id\"\n      \"instanceName\": \"$instance_name\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\n## Protection\n\nTo create an on-demand snapshot, POST on [`/mssql/db/{id}/snapshot`](#operation/createOnDemandMssqlBackup).\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/snapshot\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\nOnce the snapshot has been taken, the `$snapshot_id` can be retrieved from the request with [`/mssql/request/{id}`](#operation/getMssqlAsyncRequestStatus).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/mssql/request/$request_id\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/snapshot/$snapshot_id\",\n      \"rel\": \"result\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"SUCCEEDED\"\n}\n```\n\nThe `$snapshot_id` can be used to extract further information on the snapshot with a GET on [`/mssql/db/snapshot/{id}`](#operation/getMssqlDbSnapshot).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/mssql/db/snapshot/$snapshot_id\"\n```\n\n```bash\n{\n  \"id\": \"$snapshot_id\",\n  \"date\": \"2017-02-02T18:53:12.718Z\",\n  \"isOnDemandSnapshot\": true\n}\n```\n\nTo create an on-demand log backup, POST on [`/mssql/db/{id}/log_backup`](#operation/createOnDemandMssqlLogBackup).\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/log_backup\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\nTo protect a specific database under an SLA, perform a PATCH on [`/mssql/db/{id}`](#operation/updateMssqlDb)\n\n```bash\ncurl -X PATCH \\\n  -d '{\n    \"configuredSlaDomainId\": \"$sla_domain_id\" }' \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id\"\n```\n\n```bash\n{\n  \"id\": \"$db_id\",\n  \"name\": \"$db_name\",\n  \"configuredSlaDomainId\": \"$sla_domain_id\",\n  \"configuredSlaDomainName\": \"$sla_domain_name\",\n  \"effectiveSlaDomainId\": \"$sla_domain_id\",\n  \"effectiveSlaDomainName\": \"sla_domain_name\",\n  \"instanceId\": \"$instance_id\"\n  \"instanceName\": \"$instance_name\"\n}\n```\n\nList all snapshots for a database with a GET on [`/mssql/db/{id}/snapshot`](#operation/queryMssqlDbSnapshot).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/snapshot\"\n```\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"$snapshot_id\",\n      \"date\": \"2017-02-02T18:53:12.718Z\",\n      \"isOnDemandSnapshot\": true\n    }\n  ],\n  \"total\": 1\n}\n```\n\nPoint-in-time recovery is supported when log backups are taken. The range of recoverable times can be listed with a GET on [`/mssql/db/{id}/recoverable_range`](#operation/getMssqlDbRecoverableRanges).\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/recoverable_range\"\n```\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"beginTime\": \"2017-02-02T18:53:12.694Z\",\n      \"endTime\": \"2017-02-02T20:53:12.694Z\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\nA 'missed snapshot' occurs when a snapshot that is required by SLA Domain policy cannot be created.\nTo retrieve information about missed snapshots, send a GET request to the [`/mssql/db/{id}/missed_snapshot`](#operation/getMissedMssqlDbSnapshots) endpoint.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/missed_snapshot\"\n```\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"missedSnapshotTime\": \"2000-01-02T11:08:40.420Z\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\nTo retrieve the recoverable time ranges that were missed for a specified database, send a GET request to the [`/mssql/db/{id}/missed_recoverable_range`](#operation/getMssqlDbMissedRecoverableRanges) endpoint.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/missed_recoverable_range\"\n```\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"beginTime\": \"2017-02-02T18:53:12.694Z\",\n      \"endTime\": \"2017-02-02T20:53:12.694Z\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\nDelete all snapshots for a specific database with a DELETE on [`/mssql/db/{id}/snapshot`](#operation/deleteMssqlDbSnapshots).\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/mssql/db/$db_id/snapshot\"\n```\n\nAssign SLA properties to multiple objects with a POST to\n[`mssql/sla_domain/assign`](#operation/assignMssqlSlaProperties).\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"ids\": [\"$id1\", \"$id2\"],\n    \"copyOnly\": true,\n    \"configuredSlaDomainId\": \"$slaDomainId\"\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/sla_domain/assign\"\n```\n\n## Restore\n\nPerform a restore with a POST on [`/mssql/db/{id}/restore`](#operation/createRestoreMssqlDb) specifying the timestamp as the recovery point.\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"recoveryPoint\": {\n      \"timestampMs\": 12345\n    }\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/restore\"\n```\n\nA database can also be exported to another instance with a POST on [`/mssql/db/{id}/export`](#operation/createExportMssqlDb).\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"recoveryPoint\": {\n      \"timestampMs\": 12345\n    },\n    \"targetInstanceId\": \"$instance_id\",\n    \"targetDatabaseName\": \"$db_name\"\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/export\"\n```\n\n## Live Mount\n\nPerform a Live Mount with a POST on [`/mssql/db/{id}/mount`](#operation/createMssqlMount), specifying the timestamp as the recovery point.\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"recoveryPoint\": {\n      \"timestampMs\": 12345\n    },\n    \"mountedDatabaseName\": \"$db_name\"\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/db/$db_id/mount\"\n```\n\nAll current Live Mounts can be found with a GET on [`/mssql/db/mount`](#operation/queryMssqlMount).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/db/mount\"\n```\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"$mount_id\",\n      \"sourceDatabaseId\": \"$source_db_id\",\n      \"sourceRecoveryPoint\": {\n        \"timestampMs\": 12345\n      },\n      \"targetInstanceId\": \"$target_instance_id\",\n      \"creationDate\": \"2017-02-02T18:53:12.694Z\",\n      \"isReady\": true,\n      \"mountedDatabaseId\": \"$mounted_db_id\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\nFurther details for a single Live Mount are acquired from [`/mssql/db/mount/{id}`](#operation/getMssqlMount).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/db/mount/$mount_id\"\n```\n\n```bash\n{\n  \"id\": \"$mount_id\",\n  \"sourceDatabaseId\": \"$source_db_id\",\n  \"sourceRecoveryPoint\": {\n    \"timestampMs\": 12345\n  },\n  \"targetInstanceId\": \"$target_instance_id\",\n  \"creationDate\": \"2017-02-02T18:53:12.694Z\",\n  \"isReady\": true,\n  \"mountedDatabaseId\": \"$mounted_db_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/$source_db_id\",\n      \"rel\": \"sourceDatabase\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/instance/$target_instance_id\",\n      \"rel\": \"targetInstance\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/$mounted_db_id\",\n      \"rel\": \"mountedDatabase\"\n    }\n  ],\n}\n```\n\nDelete a Live Mount with a DELETE on [`/mssql/db/mount/{id}`](#operation/createMssqlUnmount).\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/mssql/db/mount/$mount_id\"\n```\n\n## Log Shipping\n\nCreate a Log Shipping Configuration with a POST on [`/mssql/db/{id}/log_shipping`](#operation/createLogShippingConfiguration).\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"config\": {\n      \"targetInstanceId\": \"$target_instance_id\",\n      \"targetDatabaseName\": \"$db_name\",\n      \"state\": \"$state\"\n    }\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/db/{id}/log_shipping\"\n```\n\nAll current Log Shipping Configurations can be found with a GET on [`/mssql/db/log_shipping`](#operation/queryLogShippingConfigurations).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/db/log_shipping\"\n```\n\n```bash\n{\n  \"hasMore\": true,\n  \"data\": [\n    {\n      \"id\": \"$log_shipping_id\",\n      \"lastAppliedPoint\": \"2017-02-02T18:53:12.694Z\",\n      \"location\": \"$host_name/$instance_name\",\n      \"primaryDatabaseId\": \"$primary_db_id\",\n      \"primaryDatabaseName\": \"$primary_database_name\",\n      \"secondaryDatabaseName\": \"$secondary_database_name\",\n      \"secondaryDatabaseId\": \"$secondary_database_id\",\n      \"state\": \"$state\",\n      \"status\": \"OK\"\n    }\n  ],\n  \"total\": 1\n}\n```\n\nFurther details for a single Log Shipping configuration are acquired from [`/mssql/db/log_shipping/{id}`](#operation/getLogShippingConfiguration).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/db/log_shipping/{id}\"\n```\n\n```bash\n{\n  \"id\": \"$log_shipping_id\",\n  \"lastAppliedPoint\": \"2017-02-02T18:53:12.694Z\",\n  \"location\": \"$host_name/$instance_name\",\n  \"primaryDatabaseId\": \"$primary_db_id\",\n  \"primaryDatabaseName\": \"$primary_database_name\",\n  \"secondaryDatabaseName\": \"$secondary_database_name\",\n  \"secondaryDatabaseId\": \"$secondary_database_id\",\n  \"state\": \"$state\",\n  \"status\": \"OK\"\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/$primary_db_id\",\n      \"rel\": \"primaryDatabase\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/instance/$secondary_instance_id\",\n      \"rel\": \"secondaryInstance\"\n    },\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/$secondary_db_id\",\n      \"rel\": \"secondaryDatabase\"\n    }\n  ],\n}\n```\n\nUpdate a Log Shipping Configuration with a PATCH on [`/mssql/db/log_shipping/{id}`](#operation/updateLogShippingConfiguration).\n\n```bash\ncurl -X PATCH -d \\\n  '{\n    \"config\": {\n      \"state\": \"$state\"\n    }\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/db/log_shipping/$id\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\nDelete a Log Shipping Configuration with a DELETE on [`/mssql/db/log_shipping/{id}`](#operation/deleteLogShippingConfiguration).\n\n```bash\ncurl -X DELETE \"https://$cluster_address/api/v1/mssql/db/log_shipping/$id?delete_secondary_database=true\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\nReseed a Log Shipping Configuration with a POST on [`/mssql/db/log_shipping/{id}/reseed`](#operation/reseedSecondary)\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"config\": {\n      \"state\": \"$state\"\n    }\n  }' \\\n  \"https://$cluster_address/api/v1/mssql/db/log_shipping/$id/reseed\"\n```\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/mssql/db/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\n# Hierarchy\n\nThis REST API is used to get SQL Server hierarchy objects.\n\n### Get list of immediate descendant objects\nGet a list of immediate descendant objects using a GET request to\n[/mssql/hierarchy/{id}/children]\\\n(#operation/getMssqlHierarchyChildren).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/hierarchy/{id}/children\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$database_id\",\n      \"name\": \"$database_name\",\n      \"objectType\": \"MssqlDatabase\",\n      \"descendantCount\": {},\n      \"hasPermissions\": true,\n      \"isInAvailabilityGroup\": false,\n      \"isLiveMount\": false,\n      \"isLogShippingSecondary\": false,\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"INHERIT\",\n      \"effectiveSlaDomainName\": \"Inherit\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\n### Get list of descendant objects\nGet a list of descendant objects using\na GET request to\n[/mssql/hierarchy/{id}/descendants]\\\n(#operation/getMssqlHierarchyDescendants).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/hierarchy/{id}/descendants\"\n```\n\n```bash\n{\n  \"data\": [\n    {\n      \"id\": \"$database_id\",\n      \"name\": \"$database_name\",\n      \"objectType\": \"MssqlDatabase\",\n      \"descendantCount\": {},\n      \"hasPermissions\": true,\n      \"isInAvailabilityGroup\": false,\n      \"isLiveMount\": false,\n      \"isLogShippingSecondary\": false,\n      \"configuredSlaDomainId\": \"INHERIT\",\n      \"configuredSlaDomainName\": \"Inherit\",\n      \"effectiveSlaDomainId\": \"INHERIT\",\n      \"effectiveSlaDomainName\": \"Inherit\"\n    }\n  ],\n  \"hasMore\": false,\n  \"total\": 1\n}\n```\n\n### Get an object\nGet an object in the hierarchy using a GET request to\n[/mssql/hierarchy/{id}]\\\n(#operation/getMssqlHierarchyObject).\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/mssql/hierarchy/{id}\"\n```\n\n```bash\n{\n  \"id\": \"$database_id\",\n  \"name\": \"$database_name\",\n  \"objectType\": \"MssqlDatabase\",\n  \"descendantCount\": {},\n  \"hasPermissions\": true,\n  \"isInAvailabilityGroup\": false,\n  \"isLiveMount\": false,\n  \"isLogShippingSecondary\": false,\n  \"configuredSlaDomainId\": \"INHERIT\",\n  \"configuredSlaDomainName\": \"Inherit\",\n  \"effectiveSlaDomainId\": \"INHERIT\",\n  \"effectiveSlaDomainName\": \"Inherit\"\n}\n```\n\n# Oracle Databases\n\n## Delete Downloaded Oracle Db Snapshots and Log Snapshots\n\nTo request an asynchronous job to expire downloaded database snapshots taken during a specified time period as well as log snapshots that contain any logs with timestamps within that time period, send a DELETE request to the [`/oracle/db/{id}/downloaded_snapshots`](#operation/deleteDownloadedSnapshots) endpoint with optional query parameters before_time and after_time.\n\n```bash\ncurl -X DELETE \\\n  \"https://$cluster_address/api/v1/oracle/db/{id}/downloaded_snapshots?before_time=2016-01-01T01:23:45.678&after_time=2016-01-01T01:23:45.678\"\n  ```\nAn async request is returned and can be polled to retrieve the job status.\n\n```bash\n{\n  \"id\": \"$request_id\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/internal/oracle/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ],\n  \"status\": \"QUEUED\"\n}\n```\n\n## Provide Estimate for Restore Operation Download\n\nTo request the number of bytes that must be downloaded for a restore operation for an Oracle database, send a GET request to the [`/oracle/db/{id}/restore_estimate`](#operation/oracleRestoreEstimate) endpoint with the snapshot ID or the time to be restored to.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/oracle/db/{id}/restore_estimate?recovery_time=2016-01-01T01:23:45.678\"\n```\nAn OracleRestoreEstimateResult object is returned which stores the number of bytes which are needed to restore.\n\n```bash\n{\n  \"bytesToRestore\": \"$bytesToRestore\",\n}\n```\n\n# vApps\n\nThe Rubrik cluster protects vApps running in a VMware vCloud Director\nenvironment through the vCloud Director REST APIs. The Rubrik cluster must\nconnect to the underlying vCenter servers to protect vApps.\n\n## vApp Templates\n\nThe Rubrik cluster protects vApp template objects through the vCloud\nDirector APIs.\n\n## vCloud Director server\n\nA Rubrik cluster protects and manages vApps and vApp templates through\nthe vCloud Director server that administers those vApps. After a\nvCloud Director server is added to a Rubrik cluster, the Rubrik cluster\nautomatically discovers the vApps administered under the server.\n\n### Retrive details for a vApp Template snapshot export\n\nTo retrieve the options available for exporting a specified vApp template\nsnapshot to an organization vDC and available storage policies, send a GET\nrequest to [`/vcd/vapp/template/snapshot/{snapshot_id}/export/options`](#operation/getVappTemplateSnapshotExportOptions)\n\nA GET request that is sent to the [`/vcd/vapp/template/snapshot/{snapshot_id}/export/options`](#operation/getVappTemplateSnapshotExportOptions)\nendpoint accepts the query parameters that are described in the following table.\n\n| Parameter | Description |\n| --------- | ----------- |\n|`catalog_id`| ID of the target Catalog object.|\n|`name`| Name of template object to be created. This is used to verify the existence of a template with the given name. Templates must have unique names.\n|`org_vdc_id`| ID assigned to a target organization VDC object. This parameter is required when advanced export options are used.\n\nA vApp template export targets a catalog and requires a valid storage policy and\norganization vDC. There are three options\navailable for export of a vApp template -\n* **OriginalVdcExportOptions** - This option is used to export to the\noriginal organization vDC of the vApp template when the snapshot was taken.\nOnly available when the catalog to export is under the same organization as\nthe original organization vDC and the vDC is still active.\n`org_vdc_id` is not required when using this option.\n* **DefaultCatalogExportOptions** - This option is used to export to vDC\ncorresponding to the default storage policy of the catalog. This option is\nunavailable for catalogs that do not have storage policies.\n`org_vdc_id` is not required when using this option.\n* **AdvancedExportOptions** - This option is used to export to a specific\norganization vDC under the same organization as the Catalog to export. The\nGET request returns the choices of storage policies available.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/vcd/vapp/template/snapshot/$napshot_id/export/options?catalog_id=$catalog_id&name=$template_name\"\n```\n\nThe Rubrik API responds with a `VappTemplateExportOptionsUnion` object which\nhas fields for all the above options.\n\n**Note:** To shorten the example, the response uses ellipses to replace some\n members.\n\n```bash\n{\n  \"hasMore\": false,\n  \"originalVdcExportOptions\" :\n    {\n      \"orgVdcId\": \"$org_vdc_id1\",\n      \"availableStoragePolicies\": [\n        ...\n      ]\n    },\n   \"defaultCatalogExportOptions\" :\n    {\n      \"orgVdcId\": \"$org_vdc_id1\",\n      \"availableStoragePolicies\": [\n        ...\n      ]\n    },\n   \"advancedExportOptions\" :\n    {\n      \"orgVdcId\": \"$org_vdc_id1\",\n      \"availableStoragePolicies\": [\n        ...\n      ]\n    }\n}\n```\n\n### Export a vApp Template snapshot\nCreates a new vApp Template in a catalog using the export feature. To use the\nexport feature, send a POST request to [`/vcd/vapp/template/snapshot/{snapshot_id}/export`](#operation/createVappTemplateSnapshotExport)\nThis request requires a `snapshot_id` and includes a config which includes\nthe parameters that are described in the following table.\n\n| Name | Description |\n| ---- | ----------- |\n|`name`| Name of vApp Template to be created.|\n|`catalogId`| ID of the Catalog where the vApp Template is created.|\n|`orgVdcId`| ID of the organization vDC where the vApp Template is created.|\n|`storagePolicyId`| ID of the organization vDC storage policy to be used. In case a storage policy ID is not provided, the default of the organization vDC is used.\n\n**Note:** The Catalog and organization vDC must belong to the same\norganization. When providing a storage policy, that storage policy must be\npresent in the organization vDC.\n\n```bash\ncurl -X POST -d \\\n  '{\n    \"name\": \"$template_name\",\n    \"catalogId\": \"$catalog_id\",\n    \"orgVdcId\": \"$org_vdc_id\"\n   }' \\\n   \"https://$cluster_address/api/v1/vcd/vapp/template/snapshot/{snapshot_id}/export\"\n```\n\nThe Rubrik REST API server initiates the asynchronous request task and responds\nwith a task object.\n\n```bash\n{\n  \"id\": \"$instant_recovery_task_id\",\n  \"status\": \"QUEUED\",\n  \"progress\": 0,\n  \"startTime\": \"$timestamp\",\n  \"links\": [\n    {\n      \"href\": \"https://$cluster_address/api/v1/vcd/vapp/request/$request_id\",\n      \"rel\": \"self\"\n    }\n  ]\n}\n```\n\n# Blackout Windows\n\n## Get Global Blackout Window Status\nSend a GET request to ['/blackout_window`](#operation/getBlackoutWindowStatus)\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/blackout_window\"\n```\n\n## Start or Stop the Global Blackout Window in local Rubrik Cluster\nSend a PATCH request to [`/blackout_window`](#operation/toggleBlackoutWindow)\n\n```bash\ncurl -X PATCH \\\n  -d '{ \\\n   \"isGlobalBlackoutActive\": true \\\n   }' \\\n  \"https://$cluster_address/api/v1/blackout_window\"\n```\n\n# Managed Volumes\n\n## Create Script to Unify Managed Volume Export View\n\nTo request an asynchronous job to generate a script to create a directory to view all files in all channels of a managed volume export, send a POST request to the [`/managed_volume/snapshot/export/{id}/script`](#operation/createManagedVolumeGenerateScriptJob) endpoint with the ID of the snapshot export.\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/managed_volume/snapshot/export/{id}/script\"\n```\nAn asynchronous request is returned and can be polled to retrieve the job status.\n\n```bash\n{\n  \"id\":\"$request_id\",\n  \"links\": [\n    {\n      \"href\":\"https://$cluster_address/api/v1/managed_volume/request/$request_id\",\n      \"rel\":\"result\"\n    },\n  \"status\":\"QUEUED\"\n}\n```\n\n# Archival\n\n## Create Script to Refresh data sources in a Reader location\n\nSend a POST request to the [`/archive/location/{location_id}/reader/refresh/data_sources`](#operation/refreshArchivalLocationDataSources) endpoint to request an asynchronous job that refreshes the metadata for a list of data sources from a specified reader location. The POST request must provide the ID of the reader location and a list of the IDs of the data sources in the archival location.\n\n```bash\ncurl -X POST \\\n  \"https://$cluster_address/api/v1/archive/location/{location_id}/reader/refresh/data_sources\"\n```\nAn asynchronous request is returned and can be polled to retrieve the job status.\n\n```bash\n{\n  \"id\":\"$request_id\",\n  \"links\": [\n    {\n      \"href\":\"https://$cluster_address/api/v1/archive/request/$request_id\",\n      \"rel\":\"result\"\n    },\n  \"status\":\"QUEUED\"\n}\n```\n\n## Get the ID of the customer AWS account that owns the archival location\n\nSend a GET request to the [`/archive/aws/s3/{id}/account_id`](#operation/getAwsAccountId) endpoint to request the ID of the AWS customer account for the S3 archival location. Returns an error when the location given is not an AWS S3 archival location.\n\n```bash\ncurl -X GET \\\n  \"https://$cluster_address/api/v1/archive/aws/s3/{id}/account_id\"\n```\nReturns the ID of the AWS account.\n\n# Rubrik syslog management\n\nRubrik CDM clusters include the capability to add export rules to forward\nsyslog information to remote servers.\n\n# Managing the Rubrik cluster syslog settings\n\nTo view all the currently configured syslog export rules, send a GET request to\nthe [`/syslog/export`](#operation/getSyslogExportRules) endpoint.\n\n**Example:** Retrieving the currently configured syslog export rules for a\nRubrik cluster\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/syslog/export\"\n```\n\nTo add a new syslog export rule, send a POST request to the\n[`/syslog/export`](#operation/addSyslogExportRule) endpoint.\n\n**Example:** Adding a new syslog export rule for a Rubrik cluster\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/syslog/export\"\n```\n\nTo retrieve a syslog export rule, send a GET request with the export rule ID to\nthe [`/syslog/export/{id}`](#operation/getSyslogExportRule) endpoint.\n\nTo modify a syslog export rule, send a PATCH request with the export rule ID to\nthe [`/syslog/export/{id}`](#operation/updateSyslogExportRule) endpoint.\n\nTo remove a syslog export rule, send a DELETE request with the export rule ID to\nthe [`/syslog/export/{id}`](#operation/deleteSyslogExportRule) endpoint.\n\n**Example:** Managing individual syslog export rules for a Rubrik cluster\n\n```bash\ncurl -X GET \"https://$cluster_address/api/v1/syslog/export/{id}\"\ncurl -X PATCH \"https://$cluster_address/api/v1/syslog/export/{id}\"\ncurl -X DELETE \"https://$cluster_address/api/v1/syslog/export/{id}\"\n```\n\nTo test a syslog export rule, send a POST request with the export rule\ninformation to the [`/syslog/export/test`](#operation/testSyslogExportRule)\nendpoint.\n\n**Example:** Testing a syslog export rule for a Rubrik cluster\n\n```bash\ncurl -X POST \"https://$cluster_address/api/v1/syslog/export/test\"\n```\n\n# Legal\n\n## Copyright\n\nRubrik REST API - Copyright Â© 2017 Rubrik Inc.\nAll rights reserved.\n\nThis documentation may be used free of charge. Selling without prior written consent is prohibited.\nObtain permission before redistributing. In all cases, this copyright notice and disclaimer must remain\nintact.\n\n\n## Disclaimer\n\nTHE CONTENTS OF THIS DOCUMENTATION ARE PROVIDED \"AS IS,\" AND COPYRIGHT HOLDERS MAKE NO\nREPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR\nTITLE; THAT THE CONTENTS OF THE DOCUMENTATION ARE SUITABLE FOR ANY PURPOSE; THAT THE\nIMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS,\nTRADEMARKS OR OTHER RIGHTS.\nCOPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL\nDAMAGES ARISING OUT OF ANY USE OF THE DOCUMENTATION OR THE PERFORMANCE OR IMPLEMENTATION OF\nTHE CONTENTS THEREOF.\n\n## Trademarks\n\nRubrik, the Rubrik logo, Rubrik Envision, and Rubrik Edge are trademarks or registered trademarks of Rubrik, Inc. in the U.S. and/or other countries. All other trademarks are the property of their respective owners.\n",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "archive",
			"item": [
				{
					"name": "Get the AWS account ID of an AWS S3 archival location",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/archive/aws/s3/:id/account_id",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"archive",
								"aws",
								"s3",
								":id",
								"account_id"
							],
							"variable": [
								{
									"key": "id",
									"value": "schema type not provided",
									"description": "(Required) ID of an AWS archival location that uses the S3 protocol."
								}
							]
						},
						"description": "Get the AWS account ID of an AWS S3 archival location."
					},
					"response": [
						{
							"name": "Account ID of the AWS account of the archival location",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/archive/aws/s3/:id/account_id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"archive",
										"aws",
										"s3",
										":id",
										"account_id"
									],
									"variable": [
										{
											"key": "id"
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Refresh archive information for a list of data sources",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/archive/location/:location_id/reader/refresh/data_sources",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"archive",
								"location",
								":location_id",
								"reader",
								"refresh",
								"data_sources"
							],
							"variable": [
								{
									"key": "location_id",
									"value": "schema type not provided",
									"description": "(Required) ID assigned to an archival location object."
								}
							]
						},
						"description": "Update the current Rubrik CDM cluster with information about the changes made to a list of data sources in an archival location by the Rubrik CDM cluster that owns the archival location.\n"
					},
					"response": [
						{
							"name": "The request ID for an asynchronous request to refresh archival information.\n",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/archive/location/:location_id/reader/refresh/data_sources",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"archive",
										"location",
										":location_id",
										"reader",
										"refresh",
										"data_sources"
									],
									"variable": [
										{
											"key": "location_id"
										}
									]
								}
							},
							"status": "Accepted",
							"code": 202,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "blackout window",
			"item": [
				{
					"name": "Get current status of global blackout window",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/blackout_window",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"blackout_window"
							]
						},
						"description": "Determine whether global blackout window is currently active."
					},
					"response": [
						{
							"name": "Current status of blackout window.",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/blackout_window",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"blackout_window"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Starts or stops the global blackout window in local Rubrik cluster",
					"request": {
						"method": "PATCH",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/blackout_window",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"blackout_window"
							]
						},
						"description": "Returns whether or not the system is in a blackout window."
					},
					"response": [
						{
							"name": "Returned the updated blackout window status.",
							"originalRequest": {
								"method": "PATCH",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/blackout_window",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"blackout_window"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "certificate",
			"item": [
				{
					"name": "{id}",
					"item": [
						{
							"name": "Get a certificate summary to export",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/certificate/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"certificate",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of certificate to export"
										}
									]
								},
								"description": "Get a certificate summary"
							},
							"response": [
								{
									"name": "Untitled Response",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/certificate/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"certificate",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Update a certificate entry",
							"request": {
								"method": "PATCH",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/certificate/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"certificate",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of certificate object to update"
										}
									]
								},
								"description": "Provide updated information for a certificate object"
							},
							"response": [
								{
									"name": "Updated certificate object",
									"originalRequest": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/certificate/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"certificate",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "Get all certificates",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/certificate?name=&has_key=&description=&expiration=&sort_by=&sort_order=",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"certificate"
							],
							"query": [
								{
									"key": "name",
									"value": "",
									"description": "Search by certificate name."
								},
								{
									"key": "has_key",
									"value": "",
									"description": "Search certificates by whether or not they contain a private key."
								},
								{
									"key": "description",
									"value": "",
									"description": "Search certificates by description."
								},
								{
									"key": "expiration",
									"value": "",
									"description": "Search certificates by expiration."
								},
								{
									"key": "sort_by",
									"value": "",
									"description": "Attribute by which the list of certificates is sorted. (This can only be one of name,description,hasKey,expiration)"
								},
								{
									"key": "sort_order",
									"value": "",
									"description": "Sort order, either ascending or descending. (This can only be one of asc,desc)"
								}
							]
						},
						"description": "Get all certificates"
					},
					"response": [
						{
							"name": "Untitled Response",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/certificate?name=&has_key=&description=&expiration=&sort_by=&sort_order=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"certificate"
									],
									"query": [
										{
											"key": "name",
											"value": ""
										},
										{
											"key": "has_key",
											"value": ""
										},
										{
											"key": "description",
											"value": ""
										},
										{
											"key": "expiration",
											"value": ""
										},
										{
											"key": "sort_by",
											"value": ""
										},
										{
											"key": "sort_order",
											"value": ""
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Import a certificate",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/certificate",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"certificate"
							]
						},
						"description": "Import a certificate"
					},
					"response": [
						{
							"name": "Untitled Response",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/certificate",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"certificate"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "cluster/{id}",
			"item": [
				{
					"name": "security",
					"item": [
						{
							"name": "password requirements",
							"item": [
								{
									"name": "Set password requirements",
									"request": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/cluster/:id/security/password_requirements",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"cluster",
												":id",
												"security",
												"password_requirements"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the Rubrik cluster or *me* for self."
												}
											]
										},
										"description": "Update user password requirements for a cluster."
									},
									"response": [
										{
											"name": "Succesfully patched password requirements",
											"originalRequest": {
												"method": "PATCH",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/cluster/:id/security/password_requirements",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"cluster",
														":id",
														"security",
														"password_requirements"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Get password requirements",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/cluster/:id/security/password_requirements",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"cluster",
												":id",
												"security",
												"password_requirements"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the Rubrik cluster or *me* for self."
												}
											]
										},
										"description": "Query user password requirements for a cluster."
									},
									"response": [
										{
											"name": "Active password requirements.",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/cluster/:id/security/password_requirements",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"cluster",
														":id",
														"security",
														"password_requirements"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								}
							],
							"protocolProfileBehavior": {},
							"_postman_isSubFolder": true
						},
						{
							"name": "Get encryption at rest status",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/cluster/:id/security/encryption",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"cluster",
										":id",
										"security",
										"encryption"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the Rubrik cluster or *me* for self."
										}
									]
								},
								"description": "Get the current encryption at rest status of the cluster."
							},
							"response": [
								{
									"name": "The current encryption at rest status for the cluster.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/cluster/:id/security/encryption",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"cluster",
												":id",
												"security",
												"encryption"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "Get cluster details",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/cluster/:id",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"cluster",
								":id"
							],
							"variable": [
								{
									"key": "id",
									"value": "schema type not provided",
									"description": "(Required) ID of the Rubrik cluster or *me* for self."
								}
							]
						},
						"description": "Retrieve public information about the Rubrik cluster"
					},
					"response": [
						{
							"name": "Information about the cluster",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/cluster/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"cluster",
										":id"
									],
									"variable": [
										{
											"key": "id"
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Change Rubrik cluster properties",
					"request": {
						"method": "PATCH",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/cluster/:id",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"cluster",
								":id"
							],
							"variable": [
								{
									"key": "id",
									"value": "schema type not provided",
									"description": "(Required) ID of a Rubrik cluster object, or use *me* for the Rubrik cluster that is hosting the current API session."
								}
							]
						},
						"description": "Change the properties of a specified Rubrik cluster. Changes to cluster name could take upto 10 minutes to be propagated to all nodes."
					},
					"response": [
						{
							"name": "Updated information for a specified Rubrik cluster",
							"originalRequest": {
								"method": "PATCH",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/cluster/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"cluster",
										":id"
									],
									"variable": [
										{
											"key": "id"
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Get cluster REST API version",
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/cluster/:id/api_version",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"cluster",
								":id",
								"api_version"
							],
							"variable": [
								{
									"key": "id",
									"value": "schema type not provided",
									"description": "(Required) ID of the Rubrik cluster or *me* for self"
								}
							]
						},
						"description": "Retrieves software version of the Rubrik cluster"
					},
					"response": [
						{
							"name": "REST API version running on the cluster",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/cluster/:id/api_version",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"cluster",
										":id",
										"api_version"
									],
									"variable": [
										{
											"key": "id"
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Get the cluster certificate",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/cluster/:id/certificate",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"cluster",
								":id",
								"certificate"
							],
							"variable": [
								{
									"key": "id",
									"value": "schema type not provided",
									"description": "(Required) ID of the Rubrik cluster or *me* for self."
								}
							]
						},
						"description": "Returns the cluster certificate."
					},
					"response": [
						{
							"name": "Returns the cluster certificate.",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/cluster/:id/certificate",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"cluster",
										":id",
										"certificate"
									],
									"variable": [
										{
											"key": "id"
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Get the link for Rubrik SNMP MIB file",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/cluster/:id/snmp_mib_link",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"cluster",
								":id",
								"snmp_mib_link"
							],
							"variable": [
								{
									"key": "id",
									"value": "schema type not provided",
									"description": "(Required) ID of the Rubrik cluster or *me* for self."
								}
							]
						},
						"description": "Retrieve the download link for the Rubrik SNMP MIB file. The retrieval is a synchronous operation."
					},
					"response": [
						{
							"name": "Download link for the Rubrik SNMP MIB file.",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/cluster/:id/snmp_mib_link",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"cluster",
										":id",
										"snmp_mib_link"
									],
									"variable": [
										{
											"key": "id"
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Get cluster software version",
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/cluster/:id/version",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"cluster",
								":id",
								"version"
							],
							"variable": [
								{
									"key": "id",
									"value": "schema type not provided",
									"description": "(Required) ID of the Rubrik cluster or *me* for self"
								}
							]
						},
						"description": "Retrieves software version of the Rubrik cluster"
					},
					"response": [
						{
							"name": "Software version running on the cluster",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/cluster/:id/version",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"cluster",
										":id",
										"version"
									],
									"variable": [
										{
											"key": "id"
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "csr",
			"item": [
				{
					"name": "Get all certificate signing requests",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/csr",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"csr"
							]
						},
						"description": "Returns a list of summaries for every outstanding certificate signing request (CSR)."
					},
					"response": [
						{
							"name": "Untitled Response",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/csr",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"csr"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Generate a new private key and return a certificate signing request",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/csr",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"csr"
							]
						},
						"description": "Generates a new private key and returns a base64 encoded PKCS#10 certificate signing request (CSR)."
					},
					"response": [
						{
							"name": "Certificate signing request.",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/csr",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"csr"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Delete a certificate signing request",
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/csr/:id",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"csr",
								":id"
							],
							"variable": [
								{
									"key": "id",
									"value": "schema type not provided",
									"description": "(Required) Certificate signing request ID."
								}
							]
						},
						"description": "Deletes a certificate signing request corresponding to the provided ID."
					},
					"response": [
						{
							"name": "Returned if delete completes successfully.",
							"originalRequest": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/csr/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"csr",
										":id"
									],
									"variable": [
										{
											"key": "id"
										}
									]
								}
							},
							"status": "No Content",
							"code": 204,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "event",
			"item": [
				{
					"name": "(DO NOT USE! WILL RELEASE IN FUTURE) Get information for all events",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/event?limit=&after_id=&after_date=",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"event"
							],
							"query": [
								{
									"key": "limit",
									"value": "",
									"description": "Maximum number of events retrieved."
								},
								{
									"key": "after_id",
									"value": "",
									"description": "Returns all events with timestamps more recent than the value of after_id. The events are returned as a serialized list of (event_id, time) tuples."
								},
								{
									"key": "after_date",
									"value": "",
									"description": "Filter out event series that have events occurring before the specified date."
								}
							]
						},
						"description": "Returns information for all events. For Polaris/Global Admin/Read Only Admin/Support users only. Accepts filters."
					},
					"response": [
						{
							"name": "Returns information for the events that match the query parameters.",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/event?limit=&after_id=&after_date=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"event"
									],
									"query": [
										{
											"key": "limit",
											"value": ""
										},
										{
											"key": "after_id",
											"value": ""
										},
										{
											"key": "after_date",
											"value": ""
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "(DO NOT USE! WILL RELEASE IN FUTURE) Get latest events and event series info for event series",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/event/latest?limit=&event_series_status=&event_status=&event_type=&event_severity=&object_ids=&object_type=&object_name=&after_id=&before_date=&after_date=&order_by_time=",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"event",
								"latest"
							],
							"query": [
								{
									"key": "limit",
									"value": "",
									"description": "Maximum number of events retrieved."
								},
								{
									"key": "event_series_status",
									"value": "",
									"description": "Filter by the current status of the event series. (This can only be one of Success,Queued,Scheduled,Active,Canceling,Canceled,SuccessfulWithWarnings)"
								},
								{
									"key": "event_status",
									"value": "",
									"description": "Filter by the status of the latest event in the event series. (This can only be one of Failure,Warning,Running,Success,Canceled,Canceling,TaskSuccess)"
								},
								{
									"key": "event_type",
									"value": "",
									"description": "Filter by the type of the latest event in the event series. (This can only be one of Archive,Audit,AuthDomain,AwsEvent,Backup,Classification,CloudNativeSource,CloudNativeVm,Configuration,Connection,Diagnostic,Discovery,Fileset,Hardware,HostEvent,HypervScvmm,HypervServer,Instantiate,Maintenance,NutanixCluster,Recovery,Replication,Storage,StorageArray,StormResource,Support,System,Upgrade,User,VCenter,Vcd,VolumeGroup)"
								},
								{
									"key": "event_severity",
									"value": "",
									"description": "Filter by the severity of the latest event in the event series. (This can only be one of Critical,Warning,informational)"
								},
								{
									"key": "object_ids",
									"value": "",
									"description": "Filter the object IDs in the latest event series by matches to a comma-separated list of object IDs."
								},
								{
									"key": "object_type",
									"value": "",
									"description": "Filter the events in the event series by a specified object type. (This can only be one of VmwareVm,Mssql,LinuxFileset,WindowsFileset,WindowsHost,LinuxHost,StorageArrayVolumeGroup,SupportBundle,VolumeGroup,NutanixVm,Oracle,AwsAccount,Ec2Instance)"
								},
								{
									"key": "object_name",
									"value": "",
									"description": "Filter latest events according to the provided name using prefix search for resources and exact search for usernames."
								},
								{
									"key": "after_id",
									"value": "",
									"description": "Retrieve all events in the series after the event ID that matches after_id. The events are returned as a series of (event_series_id, time) tuples."
								},
								{
									"key": "before_date",
									"value": "",
									"description": "Filter out event series that have events occurring after the specified date."
								},
								{
									"key": "after_date",
									"value": "",
									"description": "Filter out event series that have events occurring before the specified date."
								},
								{
									"key": "order_by_time",
									"value": "",
									"description": "The events in a series are ordered by timestamp. Specify DESC to show the latest entries first. Specify ASC to show the oldest entries first. The default behavior is DESC."
								}
							]
						},
						"description": "Get the latest event, event series status, and the number of warning events for all event series."
					},
					"response": [
						{
							"name": "Returns information for the events that match the query parameters.",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/event/latest?limit=&event_series_status=&event_status=&event_type=&event_severity=&object_ids=&object_type=&object_name=&after_id=&before_date=&after_date=&order_by_time=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"event",
										"latest"
									],
									"query": [
										{
											"key": "limit",
											"value": ""
										},
										{
											"key": "event_series_status",
											"value": ""
										},
										{
											"key": "event_status",
											"value": ""
										},
										{
											"key": "event_type",
											"value": ""
										},
										{
											"key": "event_severity",
											"value": ""
										},
										{
											"key": "object_ids",
											"value": ""
										},
										{
											"key": "object_type",
											"value": ""
										},
										{
											"key": "object_name",
											"value": ""
										},
										{
											"key": "after_id",
											"value": ""
										},
										{
											"key": "before_date",
											"value": ""
										},
										{
											"key": "after_date",
											"value": ""
										},
										{
											"key": "order_by_time",
											"value": ""
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "fileset",
			"item": [
				{
					"name": "snapshot/{id}",
					"item": [
						{
							"name": "Get information for a fileset snapshot",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset/snapshot/:id?verbose=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset",
										"snapshot",
										":id"
									],
									"query": [
										{
											"key": "verbose",
											"value": "",
											"description": "Whether or not to fetch verbose fileset snapshot information. The performance of this endpoint will decrease if set to true."
										}
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of snapshot"
										}
									]
								},
								"description": "Retrieve summary information for a fileset snapshot by specifying the snapshot ID."
							},
							"response": [
								{
									"name": "Detailed information for the specified fileset snapshot.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset/snapshot/:id?verbose=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset",
												"snapshot",
												":id"
											],
											"query": [
												{
													"key": "verbose",
													"value": ""
												}
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Delete a fileset snapshot",
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset/snapshot/:id?location=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset",
										"snapshot",
										":id"
									],
									"query": [
										{
											"key": "location",
											"value": "",
											"description": "(Required) Snapshot location to delete. Use **_local_** to delete all local snapshots and **_all_** to delete the snapshot in all locations. (This can only be one of all,local)"
										}
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of snapshot"
										}
									]
								},
								"description": "Delete a fileset snapshot. A snapshot is deleted only if it is an on-demand snapshot, a snapshot of an unprotected fileset or a local snapshot that was downloaded from an archive location."
							},
							"response": [
								{
									"name": "Snapshot sucessfully deleted",
									"originalRequest": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset/snapshot/:id?location=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset",
												"snapshot",
												":id"
											],
											"query": [
												{
													"key": "location",
													"value": ""
												}
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "No Content",
									"code": 204,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Lists all files and directories in a given path",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset/snapshot/:id/browse?path=&offset=&limit=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset",
										"snapshot",
										":id",
										"browse"
									],
									"query": [
										{
											"key": "path",
											"value": "",
											"description": "(Required) The absolute path of the starting point for the directory listing."
										},
										{
											"key": "offset",
											"value": "",
											"description": "Starting position in the list of path entries contained in the query results, sorted by lexicographical order. The response includes the specified numbered entry and all higher numbered entries."
										},
										{
											"key": "limit",
											"value": "",
											"description": "Maximum number of entries in the response."
										}
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of snapshot"
										}
									]
								},
								"description": "Lists all files and directories in a given path"
							},
							"response": [
								{
									"name": "List of files and directories at the specified path.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset/snapshot/:id/browse?path=&offset=&limit=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset",
												"snapshot",
												":id",
												"browse"
											],
											"query": [
												{
													"key": "path",
													"value": ""
												},
												{
													"key": "offset",
													"value": ""
												},
												{
													"key": "limit",
													"value": ""
												}
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Create a download fileset snapshot from archival request",
							"request": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset/snapshot/:id/download",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset",
										"snapshot",
										":id",
										"download"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of snapshot"
										}
									]
								},
								"description": "Create a download fileset snapshot from archival request."
							},
							"response": [
								{
									"name": "Status for the download request.",
									"originalRequest": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset/snapshot/:id/download",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset",
												"snapshot",
												":id",
												"download"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "Accepted",
									"code": 202,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Create a file download job from a fileset backup",
							"request": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset/snapshot/:id/download_file",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset",
										"snapshot",
										":id",
										"download_file"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of snapshot"
										}
									]
								},
								"description": "Initiate a job to download a file from a backup of a fileset. Returns a job instance ID.\nAn email notification will be sent out when the download is ready. When the download is ready, the file can be downloaded from the corresponding event which includes the job instance ID as the value of **jobInstanceId**"
							},
							"response": [
								{
									"name": "Status for the download request.",
									"originalRequest": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset/snapshot/:id/download_file",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset",
												"snapshot",
												":id",
												"download_file"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "Accepted",
									"code": 202,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Create export job",
							"request": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset/snapshot/:id/export_file",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset",
										"snapshot",
										":id",
										"export_file"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of snapshot"
										}
									]
								},
								"description": "Initiate a job to copy a file or folder from a fileset backup to a destination host other than the source host. Returns the job instance ID."
							},
							"response": [
								{
									"name": "Status for the export request.",
									"originalRequest": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset/snapshot/:id/export_file",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset",
												"snapshot",
												":id",
												"export_file"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "Accepted",
									"code": 202,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Create restore job",
							"request": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset/snapshot/:id/restore_file",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset",
										"snapshot",
										":id",
										"restore_file"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of snapshot"
										}
									]
								},
								"description": "Initiate a job to copy a file or folder from a fileset backup to the source host. Returns the job instance ID."
							},
							"response": [
								{
									"name": "Status for the restore request.",
									"originalRequest": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset/snapshot/:id/restore_file",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset",
												"snapshot",
												":id",
												"restore_file"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "Accepted",
									"code": 202,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "{id}",
					"item": [
						{
							"name": "snapshot",
							"item": [
								{
									"name": "Initiate an on-demand backup for a fileset",
									"request": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset/:id/snapshot",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset",
												":id",
												"snapshot"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the Fileset"
												}
											]
										},
										"description": "Create an on-demand backup request for the given fileset."
									},
									"response": [
										{
											"name": "Status for the backup request.",
											"originalRequest": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/fileset/:id/snapshot",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"fileset",
														":id",
														"snapshot"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "Accepted",
											"code": 202,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Delete all snapshots of a fileset",
									"request": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset/:id/snapshot",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset",
												":id",
												"snapshot"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the fileset."
												}
											]
										},
										"description": "Delete all snapshots that were created based on a fileset by providing the fileset ID.\nRequires an unprotected fileset. Remove the fileset from all SLA Domains."
									},
									"response": [
										{
											"name": "Successfully removed all snapshots for the fileset.",
											"originalRequest": {
												"method": "DELETE",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/fileset/:id/snapshot",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"fileset",
														":id",
														"snapshot"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "No Content",
											"code": 204,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								}
							],
							"protocolProfileBehavior": {},
							"_postman_isSubFolder": true
						},
						{
							"name": "Get information for a single fileset",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) Specify the fileset ID."
										}
									]
								},
								"description": "Retrieve summary information for a fileset by specifying the fileset ID."
							},
							"response": [
								{
									"name": "Detailed information for the specified fileset.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Update a Fileset",
							"request": {
								"method": "PATCH",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the Fileset to update."
										}
									]
								},
								"description": "Update a Fileset with the specified properties."
							},
							"response": [
								{
									"name": "Returned if the update was successful",
									"originalRequest": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Delete a fileset",
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset/:id?preserve_snapshots=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset",
										":id"
									],
									"query": [
										{
											"key": "preserve_snapshots",
											"value": "",
											"description": "Flag to indicate whether to preserve snapshots of the fileset or to delete them. Default behavior is to preserve them."
										}
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) Provide a fileset ID to delete."
										}
									]
								},
								"description": "Delete a fileset by specifying the fileset ID."
							},
							"response": [
								{
									"name": "Fileset deletion failed",
									"originalRequest": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset/:id?preserve_snapshots=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset",
												":id"
											],
											"query": [
												{
													"key": "preserve_snapshots",
													"value": ""
												}
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "Not Found",
									"code": 404,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								},
								{
									"name": "Deleted the specified fileset.",
									"originalRequest": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset/:id?preserve_snapshots=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset",
												":id"
											],
											"query": [
												{
													"key": "preserve_snapshots",
													"value": ""
												}
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "No Content",
									"code": 204,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Get missed snapshots for a fileset",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset/:id/missed_snapshot",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset",
										":id",
										"missed_snapshot"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the fileset."
										}
									]
								},
								"description": "Retrieve summary information about all missed snapshots for a fileset."
							},
							"response": [
								{
									"name": "Summary information about missed snapshots for the specified fileset.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset/:id/missed_snapshot",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset",
												":id",
												"missed_snapshot"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Search for a file within the fileset",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset/:id/search?path=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset",
										":id",
										"search"
									],
									"query": [
										{
											"key": "path",
											"value": "",
											"description": "(Required) The path query. Either path prefix or filename prefix."
										}
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) Fileset ID to search"
										}
									]
								},
								"description": "Search for a file within the fileset. Search via full path prefix or filename prefix."
							},
							"response": [
								{
									"name": "Search results",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset/:id/search?path=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset",
												":id",
												"search"
											],
											"query": [
												{
													"key": "path",
													"value": ""
												}
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "Get summary information for all filesets",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/fileset?primary_cluster_id=&host_id=&share_id=&is_relic=&effective_sla_domain_id=&template_id=&limit=&offset=&name=&host_name=&sort_by=&sort_order=",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"fileset"
							],
							"query": [
								{
									"key": "primary_cluster_id",
									"value": "",
									"description": "Filter the summary information based on the primary_cluster_id of the primary Rubrik cluster.\nUse **_local_** as the primary_cluster_id of the Rubrik cluster that is hosting the current REST API session."
								},
								{
									"key": "host_id",
									"value": "",
									"description": "Filter the summary information based on the ID of the host referenced by the fileset."
								},
								{
									"key": "share_id",
									"value": "",
									"description": "Filter the summary information based on the ID of the host share referenced by the fileset.\nUse **_NONE_** to only return information for filesets that were not created based on a host share.\nUse **_ANY_** to only return information for filesets that were created based on a host share."
								},
								{
									"key": "is_relic",
									"value": "",
									"description": "Filter the summary information based on the relic status of the fileset. Returns both relic and non relic if the parameter is not set."
								},
								{
									"key": "effective_sla_domain_id",
									"value": "",
									"description": "Filter the summary information based on the ID of the effective SLA Domain inherited by a fileset.\nUse **_UNPROTECTED_** to only return information for filesets that do not have an effective SLA Domain.\nUse **_PROTECTED_** to only return information for filesets that do have an effective SLA Domain."
								},
								{
									"key": "template_id",
									"value": "",
									"description": "Filter the summary information based on the ID of a fileset template.\n\nUse **_NONE_** to only return information for filesets that were not created from a fileset template.\n\nUse **_ANY_** to only return information for filesets that were created from a fileset template."
								},
								{
									"key": "limit",
									"value": "",
									"description": "Limit the summary information to a specified maximum number of filesets.\n\nOptionally, use with **_offset_** to start the count at a specified point.\n\nOptionally, use with **_sort_by_** to perform sort on given attributes. Include **_sort_order_** to determine the ascending or descending direction of sort."
								},
								{
									"key": "offset",
									"value": "",
									"description": "Starting position in the list of fileset entries contained in the response. The summary information includes the specified numbered entry and all higher numbered entries. Use with **_limit_** to retrieve the summary information as smaller groups of entries, e.g. for paging of results."
								},
								{
									"key": "name",
									"value": "",
									"description": "Retrieve filesets with a name matching the provided name. The search is performed as a case-insensitive infix search."
								},
								{
									"key": "host_name",
									"value": "",
									"description": "Retrieve filesets with a host name matching the provided name. The search is performed as a case-insensitive infix search."
								},
								{
									"key": "sort_by",
									"value": "",
									"description": "Specifies a comma-separated list of fileset attributes to use in sorting the fileset summary information. Performs an ASCII sort of the summary information using each specified attribute, in the order specified.\n\nValid attributes are: **_name_**, **_hostName_**, **_templateType_**, **_slaName_**, **_includes_**, **_excludes_**, and **_exceptions_**. Requires **_sort_order_**. (This can only be one of name,hostName,templateId,effectiveSlaDomainName,includes,excludes,exceptions)"
								},
								{
									"key": "sort_order",
									"value": "",
									"description": "Sort order, either ascending or descending (This can only be one of asc,desc)"
								}
							]
						},
						"description": "Retrieve summary information for each fileset. Optionally, filter the retrieved information."
					},
					"response": [
						{
							"name": "Summary information for filesets.",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset?primary_cluster_id=&host_id=&share_id=&is_relic=&effective_sla_domain_id=&template_id=&limit=&offset=&name=&host_name=&sort_by=&sort_order=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset"
									],
									"query": [
										{
											"key": "primary_cluster_id",
											"value": ""
										},
										{
											"key": "host_id",
											"value": ""
										},
										{
											"key": "share_id",
											"value": ""
										},
										{
											"key": "is_relic",
											"value": ""
										},
										{
											"key": "effective_sla_domain_id",
											"value": ""
										},
										{
											"key": "template_id",
											"value": ""
										},
										{
											"key": "limit",
											"value": ""
										},
										{
											"key": "offset",
											"value": ""
										},
										{
											"key": "name",
											"value": ""
										},
										{
											"key": "host_name",
											"value": ""
										},
										{
											"key": "sort_by",
											"value": ""
										},
										{
											"key": "sort_order",
											"value": ""
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Create one fileset for a host",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/fileset",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"fileset"
							]
						},
						"description": "Create a fileset for a network host. A fileset is a fileset template applied to a host"
					},
					"response": [
						{
							"name": "Details of the new fileset.",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset"
									]
								}
							},
							"status": "Created",
							"code": 201,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Get details about an async request",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/fileset/request/:id",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"fileset",
								"request",
								":id"
							],
							"variable": [
								{
									"key": "id",
									"value": "schema type not provided",
									"description": "(Required) ID of the request"
								}
							]
						},
						"description": "Get details about a fileset related async request."
					},
					"response": [
						{
							"name": "Status for the async request.",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset/request/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset",
										"request",
										":id"
									],
									"variable": [
										{
											"key": "id"
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "fileset template",
			"item": [
				{
					"name": "{id}",
					"item": [
						{
							"name": "Get information for a fileset template",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset_template/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset_template",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) The ID of the fileset template."
										}
									]
								},
								"description": "Retrieve summary information for a specified fileset template."
							},
							"response": [
								{
									"name": "Summary information for the specified fileset template.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset_template/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset_template",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Modify a fileset template",
							"request": {
								"method": "PATCH",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset_template/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset_template",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the fileset template to update."
										}
									]
								},
								"description": "Modify the values of specified fileset template."
							},
							"response": [
								{
									"name": "Detailed information for modified fileset template.",
									"originalRequest": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset_template/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset_template",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Delete a fileset template",
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset_template/:id?preserve_snapshots=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset_template",
										":id"
									],
									"query": [
										{
											"key": "preserve_snapshots",
											"value": "",
											"description": "Flag to indicate whether to convert snapshots of all filesets of this template to relics or to delete them.  Default is true."
										}
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the fileset template to remove."
										}
									]
								},
								"description": "Deletes the specfied fileset template. All associated filesets are deleted."
							},
							"response": [
								{
									"name": "Successfully removed the specified fileset template.",
									"originalRequest": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/fileset_template/:id?preserve_snapshots=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"fileset_template",
												":id"
											],
											"query": [
												{
													"key": "preserve_snapshots",
													"value": ""
												}
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "No Content",
									"code": 204,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "Get summary information for all fileset templates",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/fileset_template?primary_cluster_id=&operating_system_type=&share_type=&name=&sort_by=&sort_order=",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"fileset_template"
							],
							"query": [
								{
									"key": "primary_cluster_id",
									"value": "",
									"description": "Filter the summary information based on the primary_cluster_id of the primary Rubrik cluster.\nUse **_local_** as the primary_cluster_id of the Rubrik cluster that is hosting the current REST API session."
								},
								{
									"key": "operating_system_type",
									"value": "",
									"description": "Filter the summary information based on the operating system type of the fileset. Accepted values: 'Windows', 'UnixLike', 'ANY', 'NONE'.\nUse **_NONE_** to only return information for fileset templates that do not have operating system type set.\nUse **_ANY_** to only return information for fileset templates that have operating system type set. (This can only be one of UnixLike,Windows,ANY,NONE)"
								},
								{
									"key": "share_type",
									"value": "",
									"description": "Filter the summary information based on the share type where the fileset is assigned to. Accepted values: 'NFS', 'SMB', 'ANY', 'NONE'.\nUse **_NONE_** to only return information for fileset templates that do not have share type set.\nUse **_ANY_** to only return information for fileset templates that have share type set. (This can only be one of NFS,SMB,ANY,NONE)"
								},
								{
									"key": "name",
									"value": "",
									"description": "Retrieve fileset templates with a name matching the provided name. The search is performed as a case-insensitive infix search."
								},
								{
									"key": "sort_by",
									"value": "",
									"description": "Specifies a comma-separated list of fileset attributes to use in sorting the fileset summary information. Performs an ASCII sort of the summary information using each specified attribute, in the order specified.\n\nValid attributes are: **_name_**, **_includes_**, **_excludes_**, **_exceptions_**, **_hostCount_**, **_shareType_**. Default sort_order is ascending (This can only be one of name,hostCount,includes,excludes,exceptions,shareType)"
								},
								{
									"key": "sort_order",
									"value": "",
									"description": "Sort order, either ascending or descending (This can only be one of asc,desc)"
								}
							]
						},
						"description": "Retrieve summary information for all fileset templates, including: ID and name of the fileset template, fileset template creation timestamp, array of the included filepaths, array of the excluded filepaths."
					},
					"response": [
						{
							"name": "Summary information for all fileset templates.",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset_template?primary_cluster_id=&operating_system_type=&share_type=&name=&sort_by=&sort_order=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset_template"
									],
									"query": [
										{
											"key": "primary_cluster_id",
											"value": ""
										},
										{
											"key": "operating_system_type",
											"value": ""
										},
										{
											"key": "share_type",
											"value": ""
										},
										{
											"key": "name",
											"value": ""
										},
										{
											"key": "sort_by",
											"value": ""
										},
										{
											"key": "sort_order",
											"value": ""
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Create a fileset template",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/fileset_template",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"fileset_template"
							]
						},
						"description": "Create a fileset template. The template is applied to the host.  Each template is a set of paths on the host.\n\nA template uses full paths and wildcards to define the objects to include, exclude, and exempt from exclusion.\n\nThe **_exceptions_** value specifies paths that should not be excluded from the fileset by the **_exclude_** value.\n\nSpecify an array of full path descriptions for each property **_include_**, **_exclude_**, and **_exceptions_**.\n\nAcceptable wildcard characters are\n+ **_\\*_** Single asterisk matches zero or more characters up to a path deliminator\n+ **_\\*\\*_** Double asterisk matches zero or more characters\n\nThe following rules apply to path descriptions\n+ Accepts UTF-8 characters\n+ Case sensitive\n+ Forward slash character **_/_** is the path deliminator\n+ Symbolic links must point to a subset of a non symbolic link path\n+ Paths that do not start with **_/_** are modified to start with **_\\*\\*/_**\n+ Paths that do not end with **_\\*_** are modified to end with **_/\\*\\*_**"
					},
					"response": [
						{
							"name": "Summary information for the created fileset template.",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/fileset_template",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"fileset_template"
									]
								}
							},
							"status": "Created",
							"code": 201,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "host",
			"item": [
				{
					"name": "{id}",
					"item": [
						{
							"name": "Get summary information for a host",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/host/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"host",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the registered host."
										}
									]
								},
								"description": "Retrieve summary information for a registered host."
							},
							"response": [
								{
									"name": "Summary information for the specified host.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/host/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"host",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Modify information for a registered host",
							"request": {
								"method": "PATCH",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/host/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"host",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the registered host"
										}
									]
								},
								"description": "Change the FQDN and IPv4 address that is assigned to a host object. Enable or disable pre-transfer data compression. Enable or disable change block tracking (CBT) for backups of SQL Server databases on Windows hosts. Enable or disable volume filter driver (VFD) for volume backups on Windows hosts. Set an Oracle user with sysdba privileges to permit Oracle discovery queries."
							},
							"response": [
								{
									"name": "Summary information for the specified host.",
									"originalRequest": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/host/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"host",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Delete a registered host",
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/host/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"host",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the host to delete"
										}
									]
								},
								"description": "Delete host by specifying the host ID."
							},
							"response": [
								{
									"name": "Deleted specified host.",
									"originalRequest": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/host/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"host",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "No Content",
									"code": 204,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Refresh a host",
							"request": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/host/:id/refresh",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"host",
										":id",
										"refresh"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID assigned to a host object."
										}
									]
								},
								"description": "Refresh the properties of a host object when changes on the host are not seen in the Rubrik web UI."
							},
							"response": [
								{
									"name": "Refreshed the properties shown for the specified host",
									"originalRequest": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/host/:id/refresh",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"host",
												":id",
												"refresh"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Search for a file within the host",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/host/:id/search?path=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"host",
										":id",
										"search"
									],
									"query": [
										{
											"key": "path",
											"value": "",
											"description": "(Required) The path query. Either path prefix or filename prefix."
										}
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the host to search"
										}
									]
								},
								"description": "Search for a file within the host. Search via full path prefix or filename prefix."
							},
							"response": [
								{
									"name": "Search results",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/host/:id/search?path=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"host",
												":id",
												"search"
											],
											"query": [
												{
													"key": "path",
													"value": ""
												}
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "Get summary information for hosts",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/host?operating_system_type=&operating_system=&primary_cluster_id=&name=&hostname=&sort_by=&sort_order=&snappable_status=",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"host"
							],
							"query": [
								{
									"key": "operating_system_type",
									"value": "",
									"description": "Filter the summary information based on the operating system type. Accepted values are 'Windows', 'UnixLike', 'ANY', 'NONE'.\nUse **_NONE_** to only return information for hosts templates that do not have operating system type set.\nUse **_ANY_** to only return information for hosts that have operating system type set. (This can only be one of ANY,NONE,UnixLike,Windows)"
								},
								{
									"key": "operating_system",
									"value": "",
									"description": "Filter the summary information based on the operating system.\nUse **_AIX_**, **_Linux_** or **_Solaris_** to restrict the returned information to hosts with operating systems within the specified operating system family.\nUse a specific operating system release version to restrict the returned information to hosts with operating systems that match the specified version."
								},
								{
									"key": "primary_cluster_id",
									"value": "",
									"description": "Filters the summary information based on the Rubrik cluster specified by the value of primary_cluster_id. Use 'local' for the Rubrik cluster that is hosting the current REST API session."
								},
								{
									"key": "name",
									"value": "",
									"description": "Retrieve hosts with a host name matching the provided name. The search type is infix"
								},
								{
									"key": "hostname",
									"value": "",
									"description": "(Deprecated) Retrieve hosts with a host name matching the provided name. The search type is infix"
								},
								{
									"key": "sort_by",
									"value": "",
									"description": "Specifies the host attribute to use in sorting the host summary information. Performs an ASCII sort of the summary information using the specified attribute, in the order specified.\nValid attributes are 'hostname' (This can only be one of hostname)"
								},
								{
									"key": "sort_order",
									"value": "",
									"description": "Sort order, either ascending or descending (This can only be one of asc,desc)"
								},
								{
									"key": "snappable_status",
									"value": "",
									"description": "Determines whether to fetch hosts with additional privilege checks. (This can only be one of Protectable)"
								}
							]
						},
						"description": "Retrieve summary information for all hosts that are registered with a Rubrik cluster."
					},
					"response": [
						{
							"name": "Summary information for registered hosts.",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/host?operating_system_type=&operating_system=&primary_cluster_id=&name=&hostname=&sort_by=&sort_order=&snappable_status=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"host"
									],
									"query": [
										{
											"key": "operating_system_type",
											"value": ""
										},
										{
											"key": "operating_system",
											"value": ""
										},
										{
											"key": "primary_cluster_id",
											"value": ""
										},
										{
											"key": "name",
											"value": ""
										},
										{
											"key": "hostname",
											"value": ""
										},
										{
											"key": "sort_by",
											"value": ""
										},
										{
											"key": "sort_order",
											"value": ""
										},
										{
											"key": "snappable_status",
											"value": ""
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Register a host",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/host",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"host"
							]
						},
						"description": "Register a host."
					},
					"response": [
						{
							"name": "Summary information from registration of the host.",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/host",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"host"
									]
								}
							},
							"status": "Created",
							"code": 201,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Update certificate",
					"request": {
						"method": "PUT",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/host/certificate/:id",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"host",
								"certificate",
								":id"
							],
							"variable": [
								{
									"key": "id",
									"value": "schema type not provided",
									"description": "(Required) ID of the host."
								}
							]
						},
						"description": "Provide an updated certificate for a specified host."
					},
					"response": [
						{
							"name": "Returns a detailed view of the update host.",
							"originalRequest": {
								"method": "PUT",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/host/certificate/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"host",
										"certificate",
										":id"
									],
									"variable": [
										{
											"key": "id"
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "idp auth domain",
			"item": [
				{
					"name": "{id}",
					"item": [
						{
							"name": "Get an IdP authentication domain for the given id",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/idp_auth_domain/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"idp_auth_domain",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the IdP Authentication Domain to be retrieved"
										}
									]
								},
								"description": "Get an IdP authentication domain for the given id"
							},
							"response": [
								{
									"name": "Returns a summary of the requested IdP authentication domain.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/idp_auth_domain/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"idp_auth_domain",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Update an existing IdP authentication domain",
							"request": {
								"method": "PATCH",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/idp_auth_domain/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"idp_auth_domain",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the IdP authentication domain to be updated"
										}
									]
								},
								"description": "Update an existing IdP authentication domain."
							},
							"response": [
								{
									"name": "Returns a summary of the newly updated IdP authentication domain.",
									"originalRequest": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/idp_auth_domain/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"idp_auth_domain",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Delete an IdP authentication domain for the given ID",
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/idp_auth_domain/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"idp_auth_domain",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the IdP authentication domain to be deleted"
										}
									]
								},
								"description": "Delete an IdP authentication domain for the given ID."
							},
							"response": [
								{
									"name": "Delete Successful",
									"originalRequest": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/idp_auth_domain/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"idp_auth_domain",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "No Content",
									"code": 204,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "Get a list of IdP authentication domains",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/idp_auth_domain",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"idp_auth_domain"
							]
						},
						"description": "Get a list of IdP authentication domains."
					},
					"response": [
						{
							"name": "Returns the list of IdP authentication domains",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/idp_auth_domain",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"idp_auth_domain"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Add a new IdP authentication domain",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/idp_auth_domain",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"idp_auth_domain"
							]
						},
						"description": "Add a new IdP authentication domain."
					},
					"response": [
						{
							"name": "Returns a summary of the newly created IdP authentication domain.",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/idp_auth_domain",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"idp_auth_domain"
									]
								}
							},
							"status": "Created",
							"code": 201,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "ldap service",
			"item": [
				{
					"name": "{id}",
					"item": [
						{
							"name": "Get a LDAP service for the given ID",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/ldap_service/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"ldap_service",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the authentication domain to be retrieved."
										}
									]
								},
								"description": "Get a LDAP service for the given ID."
							},
							"response": [
								{
									"name": "Returns a summary of the requested authentication domain.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/ldap_service/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"ldap_service",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Update an existing authentication domain",
							"request": {
								"method": "PATCH",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/ldap_service/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"ldap_service",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the authentication domain to be updated."
										}
									]
								},
								"description": "Modify the values of a specified authentication domain object."
							},
							"response": [
								{
									"name": "Returns a summary of the newly updated authentication domain.",
									"originalRequest": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/ldap_service/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"ldap_service",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Replace the values of an authentication domain",
							"request": {
								"method": "PUT",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/ldap_service/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"ldap_service",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the authentication domain to be updated."
										}
									]
								},
								"description": "Replace the values of a specified authentication domain object."
							},
							"response": [
								{
									"name": "Returns a summary of the newly updated authentication domain.",
									"originalRequest": {
										"method": "PUT",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/ldap_service/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"ldap_service",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Delete an authentication domain for the given ID",
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/ldap_service/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"ldap_service",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the authentication domain to be deleted."
										}
									]
								},
								"description": "Delete an authentication domain for the given ID."
							},
							"response": [
								{
									"name": "Delete successful.",
									"originalRequest": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/ldap_service/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"ldap_service",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "No Content",
									"code": 204,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "Get a list of LDAP services",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/ldap_service",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"ldap_service"
							]
						},
						"description": "Get a list of LDAP services."
					},
					"response": [
						{
							"name": "Returns the list of authentication domains.",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/ldap_service",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"ldap_service"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Add a new authentication domain",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/ldap_service",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"ldap_service"
							]
						},
						"description": "Add a new authentication domain. "
					},
					"response": [
						{
							"name": "Returns a summary of the newly created authentication. domain.",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/ldap_service",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"ldap_service"
									]
								}
							},
							"status": "Created",
							"code": 201,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "mssql",
			"item": [
				{
					"name": "db",
					"item": [
						{
							"name": "log shipping",
							"item": [
								{
									"name": "{id}",
									"item": [
										{
											"name": "Get a log shipping configuration",
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/log_shipping/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														"log_shipping",
														":id"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of a log shipping configuration."
														}
													]
												},
												"description": "Retrieves a particular log shipping configuration with all the details of the configuration."
											},
											"response": [
												{
													"name": "Returned when the request for the log shipping configuration details is successful.",
													"originalRequest": {
														"method": "GET",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/mssql/db/log_shipping/:id",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"mssql",
																"db",
																"log_shipping",
																":id"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "OK",
													"code": 200,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "Update a specified log shipping configuration",
											"request": {
												"method": "PATCH",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/log_shipping/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														"log_shipping",
														":id"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of a log shipping configuration object."
														}
													]
												},
												"description": "Updates a specified log shipping configuration."
											},
											"response": [
												{
													"name": "Returns the request ID of an asynchronous job that updates a log shipping configuration object.",
													"originalRequest": {
														"method": "PATCH",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/mssql/db/log_shipping/:id",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"mssql",
																"db",
																"log_shipping",
																":id"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "Accepted",
													"code": 202,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "Delete a specified log shipping configuration",
											"request": {
												"method": "DELETE",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/log_shipping/:id?delete_secondary_database=",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														"log_shipping",
														":id"
													],
													"query": [
														{
															"key": "delete_secondary_database",
															"value": ""
														}
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of a log shipping configuration object."
														}
													]
												},
												"description": "Deletes the specified log shipping configuration"
											},
											"response": [
												{
													"name": "Returns with the request ID of an async job to delete a log shipping configuration object and, if specified, a secondary database.",
													"originalRequest": {
														"method": "DELETE",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/mssql/db/log_shipping/:id?delete_secondary_database=",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"mssql",
																"db",
																"log_shipping",
																":id"
															],
															"query": [
																{
																	"key": "delete_secondary_database",
																	"value": ""
																}
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "Accepted",
													"code": 202,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "Reseed a secondary database",
											"request": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/log_shipping/:id/reseed",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														"log_shipping",
														":id",
														"reseed"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of the log shipping configuration object for the specified secondary database."
														}
													]
												},
												"description": "Starts an asynchronous job to reseed a secondary database. Reseeding restores the data in the secondary database based on a log shipping configuration."
											},
											"response": [
												{
													"name": "Returns with a request ID for the async job to reseed a secondary database.",
													"originalRequest": {
														"method": "POST",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/mssql/db/log_shipping/:id/reseed",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"mssql",
																"db",
																"log_shipping",
																":id",
																"reseed"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "Accepted",
													"code": 202,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										}
									],
									"protocolProfileBehavior": {},
									"_postman_isSubFolder": true
								},
								{
									"name": "Get log shipping configurations",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/db/log_shipping?primary_database_id=&primary_database_name=&secondary_database_name=&location=&status=&limit=&offset=&sort_by=&sort_order=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"db",
												"log_shipping"
											],
											"query": [
												{
													"key": "primary_database_id",
													"value": "",
													"description": "ID of a primary database object."
												},
												{
													"key": "primary_database_name",
													"value": "",
													"description": "Filter log shipping configuration objects by performing an infix search using the name of a primary database."
												},
												{
													"key": "secondary_database_name",
													"value": "",
													"description": "Filter log shipping configuration objects by performing an infix search using the name of a secondary database."
												},
												{
													"key": "location",
													"value": "",
													"description": "Filter log shipping configuration objects by performing an infix search using the location string value (host/instance) for a secondary database."
												},
												{
													"key": "status",
													"value": "",
													"description": "Filter log shipping configuration objects based on the status value for the secondary database. (This can only be one of OK,Broken,Initializing,Stale)"
												},
												{
													"key": "limit",
													"value": "",
													"description": "Limit the summary information to a specified maximum number of results."
												},
												{
													"key": "offset",
													"value": "",
													"description": "Starting position in the list of results contained in the response. The summary information includes the specified numbered result and all higher numbered results."
												},
												{
													"key": "sort_by",
													"value": "",
													"description": "Specifies an attribute used to ASCII-sort the results. Sorting by the last_applied attribute represents the timestamp as an ISO 8601-encoded string. (This can only be one of secondaryDatabaseName,primaryDatabaseName,lastAppliedPoint,location)"
												},
												{
													"key": "sort_order",
													"value": "",
													"description": "Sort order, either ascending or descending. (This can only be one of asc,desc)"
												}
											]
										},
										"description": "Retrieves all log shipping configuration objects. Results can be filtered and sorted."
									},
									"response": [
										{
											"name": "Summary list of descendant objects",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/log_shipping?primary_database_id=&primary_database_name=&secondary_database_name=&location=&status=&limit=&offset=&sort_by=&sort_order=",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														"log_shipping"
													],
													"query": [
														{
															"key": "primary_database_id",
															"value": ""
														},
														{
															"key": "primary_database_name",
															"value": ""
														},
														{
															"key": "secondary_database_name",
															"value": ""
														},
														{
															"key": "location",
															"value": ""
														},
														{
															"key": "status",
															"value": ""
														},
														{
															"key": "limit",
															"value": ""
														},
														{
															"key": "offset",
															"value": ""
														},
														{
															"key": "sort_by",
															"value": ""
														},
														{
															"key": "sort_order",
															"value": ""
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								}
							],
							"protocolProfileBehavior": {},
							"_postman_isSubFolder": true
						},
						{
							"name": "mount",
							"item": [
								{
									"name": "{id}",
									"item": [
										{
											"name": "Get detailed information for a Live Mount of a SQL Server database",
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/mount/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														"mount",
														":id"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of the Live Mount to fetch."
														}
													]
												},
												"description": "Returns detailed information for the specified Live Mount of a SQL Server database."
											},
											"response": [
												{
													"name": "Returns detailed information for a specified Live Mount of a SQL Server database.",
													"originalRequest": {
														"method": "GET",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/mssql/db/mount/:id",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"mssql",
																"db",
																"mount",
																":id"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "OK",
													"code": 200,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "Delete a Live Mount of a SQL Server database",
											"request": {
												"method": "DELETE",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/mount/:id?force=",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														"mount",
														":id"
													],
													"query": [
														{
															"key": "force",
															"value": "",
															"description": "Remove all data within the Rubrik cluster related to the Live Mount, even if the SQL Server database cannot be contacted. Default value is false."
														}
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of the Live Mount to delete."
														}
													]
												},
												"description": "Create an async request to delete a Live Mount of a SQL Server database. Poll the task status by using /mssql/request/{id}."
											},
											"response": [
												{
													"name": "Returns the task object for the async request to delete the Live Mount of a SQL Server database.",
													"originalRequest": {
														"method": "DELETE",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/mssql/db/mount/:id?force=",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"mssql",
																"db",
																"mount",
																":id"
															],
															"query": [
																{
																	"key": "force",
																	"value": ""
																}
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "Accepted",
													"code": 202,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										}
									],
									"protocolProfileBehavior": {},
									"_postman_isSubFolder": true
								},
								{
									"name": "Get summary information for all Live Mounts of SQL Server databases",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/db/mount?source_database_id=&source_database_name=&target_instance_id=&mounted_database_name=&sort_by=&sort_order=&offset=&limit=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"db",
												"mount"
											],
											"query": [
												{
													"key": "source_database_id",
													"value": "",
													"description": "Filters by the ID of the source SQL Server database."
												},
												{
													"key": "source_database_name",
													"value": "",
													"description": "Filters by the name of the source SQL Server database using infix search."
												},
												{
													"key": "target_instance_id",
													"value": "",
													"description": "Filters by the ID of the target SQL Server instance."
												},
												{
													"key": "mounted_database_name",
													"value": "",
													"description": "Filters by the name of the mounted SQL Server database using infix search."
												},
												{
													"key": "sort_by",
													"value": "",
													"description": "Specifies the SQL Server Live Mount attribute to use in sorting the summary information. Performs an ASCII sort using the specified attribute, in the order specified by sort_order. (This can only be one of sourceDatabaseName,sourceRecoveryPoint,mountedDatabaseName,creationDate)"
												},
												{
													"key": "sort_order",
													"value": "",
													"description": "Specifies the sort order, either ascending or descending. Default order is ascending. (This can only be one of asc,desc)"
												},
												{
													"key": "offset",
													"value": "",
													"description": "Returns the portion of the ordered list that starts after the element specified by the offset number."
												},
												{
													"key": "limit",
													"value": "",
													"description": "Sets the maximum number of a elements to include in the data array of the response."
												}
											]
										},
										"description": "Returns a list with summary information for all Live Mounted SQL Server databases."
									},
									"response": [
										{
											"name": "Returns summary information for all Live Mounts.",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/mount?source_database_id=&source_database_name=&target_instance_id=&mounted_database_name=&sort_by=&sort_order=&offset=&limit=",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														"mount"
													],
													"query": [
														{
															"key": "source_database_id",
															"value": ""
														},
														{
															"key": "source_database_name",
															"value": ""
														},
														{
															"key": "target_instance_id",
															"value": ""
														},
														{
															"key": "mounted_database_name",
															"value": ""
														},
														{
															"key": "sort_by",
															"value": ""
														},
														{
															"key": "sort_order",
															"value": ""
														},
														{
															"key": "offset",
															"value": ""
														},
														{
															"key": "limit",
															"value": ""
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								}
							],
							"protocolProfileBehavior": {},
							"_postman_isSubFolder": true
						},
						{
							"name": "{id}",
							"item": [
								{
									"name": "snapshot",
									"item": [
										{
											"name": "Get summary information for snapshots of a Microsoft SQL database",
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/:id/snapshot?after_time=&before_time=",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														":id",
														"snapshot"
													],
													"query": [
														{
															"key": "after_time",
															"value": "",
															"description": "Filter snapshots to those taken on or after this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\"."
														},
														{
															"key": "before_time",
															"value": "",
															"description": "Filter snapshots to those taken before or on this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\"."
														}
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of the Microsoft SQL database."
														}
													]
												},
												"description": "Returns a list of summary information for snapshots of a Microsoft SQL database."
											},
											"response": [
												{
													"name": "Returns summary information for snapshots.",
													"originalRequest": {
														"method": "GET",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/mssql/db/:id/snapshot?after_time=&before_time=",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"mssql",
																"db",
																":id",
																"snapshot"
															],
															"query": [
																{
																	"key": "after_time",
																	"value": ""
																},
																{
																	"key": "before_time",
																	"value": ""
																}
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "OK",
													"code": 200,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "Take an on-demand backup of a Microsoft SQL database",
											"request": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/:id/snapshot",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														":id",
														"snapshot"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of the Microsoft SQL database."
														}
													]
												},
												"description": "Take an on-demand backup of a Microsoft SQL database. The forceFullSnapshot property can be set to true to force a full snapshot. To check the result of the request, poll /mssql/request/{id}."
											},
											"response": [
												{
													"name": "Returns the async request for the initiated on-demand backup.",
													"originalRequest": {
														"method": "POST",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/mssql/db/:id/snapshot",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"mssql",
																"db",
																":id",
																"snapshot"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "Accepted",
													"code": 202,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "Delete all snapshots of a Microsoft SQL database",
											"request": {
												"method": "DELETE",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/:id/snapshot",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														":id",
														"snapshot"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of the Microsoft SQL database."
														}
													]
												},
												"description": "Deletes all snapshots of a Microsoft SQL database. The database must be unprotected for the operation to succeed."
											},
											"response": [
												{
													"name": "Returned if all snapshots for the Microsoft SQL database were successfully removed.",
													"originalRequest": {
														"method": "DELETE",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/mssql/db/:id/snapshot",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"mssql",
																"db",
																":id",
																"snapshot"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "No Content",
													"code": 204,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										}
									],
									"protocolProfileBehavior": {},
									"_postman_isSubFolder": true
								},
								{
									"name": "Get detailed information for a Microsoft SQL database",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/db/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"db",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the Microsoft SQL database to fetch."
												}
											]
										},
										"description": "Returns a detailed view of a Microsoft SQL database."
									},
									"response": [
										{
											"name": "Returned if the query was successful.",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Update a Microsoft SQL database",
									"request": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/db/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"db",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the Microsoft SQL database to update."
												}
											]
										},
										"description": "Update a Microsoft SQL database with the specified properties."
									},
									"response": [
										{
											"name": "Returned if the update was successful",
											"originalRequest": {
												"method": "PATCH",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Export a Microsoft SQL database to a new location",
									"request": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/db/:id/export",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"db",
												":id",
												"export"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the Microsoft SQL database."
												}
											]
										},
										"description": "Create a request to export a Microsoft SQL database. To check the result of the request, poll /mssql/request/{id}."
									},
									"response": [
										{
											"name": "Returns the async request for the initiated export.",
											"originalRequest": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/:id/export",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														":id",
														"export"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "Accepted",
											"code": 202,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Take an on-demand log backup for a Microsoft SQL database",
									"request": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/db/:id/log_backup",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"db",
												":id",
												"log_backup"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the Microsoft SQL database."
												}
											]
										},
										"description": "Take an on-demand log backup for a Microsoft SQL database."
									},
									"response": [
										{
											"name": "Returns the async request for the initiated on-demand log backup.",
											"originalRequest": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/:id/log_backup",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														":id",
														"log_backup"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "Accepted",
											"code": 202,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Create a log shipping configuration",
									"request": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/db/:id/log_shipping",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"db",
												":id",
												"log_shipping"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the primary database object."
												}
											]
										},
										"description": "Create a log shipping configuration between a specified primary database and a specified secondary database. The transaction logs from the primary database are regularly restored to the secondary database in order to maintain the secondary database as a point-in-time copy of the primary database. The primary database must have log backups configured, and it must be in the full or bulk-logged recovery model."
									},
									"response": [
										{
											"name": "Returned when the specified log shipping configuration is successfully applied.",
											"originalRequest": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/:id/log_shipping",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														":id",
														"log_shipping"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "Accepted",
											"code": 202,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Get missed recoverable ranges of a Microsoft SQL database",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/db/:id/missed_recoverable_range?after_time=&before_time=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"db",
												":id",
												"missed_recoverable_range"
											],
											"query": [
												{
													"key": "after_time",
													"value": "",
													"description": "Filter the missed ranges to end after this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\"."
												},
												{
													"key": "before_time",
													"value": "",
													"description": "Filter the missed ranges to start before this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\"."
												}
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the Microsoft SQL database."
												}
											]
										},
										"description": "Retrieve a list of missed recoverable ranges for a Microsoft SQL database. For each run of one type of error, the first and last occurrence of the error are given."
									},
									"response": [
										{
											"name": "Returns the missed recoverable ranges for the Microsoft SQL database.",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/:id/missed_recoverable_range?after_time=&before_time=",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														":id",
														"missed_recoverable_range"
													],
													"query": [
														{
															"key": "after_time",
															"value": ""
														},
														{
															"key": "before_time",
															"value": ""
														}
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Get summary information for missed snapshots of a SQL database",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/db/:id/missed_snapshot?after_time=&before_time=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"db",
												":id",
												"missed_snapshot"
											],
											"query": [
												{
													"key": "after_time",
													"value": "",
													"description": "Filter snapshots to those missed on or after this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\"."
												},
												{
													"key": "before_time",
													"value": "",
													"description": "Filter snapshots to those missed on or before this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\"."
												}
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the Microsoft SQL database."
												}
											]
										},
										"description": "Returns a list of summary information for the missed snapshots of a Microsoft SQL database, including the time of day and the locations where the snapshot was missed."
									},
									"response": [
										{
											"name": "Returns details about the missed snapshots.",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/:id/missed_snapshot?after_time=&before_time=",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														":id",
														"missed_snapshot"
													],
													"query": [
														{
															"key": "after_time",
															"value": ""
														},
														{
															"key": "before_time",
															"value": ""
														}
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Live Mount SQL Server database from a point in time copy",
									"request": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/db/:id/mount",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"db",
												":id",
												"mount"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the SQL Server database."
												}
											]
										},
										"description": "Create an async request to Live Mount a SQL Server database. Poll the task status by using /mssql/request/{id}."
									},
									"response": [
										{
											"name": "Returns the async task object for the Live Mount request.",
											"originalRequest": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/:id/mount",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														":id",
														"mount"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "Accepted",
											"code": 202,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Get recoverable ranges of a Microsoft SQL database",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/db/:id/recoverable_range?after_time=&before_time=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"db",
												":id",
												"recoverable_range"
											],
											"query": [
												{
													"key": "after_time",
													"value": "",
													"description": "Filter ranges to end after this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678Z\"."
												},
												{
													"key": "before_time",
													"value": "",
													"description": "Filter ranges to start before this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\"."
												}
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the Microsoft SQL database."
												}
											]
										},
										"description": "Retrieve the recoverable ranges for a specified Microsoft SQL database. A begin and/or end timestamp can be provided to retrieve only the ranges that fall within the window."
									},
									"response": [
										{
											"name": "Returns the recoverable ranges for the Microsoft SQL database.",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/:id/recoverable_range?after_time=&before_time=",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														":id",
														"recoverable_range"
													],
													"query": [
														{
															"key": "after_time",
															"value": ""
														},
														{
															"key": "before_time",
															"value": ""
														}
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Restore a Microsoft SQL database",
									"request": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/db/:id/restore",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"db",
												":id",
												"restore"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the Microsoft SQL database."
												}
											]
										},
										"description": "Create a request to restore a SQL Server database. To check the result of the request, poll /mssql/request/{id}."
									},
									"response": [
										{
											"name": "Returns the async request for the initiated restore.",
											"originalRequest": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/db/:id/restore",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"db",
														":id",
														"restore"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "Accepted",
											"code": 202,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								}
							],
							"protocolProfileBehavior": {},
							"_postman_isSubFolder": true
						},
						{
							"name": "Get summary information for SQL Server databases",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/mssql/db?instance_id=&availability_group_id=&effective_sla_domain_id=&primary_cluster_id=&name=&sla_assignment=&limit=&offset=&is_relic=&is_live_mount=&is_log_shipping_secondary=&sort_by=&sort_order=&include_backup_task_info=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"mssql",
										"db"
									],
									"query": [
										{
											"key": "instance_id",
											"value": "",
											"description": "Filter by Microsoft SQL instance."
										},
										{
											"key": "availability_group_id",
											"value": "",
											"description": "Filter by the `id` of an Always On Availability Group."
										},
										{
											"key": "effective_sla_domain_id",
											"value": "",
											"description": "Filter by effective SLA domain."
										},
										{
											"key": "primary_cluster_id",
											"value": "",
											"description": "Filter by primary cluster."
										},
										{
											"key": "name",
											"value": "",
											"description": "Filter by a substring of the database name."
										},
										{
											"key": "sla_assignment",
											"value": "",
											"description": "SLA Assignment of the database."
										},
										{
											"key": "limit",
											"value": "",
											"description": "Limit the number of matches returned."
										},
										{
											"key": "offset",
											"value": "",
											"description": "An integer that specifies a number of initial matches to ignore."
										},
										{
											"key": "is_relic",
											"value": "",
											"description": "Filter database summary information by the value of the `isRelic` field."
										},
										{
											"key": "is_live_mount",
											"value": "",
											"description": "Filter database summary information by the value of the `isLiveMount` field."
										},
										{
											"key": "is_log_shipping_secondary",
											"value": "",
											"description": "Filter database summary information by the value of the `isLogShippingSecondary` field."
										},
										{
											"key": "sort_by",
											"value": "",
											"description": "Specifies the SQL Server Database attribute to use in sorting the summary information. Performs an ASCII sort using the specified attribute, in the order specified by sort_order. (This can only be one of effectiveSlaDomainName,name)"
										},
										{
											"key": "sort_order",
											"value": "",
											"description": "Sort order, either ascending or descending. (This can only be one of asc,desc)"
										},
										{
											"key": "include_backup_task_info",
											"value": "",
											"description": "Include backup task information in response"
										}
									]
								},
								"description": "Returns a list of summary information for Microsoft SQL databases."
							},
							"response": [
								{
									"name": "Returned if the query was successful.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/db?instance_id=&availability_group_id=&effective_sla_domain_id=&primary_cluster_id=&name=&sla_assignment=&limit=&offset=&is_relic=&is_live_mount=&is_log_shipping_secondary=&sort_by=&sort_order=&include_backup_task_info=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"db"
											],
											"query": [
												{
													"key": "instance_id",
													"value": ""
												},
												{
													"key": "availability_group_id",
													"value": ""
												},
												{
													"key": "effective_sla_domain_id",
													"value": ""
												},
												{
													"key": "primary_cluster_id",
													"value": ""
												},
												{
													"key": "name",
													"value": ""
												},
												{
													"key": "sla_assignment",
													"value": ""
												},
												{
													"key": "limit",
													"value": ""
												},
												{
													"key": "offset",
													"value": ""
												},
												{
													"key": "is_relic",
													"value": ""
												},
												{
													"key": "is_live_mount",
													"value": ""
												},
												{
													"key": "is_log_shipping_secondary",
													"value": ""
												},
												{
													"key": "sort_by",
													"value": ""
												},
												{
													"key": "sort_order",
													"value": ""
												},
												{
													"key": "include_backup_task_info",
													"value": ""
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Get details information about a Microsoft SQL database snapshot",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/mssql/db/snapshot/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"mssql",
										"db",
										"snapshot",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the snapshot."
										}
									]
								},
								"description": "Returns detailed information about a Microsoft SQL database snapshot."
							},
							"response": [
								{
									"name": "Returns details about a Microsoft SQL database snapshot.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/db/snapshot/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"db",
												"snapshot",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "hierarchy/{id}",
					"item": [
						{
							"name": "Get summary of a SQL Server hierarchy object",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/mssql/hierarchy/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"mssql",
										"hierarchy",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the SQL Server hierarchy object."
										}
									]
								},
								"description": "Retrieve details for the specified object in the SQL Server hierarchy."
							},
							"response": [
								{
									"name": "Details of the hierarchy object.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/hierarchy/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"hierarchy",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Get list of immediate descendant objects",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/mssql/hierarchy/:id/children?effective_sla_domain_id=&object_type=&primary_cluster_id=&limit=&offset=&name=&is_relic=&is_live_mount=&is_log_shipping_secondary=&is_clustered=&has_instances=&sla_assignment=&sort_by=&sort_order=&snappable_status=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"mssql",
										"hierarchy",
										":id",
										"children"
									],
									"query": [
										{
											"key": "effective_sla_domain_id",
											"value": "",
											"description": "Filter by the ID of the effective SLA Domain."
										},
										{
											"key": "object_type",
											"value": "",
											"description": "Filter by a comma-separated list of node object types. Valid object types are Host, MssqlInstance, MssqlDatabase, WindowsCluster, and MssqlAvailabilityGroup."
										},
										{
											"key": "primary_cluster_id",
											"value": "",
											"description": "Filter by primary cluster ID, or **local**."
										},
										{
											"key": "limit",
											"value": "",
											"description": "Limit the number of matches returned."
										},
										{
											"key": "offset",
											"value": "",
											"description": "An integer that specifies the number of initial matches to ignore."
										},
										{
											"key": "name",
											"value": "",
											"description": "Filter children by provided name."
										},
										{
											"key": "is_relic",
											"value": "",
											"description": "Filter by the value of the `isRelic` field for nodes with object type MssqlDatabase."
										},
										{
											"key": "is_live_mount",
											"value": "",
											"description": "Filter database by the value of the `isLiveMount` field for nodes with object type MssqlDatabase."
										},
										{
											"key": "is_log_shipping_secondary",
											"value": "",
											"description": "Filter by the value of the `isLogShippingSecondary` field for nodes with object type MssqlDatabase."
										},
										{
											"key": "is_clustered",
											"value": "",
											"description": "Filter by the value of the `isClustered` field for nodes with object type MssqlDatabase or MssqlInstance."
										},
										{
											"key": "has_instances",
											"value": "",
											"description": "Boolean that filters top-level nodes with the Host or WindowsCluster object type by whether or not the nodes have children MssqlInstance nodes. When this value is 'true,' the filter shows only nodes with children MssqlInstance nodes. When this value is 'false,' the filter shows only nodes without children MssqlInstance nodes."
										},
										{
											"key": "sla_assignment",
											"value": "",
											"description": "Filter by SLA assignment type. (This can only be one of Derived,Direct,Unassigned)"
										},
										{
											"key": "sort_by",
											"value": "",
											"description": "Attribute to sort the results on. (This can only be one of name,descendantCount.MssqlInstance,descendantCount.MssqlDatabase,logBackupRetentionHours,copyOnly,effectiveSlaDomainName)"
										},
										{
											"key": "sort_order",
											"value": "",
											"description": "Sort order, either ascending or descending. (This can only be one of asc,desc)"
										},
										{
											"key": "snappable_status",
											"value": "",
											"description": "Determines whether SQL Server instances are fetched with additional privilege checks. (This can only be one of Protectable)"
										}
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the parent SQL Server hierarchy object. To get top-level nodes, use **root** as the ID."
										}
									]
								},
								"description": "Retrieve the list of immediate descendant objects for the specified parent"
							},
							"response": [
								{
									"name": "Summary list of children objects.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/hierarchy/:id/children?effective_sla_domain_id=&object_type=&primary_cluster_id=&limit=&offset=&name=&is_relic=&is_live_mount=&is_log_shipping_secondary=&is_clustered=&has_instances=&sla_assignment=&sort_by=&sort_order=&snappable_status=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"hierarchy",
												":id",
												"children"
											],
											"query": [
												{
													"key": "effective_sla_domain_id",
													"value": ""
												},
												{
													"key": "object_type",
													"value": ""
												},
												{
													"key": "primary_cluster_id",
													"value": ""
												},
												{
													"key": "limit",
													"value": ""
												},
												{
													"key": "offset",
													"value": ""
												},
												{
													"key": "name",
													"value": ""
												},
												{
													"key": "is_relic",
													"value": ""
												},
												{
													"key": "is_live_mount",
													"value": ""
												},
												{
													"key": "is_log_shipping_secondary",
													"value": ""
												},
												{
													"key": "is_clustered",
													"value": ""
												},
												{
													"key": "has_instances",
													"value": ""
												},
												{
													"key": "sla_assignment",
													"value": ""
												},
												{
													"key": "sort_by",
													"value": ""
												},
												{
													"key": "sort_order",
													"value": ""
												},
												{
													"key": "snappable_status",
													"value": ""
												}
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Get list of descendant objects",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/mssql/hierarchy/:id/descendants?effective_sla_domain_id=&object_type=&primary_cluster_id=&limit=&offset=&name=&is_relic=&is_live_mount=&is_log_shipping_secondary=&is_clustered=&has_instances=&sla_assignment=&sort_by=&sort_order=&snappable_status=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"mssql",
										"hierarchy",
										":id",
										"descendants"
									],
									"query": [
										{
											"key": "effective_sla_domain_id",
											"value": "",
											"description": "Filter by the ID of the effective SLA Domain."
										},
										{
											"key": "object_type",
											"value": "",
											"description": "Filter by a comma-separated list of node object types. Valid object types are Host, MssqlInstance, MssqlDatabase, WindowsCluster, and MssqlAvailabilityGroup."
										},
										{
											"key": "primary_cluster_id",
											"value": "",
											"description": "Filter by primary cluster ID, or **local**."
										},
										{
											"key": "limit",
											"value": "",
											"description": "Limit the number of matches returned."
										},
										{
											"key": "offset",
											"value": "",
											"description": "An integer that specifies the number of initial matches to ignore."
										},
										{
											"key": "name",
											"value": "",
											"description": "Filter descendants by provided name."
										},
										{
											"key": "is_relic",
											"value": "",
											"description": "Filter by the value of the `isRelic` field for nodes with MssqlDatabase as the value of the object type field."
										},
										{
											"key": "is_live_mount",
											"value": "",
											"description": "Filter database by the value of the `isLiveMount` field for nodes with MssqlDatabase as the value of the object type field."
										},
										{
											"key": "is_log_shipping_secondary",
											"value": "",
											"description": "Filter by the value of the `isLogShippingSecondary` field for nodes with MssqlDatabase as the value of the object type field."
										},
										{
											"key": "is_clustered",
											"value": "",
											"description": "Filter by the value of the `isClustered` field for nodes with object type MssqlDatabase or MssqlInstance."
										},
										{
											"key": "has_instances",
											"value": "",
											"description": "Boolean that filters top-level nodes with the Host or WindowsCluster object type by whether or not the nodes have children MssqlInstance nodes. When this value is 'true,' the filter shows only nodes with children MssqlInstance nodes. When this value is 'false,' the filter shows only nodes without children MssqlInstance nodes."
										},
										{
											"key": "sla_assignment",
											"value": "",
											"description": "Filter by SLA Domain assignment type. (This can only be one of Derived,Direct,Unassigned)"
										},
										{
											"key": "sort_by",
											"value": "",
											"description": "Attribute to sort the results on. (This can only be one of name,descendantCount.MssqlInstance,descendantCount.MssqlDatabase,logBackupRetentionHours,copyOnly,effectiveSlaDomainName)"
										},
										{
											"key": "sort_order",
											"value": "",
											"description": "Sort order, either ascending or descending. (This can only be one of asc,desc)"
										},
										{
											"key": "snappable_status",
											"value": "",
											"description": "Determines whether SQL Server instances are fetched with additional privilege checks. (This can only be one of Protectable)"
										}
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the parent SQL server hierarchy object. To get top-level nodes, use **root** as the ID."
										}
									]
								},
								"description": "Retrieve the list of descendant objects for the specified parent"
							},
							"response": [
								{
									"name": "Summary list of descendant objects.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/hierarchy/:id/descendants?effective_sla_domain_id=&object_type=&primary_cluster_id=&limit=&offset=&name=&is_relic=&is_live_mount=&is_log_shipping_secondary=&is_clustered=&has_instances=&sla_assignment=&sort_by=&sort_order=&snappable_status=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"hierarchy",
												":id",
												"descendants"
											],
											"query": [
												{
													"key": "effective_sla_domain_id",
													"value": ""
												},
												{
													"key": "object_type",
													"value": ""
												},
												{
													"key": "primary_cluster_id",
													"value": ""
												},
												{
													"key": "limit",
													"value": ""
												},
												{
													"key": "offset",
													"value": ""
												},
												{
													"key": "name",
													"value": ""
												},
												{
													"key": "is_relic",
													"value": ""
												},
												{
													"key": "is_live_mount",
													"value": ""
												},
												{
													"key": "is_log_shipping_secondary",
													"value": ""
												},
												{
													"key": "is_clustered",
													"value": ""
												},
												{
													"key": "has_instances",
													"value": ""
												},
												{
													"key": "sla_assignment",
													"value": ""
												},
												{
													"key": "sort_by",
													"value": ""
												},
												{
													"key": "sort_order",
													"value": ""
												},
												{
													"key": "snappable_status",
													"value": ""
												}
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "instance",
					"item": [
						{
							"name": "{id}",
							"item": [
								{
									"name": "Get detailed information for a Microsoft SQL instance",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/instance/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"instance",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the Microsoft SQL instance."
												}
											]
										},
										"description": "Returns a detailed view of a Microsoft SQL instance."
									},
									"response": [
										{
											"name": "Returned if the query was successful.",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/instance/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"instance",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Update a Microsoft SQL instance",
									"request": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/instance/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"instance",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the Microsoft SQL instance."
												}
											]
										},
										"description": "Update a Microsoft SQL instance with specified properties."
									},
									"response": [
										{
											"name": "Returned if the update was successful.",
											"originalRequest": {
												"method": "PATCH",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/mssql/instance/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"mssql",
														"instance",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								}
							],
							"protocolProfileBehavior": {},
							"_postman_isSubFolder": true
						},
						{
							"name": "Get summary information for Microsoft SQL instances",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/mssql/instance?root_id=&primary_cluster_id=&snappable_status=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"mssql",
										"instance"
									],
									"query": [
										{
											"key": "root_id",
											"value": "",
											"description": "Include only instances that belong to this root."
										},
										{
											"key": "primary_cluster_id",
											"value": "",
											"description": "Limits the instances returned within one cluster specified by primary_cluster_id."
										},
										{
											"key": "snappable_status",
											"value": "",
											"description": "Determines whether SQL Server instances are fetched with additional privilege checks. (This can only be one of Protectable)"
										}
									]
								},
								"description": "Returns a list of summary information for Microsoft SQL instances."
							},
							"response": [
								{
									"name": "Returned if the query was successful.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/mssql/instance?root_id=&primary_cluster_id=&snappable_status=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"mssql",
												"instance"
											],
											"query": [
												{
													"key": "root_id",
													"value": ""
												},
												{
													"key": "primary_cluster_id",
													"value": ""
												},
												{
													"key": "snappable_status",
													"value": ""
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "Get details for an async request",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/mssql/request/:id",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"mssql",
								"request",
								":id"
							],
							"variable": [
								{
									"key": "id",
									"value": "schema type not provided",
									"description": "(Required) ID of the async request."
								}
							]
						},
						"description": "Returns the task object for an async request related to SQL Server databases."
					},
					"response": [
						{
							"name": "Status of the async request.",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/mssql/request/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"mssql",
										"request",
										":id"
									],
									"variable": [
										{
											"key": "id"
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Assign SLA properties to SQL Server objects",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/mssql/sla_domain/assign",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"mssql",
								"sla_domain",
								"assign"
							]
						},
						"description": "Assigns SLA Domain properties to SQL Server objects. Hosts and Windows clusters cannot be assigned SLA Domains directly. The SLA Domains are instead applied to the SQL Server child objects within the Host or Windows Cluster object. Newly discovered SQL Server objects within a given Host or Windows Cluster object do not inherit SLA Domain properties from other child SQL Server objects with the same parent object."
					},
					"response": [
						{
							"name": "Successfully assigned SLA Domain properties.",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/mssql/sla_domain/assign",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"mssql",
										"sla_domain",
										"assign"
									]
								}
							},
							"status": "No Content",
							"code": 204,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "oracle/db/{id}",
			"item": [
				{
					"name": "Delete downloaded Oracle database snapshots and log snapshots",
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/oracle/db/:id/downloaded_snapshots?after_time=&before_time=",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"oracle",
								"db",
								":id",
								"downloaded_snapshots"
							],
							"query": [
								{
									"key": "after_time",
									"value": "",
									"description": "Uses the ISO 8601 format to specify the start of the time period used by the asynchronous snapshot expiration job, as in the example \"2016-01-01T01:23:45.678\"."
								},
								{
									"key": "before_time",
									"value": "",
									"description": "Uses the ISO 8601 format to specify the end of the time period used by the asynchronous snapshot expiration job, as in the example \"2016-01-01T01:23:45.678\"."
								}
							],
							"variable": [
								{
									"key": "id",
									"value": "schema type not provided",
									"description": "(Required) ID of the Oracle database"
								}
							]
						},
						"description": "Requests an asynchronous job to expire downloaded database snapshots taken during a specified time period as well as log snapshots that contain any logs with timestamps within that time period."
					},
					"response": [
						{
							"name": "The request status of the asynchronous job that deletes downloaded Oracle database snapshots and log snapshots.",
							"originalRequest": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/oracle/db/:id/downloaded_snapshots?after_time=&before_time=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"oracle",
										"db",
										":id",
										"downloaded_snapshots"
									],
									"query": [
										{
											"key": "after_time",
											"value": ""
										},
										{
											"key": "before_time",
											"value": ""
										}
									],
									"variable": [
										{
											"key": "id"
										}
									]
								}
							},
							"status": "Accepted",
							"code": 202,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Get a size estimate for a restore or export",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/oracle/db/:id/restore_estimate?snapshot_id=&recovery_time=",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"oracle",
								"db",
								":id",
								"restore_estimate"
							],
							"query": [
								{
									"key": "snapshot_id",
									"value": "",
									"description": "ID of the snapshot to recover to."
								},
								{
									"key": "recovery_time",
									"value": "",
									"description": "The date and time for the recovery restore point, specified in the ISO 8601 format, as in the example \"2016-01-01T01:23:45.678\"."
								}
							],
							"variable": [
								{
									"key": "id",
									"value": "schema type not provided",
									"description": "(Required) ID of the Oracle database."
								}
							]
						},
						"description": "The estimated size of the data to download from an archival location in order to perform a specified restore or export operation."
					},
					"response": [
						{
							"name": "Returns the estimate for a restore or export to the specified recovery point.",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/oracle/db/:id/restore_estimate?snapshot_id=&recovery_time=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"oracle",
										"db",
										":id",
										"restore_estimate"
									],
									"query": [
										{
											"key": "snapshot_id",
											"value": ""
										},
										{
											"key": "recovery_time",
											"value": ""
										}
									],
									"variable": [
										{
											"key": "id"
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "saml",
			"item": [
				{
					"name": "Make SAML authentication request",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/saml/authn_request/:idp_name",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"saml",
								"authn_request",
								":idp_name"
							],
							"variable": [
								{
									"key": "idp_name",
									"value": "schema type not provided",
									"description": "(Required) Name of the IdP Authentication Domain to authenticate with."
								}
							]
						},
						"description": "Make a SAML authentication request for a specified IdP Authentication Domain."
					},
					"response": [
						{
							"name": "Return the necessary data for constructing SAML authentication request.",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/saml/authn_request/:idp_name",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"saml",
										"authn_request",
										":idp_name"
									],
									"variable": [
										{
											"key": "idp_name"
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Configure and generate Rubrik SAML metadata",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/saml/rubrik_metadata",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"saml",
								"rubrik_metadata"
							]
						},
						"description": "Configure and generate the SAML metadata for this Rubrik cluster. The call returns the download URL for the metadata."
					},
					"response": [
						{
							"name": "Returns the URL for downloading the Rubrik SAML metadata.",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/saml/rubrik_metadata",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"saml",
										"rubrik_metadata"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Check SAML SSO Status",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/saml/sso_status",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"saml",
								"sso_status"
							]
						},
						"description": "An object that contains two values. A Boolean value that determines whether or not SSO is enabled and an optional String value that indicates the name of the default IdP authentication domain for SSO login. When the boolean value is 'true,' SAML SSO is enabled. When the Boolean value is 'false,' SAML SSO is disabled."
					},
					"response": [
						{
							"name": "Return an object containing SAML SSO status",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/saml/sso_status",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"saml",
										"sso_status"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "session",
			"item": [
				{
					"name": "Create user session",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/session?organization_id=&realm=",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"session"
							],
							"query": [
								{
									"key": "organization_id",
									"value": "",
									"description": "Bind the new session to the specified organization. When this parameter is not specified, the session will be bound to an organization chosen according to the user's preferences and authorizations."
								},
								{
									"key": "realm",
									"value": "",
									"description": "Bind the new session to the specified directory. When this parameter is unspecified, the session will be bound to local domain."
								}
							]
						},
						"description": "Open a user session."
					},
					"response": [
						{
							"name": "Session creation successful",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/session?organization_id=&realm=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"session"
									],
									"query": [
										{
											"key": "organization_id",
											"value": ""
										},
										{
											"key": "realm",
											"value": ""
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Delete user session",
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/session/:id",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"session",
								":id"
							],
							"variable": [
								{
									"key": "id",
									"value": "schema type not provided",
									"description": "(Required) Session ID or  *me* for session of bearer token."
								}
							]
						},
						"description": "Close a user session and invalidate the session token."
					},
					"response": [
						{
							"name": "Invalidation successful",
							"originalRequest": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/session/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"session",
										":id"
									],
									"variable": [
										{
											"key": "id"
										}
									]
								}
							},
							"status": "No Content",
							"code": 204,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "sla domain",
			"item": [
				{
					"name": "{id}",
					"item": [
						{
							"name": "Get SLA Domain details",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/sla_domain/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"sla_domain",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the SLA Domain."
										}
									]
								},
								"description": "Retrieve summary information for a specified SLA Domain."
							},
							"response": [
								{
									"name": "Object containing information about the SLA Domain",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/sla_domain/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"sla_domain",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Remove SLA Domain",
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/sla_domain/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"sla_domain",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the SLA Domain."
										}
									]
								},
								"description": "Delete an SLA Domain from a Rubrik cluster. The SLA Domain must not be assigned to any VMs, filesets or databases."
							},
							"response": [
								{
									"name": "Removed the specified SLA Domain.",
									"originalRequest": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/sla_domain/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"sla_domain",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "No Content",
									"code": 204,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Update SLA Domain",
							"request": {
								"method": "PUT",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/sla_domain/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"sla_domain",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the SLA Domain."
										}
									]
								},
								"description": "Update the properties of an SLA Domain."
							},
							"response": [
								{
									"name": "Object containing updated SLA Domain.",
									"originalRequest": {
										"method": "PUT",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/sla_domain/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"sla_domain",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Patch SLA Domain",
							"request": {
								"method": "PATCH",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/sla_domain/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"sla_domain",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the SLA Domain."
										}
									]
								},
								"description": "Patch the properties of an SLA Domain."
							},
							"response": [
								{
									"name": "Object containing the patched SLA Domain.",
									"originalRequest": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/sla_domain/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"sla_domain",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "Get list of SLA Domains",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/sla_domain?primary_cluster_id=&name=&sort_by=&sort_order=&data_sources=&snapshot_ids=",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"sla_domain"
							],
							"query": [
								{
									"key": "primary_cluster_id",
									"value": "",
									"description": "Limits the information retrieved to those SLA Domains that are associated with the Rubrik cluster ID that is specified by primary_cluster_id. Use **local** for the Rubrik cluster that is hosting the current REST API session."
								},
								{
									"key": "name",
									"value": "",
									"description": "Limit the list information to those SLA Domains which match the specified SLA Domain 'name' value."
								},
								{
									"key": "sort_by",
									"value": "",
									"description": "Attribute to use to sort the SLA Domains summary information. Optionally use **_sort_order_** to specify whether to sort in ascending or descending order (This can only be one of name)"
								},
								{
									"key": "sort_order",
									"value": "",
									"description": "Sort order, either ascending or descending. If not specified, SLA Domain summary results will be sorted in ascending order (This can only be one of asc,desc)"
								},
								{
									"key": "data_sources",
									"value": "",
									"description": "Limit the list information to SLA Domains that can be assigned to specified data sources."
								},
								{
									"key": "snapshot_ids",
									"value": "",
									"description": "Limit the list information to SLA Domains that can be assigned to specified snapshots."
								}
							]
						},
						"description": "Retrieve summary information for all SLA Domains."
					},
					"response": [
						{
							"name": "Summary information for SLA Domains",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/sla_domain?primary_cluster_id=&name=&sort_by=&sort_order=&data_sources=&snapshot_ids=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"sla_domain"
									],
									"query": [
										{
											"key": "primary_cluster_id",
											"value": ""
										},
										{
											"key": "name",
											"value": ""
										},
										{
											"key": "sort_by",
											"value": ""
										},
										{
											"key": "sort_order",
											"value": ""
										},
										{
											"key": "data_sources",
											"value": ""
										},
										{
											"key": "snapshot_ids",
											"value": ""
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Create SLA Domain",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/sla_domain",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"sla_domain"
							]
						},
						"description": "Create a new SLA Domain on a Rubrik cluster by specifying Domain Rules and policies."
					},
					"response": [
						{
							"name": "Summary of newly created SLA Domain.",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/sla_domain",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"sla_domain"
									]
								}
							},
							"status": "Created",
							"code": 201,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "syslog/export",
			"item": [
				{
					"name": "{id}",
					"item": [
						{
							"name": "Get the specified syslog export rule",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/syslog/export/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"syslog",
										"export",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) The ID of syslog export rule."
										}
									]
								},
								"description": "Get the summary of the syslog export rule specified by the given id.\n"
							},
							"response": [
								{
									"name": "Summary of the syslog export rule.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/syslog/export/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"syslog",
												"export",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Update the specified syslog export rule",
							"request": {
								"method": "PATCH",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/syslog/export/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"syslog",
										"export",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) The ID of syslog export rule."
										}
									]
								},
								"description": "Update the syslog export rule specified by the given id."
							},
							"response": [
								{
									"name": "Updated syslog export rule.",
									"originalRequest": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/syslog/export/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"syslog",
												"export",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Delete the specified syslog export rule",
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/syslog/export/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"syslog",
										"export",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) The ID of the syslog export rule."
										}
									]
								},
								"description": "Delete the syslog export rule specified by the given id."
							},
							"response": [
								{
									"name": "Syslog server export rule successfully deleted.",
									"originalRequest": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/syslog/export/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"syslog",
												"export",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "No Content",
									"code": 204,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "Get the configured syslog export rules",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/syslog/export",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"syslog",
								"export"
							]
						},
						"description": "Return the list of all configured syslog export rules."
					},
					"response": [
						{
							"name": "List of all configured syslog export rules.",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/syslog/export",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"syslog",
										"export"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Add a new syslog export rule",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/syslog/export",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"syslog",
								"export"
							]
						},
						"description": "Adds a new rule specifying where to export the specified syslog information.\n"
					},
					"response": [
						{
							"name": "Summary of the newly added syslog export rule.",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/syslog/export",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"syslog",
										"export"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Test the specified syslog export rule",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/syslog/export/test",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"syslog",
								"export",
								"test"
							]
						},
						"description": "Send a test message using the syslog export rule specified by the given id.\n"
					},
					"response": [
						{
							"name": "Syslog export rule was tested successfully.",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/syslog/export/test",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"syslog",
										"export",
										"test"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "vcd/vapp/template/snapshot/{snapshot id}/export",
			"item": [
				{
					"name": "Export of a vApp template snapshot",
					"request": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/vcd/vapp/template/snapshot/:snapshot_id/export",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"vcd",
								"vapp",
								"template",
								"snapshot",
								":snapshot_id",
								"export"
							],
							"variable": [
								{
									"key": "snapshot_id",
									"value": "schema type not provided",
									"description": "(Required) ID assigned to a vApp snapshot object."
								}
							]
						},
						"description": "Export a vApp template snapashot to a catalog. Use the options endpoint to confirm that exporting to the catalog defaults or the original organization vDC storage profile is possible."
					},
					"response": [
						{
							"name": "Request status for asynchronous Export job for vApp template snapshot.",
							"originalRequest": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/vcd/vapp/template/snapshot/:snapshot_id/export",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"vcd",
										"vapp",
										"template",
										"snapshot",
										":snapshot_id",
										"export"
									],
									"variable": [
										{
											"key": "snapshot_id"
										}
									]
								}
							},
							"status": "Accepted",
							"code": 202,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Get Export information for a vApp template snapshot",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/vcd/vapp/template/snapshot/:snapshot_id/export/options?catalog_id=&name=&org_vdc_id=",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"vcd",
								"vapp",
								"template",
								"snapshot",
								":snapshot_id",
								"export",
								"options"
							],
							"query": [
								{
									"key": "catalog_id",
									"value": "",
									"description": "(Required) ID of the target catalog object."
								},
								{
									"key": "name",
									"value": "",
									"description": "(Required) Name of template object to create. This is used to verify the existence of a template with the given name. Templates must have unique names."
								},
								{
									"key": "org_vdc_id",
									"value": "",
									"description": "ID assigned to a target organization vDC object. Use the ID when exporting a vApp template snapshot to a specified organization VDC. This ID is used to fetch the avaiable choices to pick the storage profile of the template. Leave this field empty to use the options from the original organization vDC or the target catalog defaults."
								}
							],
							"variable": [
								{
									"key": "snapshot_id",
									"value": "schema type not provided",
									"description": "(Required) ID assigned to a vApp snapshot object."
								}
							]
						},
						"description": "Retrieve the available choices vApp template storage profile and organization vDC choices in case of exporting to either original organization vDC defaults of the target catalog. In case advanced option of manually deciding org vdc is preferred, this also provides available storage profile choices."
					},
					"response": [
						{
							"name": "Untitled Response",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/vcd/vapp/template/snapshot/:snapshot_id/export/options?catalog_id=&name=&org_vdc_id=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"vcd",
										"vapp",
										"template",
										"snapshot",
										":snapshot_id",
										"export",
										"options"
									],
									"query": [
										{
											"key": "catalog_id",
											"value": ""
										},
										{
											"key": "name",
											"value": ""
										},
										{
											"key": "org_vdc_id",
											"value": ""
										}
									],
									"variable": [
										{
											"key": "snapshot_id"
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "vmware",
			"item": [
				{
					"name": "compute cluster",
					"item": [
						{
							"name": "{id}",
							"item": [
								{
									"name": "Get details for the compute cluster",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/compute_cluster/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"compute_cluster",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the compute cluster"
												}
											]
										},
										"description": "Get details for the compute cluster"
									},
									"response": [
										{
											"name": "Details of the requested compute cluster",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/compute_cluster/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"compute_cluster",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Modify information for a VMware compute cluster",
									"request": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/compute_cluster/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"compute_cluster",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the compute cluster"
												}
											]
										},
										"description": "Update the configuredSlaDomainId for a VMware compute cluster with a specific ID."
									},
									"response": [
										{
											"name": "Details of the updated compute cluster",
											"originalRequest": {
												"method": "PATCH",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/compute_cluster/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"compute_cluster",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Install the Rubrik ioFilter to the VMware cluster with a specific ID",
									"request": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/compute_cluster/:id/install_io_filter",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"compute_cluster",
												":id",
												"install_io_filter"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the VMware compute cluster"
												}
											]
										},
										"description": "Install the latest version of Rubrik ioFilter to the VMware cluster with a specific ID. The cluster must be in maintenance mode to install the ioFilter successfully. The vCenter of the VMware compute cluster must be of version 6.7 and above."
									},
									"response": [
										{
											"name": "Status of the Rubrik ioFilter installation job",
											"originalRequest": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/compute_cluster/:id/install_io_filter",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"compute_cluster",
														":id",
														"install_io_filter"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "Accepted",
											"code": 202,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										},
										{
											"name": "Returned if there is no compute cluster with the given ID",
											"originalRequest": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/compute_cluster/:id/install_io_filter",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"compute_cluster",
														":id",
														"install_io_filter"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "Not Found",
											"code": 404,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Get the ioFilters on the VMware compute cluster with a specific ID",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/compute_cluster/:id/io_filter",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"compute_cluster",
												":id",
												"io_filter"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the VMware compute cluster"
												}
											]
										},
										"description": "Get the summary of the ioFilters on the VMware compute cluster with a specific ID."
									},
									"response": [
										{
											"name": "Returned if there is no compute cluster with the given ID",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/compute_cluster/:id/io_filter",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"compute_cluster",
														":id",
														"io_filter"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "Not Found",
											"code": 404,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										},
										{
											"name": "List of the ioFilters on the VMware compute cluster",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/compute_cluster/:id/io_filter",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"compute_cluster",
														":id",
														"io_filter"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Uninstall the Rubrik ioFilter from the VMware cluster with a specific ID",
									"request": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/compute_cluster/:id/uninstall_io_filter",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"compute_cluster",
												":id",
												"uninstall_io_filter"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the VMware compute cluster"
												}
											]
										},
										"description": "Uninstall the Rubrik ioFilter from the VMware cluster with a specific ID. The cluster must be in maintenance mode to uninstall the ioFilter successfully. The vCenter of the VMware compute cluster must be of version 6.7 and above."
									},
									"response": [
										{
											"name": "Returned if there is no compute cluster with the given id",
											"originalRequest": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/compute_cluster/:id/uninstall_io_filter",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"compute_cluster",
														":id",
														"uninstall_io_filter"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "Not Found",
											"code": 404,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										},
										{
											"name": "Status of the Rubrik ioFilter uninstallation job",
											"originalRequest": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/compute_cluster/:id/uninstall_io_filter",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"compute_cluster",
														":id",
														"uninstall_io_filter"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "Accepted",
											"code": 202,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Upgrade the Rubrik ioFilter for the VMware cluster with a specific ID",
									"request": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/compute_cluster/:id/upgrade_io_filter",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"compute_cluster",
												":id",
												"upgrade_io_filter"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the VMware compute cluster"
												}
											]
										},
										"description": "Upgrade the Rubrik ioFilter for a VMware cluster with a specific ID. The cluster must be in maintenance mode to upgrade the ioFilter successfully. The vCenter of the VMware compute cluster must be of version 6.7 and above."
									},
									"response": [
										{
											"name": "Status of the Rubrik ioFilter upgrade",
											"originalRequest": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/compute_cluster/:id/upgrade_io_filter",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"compute_cluster",
														":id",
														"upgrade_io_filter"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "Accepted",
											"code": 202,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										},
										{
											"name": "Returned if there is no compute cluster with the given id",
											"originalRequest": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/compute_cluster/:id/upgrade_io_filter",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"compute_cluster",
														":id",
														"upgrade_io_filter"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "Not Found",
											"code": 404,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								}
							],
							"protocolProfileBehavior": {},
							"_postman_isSubFolder": true
						},
						{
							"name": "Get all the clusters belonging to this datacenter",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/vmware/compute_cluster?datacenter_id=&primary_cluster_id=&snappable_status=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"vmware",
										"compute_cluster"
									],
									"query": [
										{
											"key": "datacenter_id",
											"value": "",
											"description": "Filter clusters on data center ID"
										},
										{
											"key": "primary_cluster_id",
											"value": "",
											"description": "Filter on a primary cluster ID. Also accepts value 'local'"
										},
										{
											"key": "snappable_status",
											"value": "",
											"description": "Determines whether to fetch Compute Clusters with additional privilege checks. (This can only be one of Protectable)"
										}
									]
								},
								"description": "Get all the clusters belonging to this datacenter"
							},
							"response": [
								{
									"name": "Returns list of compute clusters subject to provided filters",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/compute_cluster?datacenter_id=&primary_cluster_id=&snappable_status=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"compute_cluster"
											],
											"query": [
												{
													"key": "datacenter_id",
													"value": ""
												},
												{
													"key": "primary_cluster_id",
													"value": ""
												},
												{
													"key": "snappable_status",
													"value": ""
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Get asynchronous request details for VMware cluster",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/vmware/compute_cluster/request/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"vmware",
										"compute_cluster",
										"request",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of an asynchronous request."
										}
									]
								},
								"description": "Get the details of an asynchronous request that involves a VMware compute cluster."
							},
							"response": [
								{
									"name": "Status of an asynchronous request.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/compute_cluster/request/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"compute_cluster",
												"request",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "host",
					"item": [
						{
							"name": "{id}",
							"item": [
								{
									"name": "Get details of a ESXi hypervisor",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/host/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"host",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the VMWare host"
												}
											]
										},
										"description": "Get details of a ESXi hypervisor"
									},
									"response": [
										{
											"name": "Details about the vmware host",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/host/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"host",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Update the SLA Domain for an ESXi hypervisor",
									"request": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/host/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"host",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the ESXi hypervisor"
												}
											]
										},
										"description": "Update the SLA Domain that is configured for an ESXi hypervisor."
									},
									"response": [
										{
											"name": "Details for the ESXi hypervisor",
											"originalRequest": {
												"method": "PATCH",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/host/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"host",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Get details of datastores in a ESXi hypervisor",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/host/:id/datastore",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"host",
												":id",
												"datastore"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the VMWare host"
												}
											]
										},
										"description": "Get details of datastores in a ESXi hypervisor"
									},
									"response": [
										{
											"name": "Details about the vmware host",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/host/:id/datastore",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"host",
														":id",
														"datastore"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								}
							],
							"protocolProfileBehavior": {},
							"_postman_isSubFolder": true
						},
						{
							"name": "Get summary of all the ESXi hypervisor",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/vmware/host?primary_cluster_id=&compute_cluster_id=&snappable_status=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"vmware",
										"host"
									],
									"query": [
										{
											"key": "primary_cluster_id",
											"value": "",
											"description": "ID of the Primary cluster"
										},
										{
											"key": "compute_cluster_id",
											"value": "",
											"description": "Filter by ID of Compute Cluster"
										},
										{
											"key": "snappable_status",
											"value": "",
											"description": "Requests additional data about VMware Hosts based on the specified query value. (This can only be one of Protectable)"
										}
									]
								},
								"description": "Get summary of all the ESXi hypervisor"
							},
							"response": [
								{
									"name": "List of VMware host summaries",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/host?primary_cluster_id=&compute_cluster_id=&snappable_status=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"host"
											],
											"query": [
												{
													"key": "primary_cluster_id",
													"value": ""
												},
												{
													"key": "compute_cluster_id",
													"value": ""
												},
												{
													"key": "snappable_status",
													"value": ""
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "vcenter",
					"item": [
						{
							"name": "{id}",
							"item": [
								{
									"name": "Get the details of a vCenter Server",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vcenter/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vcenter",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the vCenter Server."
												}
											]
										},
										"description": "Retrieve detailed information for a vCenter Server object."
									},
									"response": [
										{
											"name": "Details for a vCenter Server object.",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vcenter/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vcenter",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Update the SLA Domain for a vCenter Server",
									"request": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vcenter/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vcenter",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the vCenter Server."
												}
											]
										},
										"description": "Update the SLA Domain that is configured for a vCenter Server."
									},
									"response": [
										{
											"name": "Summary of the updated vCenter Server object.",
											"originalRequest": {
												"method": "PATCH",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vcenter/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vcenter",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Update vCenter Server",
									"request": {
										"method": "PUT",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vcenter/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vcenter",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the vCenter Server."
												}
											]
										},
										"description": "Update the address, username and password of the specified vCenter Server object."
									},
									"response": [
										{
											"name": "Summary of the updated vCenter Server object.",
											"originalRequest": {
												"method": "PUT",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vcenter/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vcenter",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Remove vCenter Server",
									"request": {
										"method": "DELETE",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vcenter/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vcenter",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the vCenter Server to remove."
												}
											]
										},
										"description": "Initiates an asynchronous job to remove a vCenter Server object. The vCenter Server cannot have VMs mounted through the Rubrik cluster."
									},
									"response": [
										{
											"name": "Status for the async request.",
											"originalRequest": {
												"method": "DELETE",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vcenter/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vcenter",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "Accepted",
											"code": 202,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Refresh vCenter Server metadata",
									"request": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vcenter/:id/refresh",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vcenter",
												":id",
												"refresh"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the vCenter Server"
												}
											]
										},
										"description": "Create a job to refresh the metadata for the specified vCenter Server"
									},
									"response": [
										{
											"name": "Job Instance ID of the scheduled vCenter Server refresh job.",
											"originalRequest": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vcenter/:id/refresh",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vcenter",
														":id",
														"refresh"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "Accepted",
											"code": 202,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								}
							],
							"protocolProfileBehavior": {},
							"_postman_isSubFolder": true
						},
						{
							"name": "Get list of vCenters",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/vmware/vcenter?primary_cluster_id=&snappable_status=&ignore_connection_status=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"vmware",
										"vcenter"
									],
									"query": [
										{
											"key": "primary_cluster_id",
											"value": "",
											"description": "Limits the information to the Rubrik cluster specified by the value of primary_cluster_id. Use 'local' for the Rubrik cluster that is hosting the current REST API session."
										},
										{
											"key": "snappable_status",
											"value": "",
											"description": "Determines whether to fetch vCenters with additional privilege checks. (This can only be one of Protectable)"
										},
										{
											"key": "ignore_connection_status",
											"value": "",
											"description": "Don't ping vCenters for connection status. The connection_status field in the response is unusable."
										}
									]
								},
								"description": "Retrieve information for each managed vCenter, including: ID, managed ID, address, username, SLA ID, and primary cluster ID."
							},
							"response": [
								{
									"name": "Summary information for managed vCenters.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vcenter?primary_cluster_id=&snappable_status=&ignore_connection_status=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vcenter"
											],
											"query": [
												{
													"key": "primary_cluster_id",
													"value": ""
												},
												{
													"key": "snappable_status",
													"value": ""
												},
												{
													"key": "ignore_connection_status",
													"value": ""
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Add vCenter Server",
							"request": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/vmware/vcenter",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"vmware",
										"vcenter"
									]
								},
								"description": "Create a vCenter Server object by providing the address and account credentials of the vCenter Server. Initiates an asynchronous job to establish a connection with the vCenter Server and retrieve all metadata. Use GET /vcenter/{id}/status to check status."
							},
							"response": [
								{
									"name": "Status for the add vCenter Server request.",
									"originalRequest": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vcenter",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vcenter"
											]
										}
									},
									"status": "Accepted",
									"code": 202,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Get vCenter Server async request",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/vmware/vcenter/request/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"vmware",
										"vcenter",
										"request",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of the request"
										}
									]
								},
								"description": "Get details about a vcenter related async request."
							},
							"response": [
								{
									"name": "Status for the async request.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vcenter/request/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vcenter",
												"request",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				},
				{
					"name": "vm",
					"item": [
						{
							"name": "snapshot",
							"item": [
								{
									"name": "mount",
									"item": [
										{
											"name": "{id}",
											"item": [
												{
													"name": "Get information for a Live Mount",
													"request": {
														"method": "GET",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/snapshot/mount/:id",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																"snapshot",
																"mount",
																":id"
															],
															"variable": [
																{
																	"key": "id",
																	"value": "schema type not provided",
																	"description": "(Required) ID of a Live Mount."
																}
															]
														},
														"description": "Retrieve detailed information for a specified Live Mount."
													},
													"response": [
														{
															"name": "Detailed information for the specified Live Mount.",
															"originalRequest": {
																"method": "GET",
																"header": [],
																"url": {
																	"raw": "{{baseUrl}}/vmware/vm/snapshot/mount/:id",
																	"host": [
																		"{{baseUrl}}"
																	],
																	"path": [
																		"vmware",
																		"vm",
																		"snapshot",
																		"mount",
																		":id"
																	],
																	"variable": [
																		{
																			"key": "id"
																		}
																	]
																}
															},
															"status": "OK",
															"code": 200,
															"_postman_previewlanguage": "text",
															"header": [
																{
																	"key": "Content-Type",
																	"value": "text/plain"
																}
															],
															"cookie": [],
															"body": ""
														}
													]
												},
												{
													"name": "Power a Live Mount on and off",
													"request": {
														"method": "PATCH",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/snapshot/mount/:id",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																"snapshot",
																"mount",
																":id"
															],
															"variable": [
																{
																	"key": "id",
																	"value": "schema type not provided",
																	"description": "(Required) ID of a Live Mount."
																}
															]
														},
														"description": "Power a specified Live Mount virtual machine on or off. Pass **_true_** to power the virtual machine on and pass **_false_** to power the virtual machine off."
													},
													"response": [
														{
															"name": "Details of the Live Mount.",
															"originalRequest": {
																"method": "PATCH",
																"header": [],
																"url": {
																	"raw": "{{baseUrl}}/vmware/vm/snapshot/mount/:id",
																	"host": [
																		"{{baseUrl}}"
																	],
																	"path": [
																		"vmware",
																		"vm",
																		"snapshot",
																		"mount",
																		":id"
																	],
																	"variable": [
																		{
																			"key": "id"
																		}
																	]
																}
															},
															"status": "OK",
															"code": 200,
															"_postman_previewlanguage": "text",
															"header": [
																{
																	"key": "Content-Type",
																	"value": "text/plain"
																}
															],
															"cookie": [],
															"body": ""
														}
													]
												},
												{
													"name": "Delete a Live Mount VM",
													"request": {
														"method": "DELETE",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/snapshot/mount/:id?force=",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																"snapshot",
																"mount",
																":id"
															],
															"query": [
																{
																	"key": "force",
																	"value": "",
																	"description": "Force unmount to remove metadata when the datastore of the Live Mount virtual machine was moved off of the Rubrik cluster."
																}
															],
															"variable": [
																{
																	"key": "id",
																	"value": "schema type not provided",
																	"description": "(Required) ID of a Live Mount"
																}
															]
														},
														"description": "Create a request to delete a Live Mount virtual machine."
													},
													"response": [
														{
															"name": "Status of the delete request.",
															"originalRequest": {
																"method": "DELETE",
																"header": [],
																"url": {
																	"raw": "{{baseUrl}}/vmware/vm/snapshot/mount/:id?force=",
																	"host": [
																		"{{baseUrl}}"
																	],
																	"path": [
																		"vmware",
																		"vm",
																		"snapshot",
																		"mount",
																		":id"
																	],
																	"query": [
																		{
																			"key": "force",
																			"value": ""
																		}
																	],
																	"variable": [
																		{
																			"key": "id"
																		}
																	]
																}
															},
															"status": "Accepted",
															"code": 202,
															"_postman_previewlanguage": "text",
															"header": [
																{
																	"key": "Content-Type",
																	"value": "text/plain"
																}
															],
															"cookie": [],
															"body": ""
														}
													]
												},
												{
													"name": "Relocate a virtual machine to another datastore",
													"request": {
														"method": "POST",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/snapshot/mount/:id/relocate",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																"snapshot",
																"mount",
																":id",
																"relocate"
															],
															"variable": [
																{
																	"key": "id",
																	"value": "schema type not provided",
																	"description": "(Required) ID of the live mount"
																}
															]
														},
														"description": "Run storage VMotion to relocate a specified Live Mount into another data store."
													},
													"response": [
														{
															"name": "Status of an asynchronous request to migrate datastore",
															"originalRequest": {
																"method": "POST",
																"header": [],
																"url": {
																	"raw": "{{baseUrl}}/vmware/vm/snapshot/mount/:id/relocate",
																	"host": [
																		"{{baseUrl}}"
																	],
																	"path": [
																		"vmware",
																		"vm",
																		"snapshot",
																		"mount",
																		":id",
																		"relocate"
																	],
																	"variable": [
																		{
																			"key": "id"
																		}
																	]
																}
															},
															"status": "Accepted",
															"code": 202,
															"_postman_previewlanguage": "text",
															"header": [
																{
																	"key": "Content-Type",
																	"value": "text/plain"
																}
															],
															"cookie": [],
															"body": ""
														}
													]
												}
											],
											"protocolProfileBehavior": {},
											"_postman_isSubFolder": true
										},
										{
											"name": "Get Live Mount information",
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/snapshot/mount?vm_id=&offset=&limit=",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														"snapshot",
														"mount"
													],
													"query": [
														{
															"key": "vm_id",
															"value": "",
															"description": "Filters information by virtual machine ID."
														},
														{
															"key": "offset",
															"value": "",
															"description": "Starting position in the list of Live Mount entries contained in the response. The summary information includes the specified numbered entry and all higher numbered entries. Use with **_limit_** to retrieve the summary information as smaller groups of entries, e.g. for paging of the results."
														},
														{
															"key": "limit",
															"value": "",
															"description": "Limit the summary information to a specified maximum number of entries. Optionally, use with **_offset_** to start the count at a specified point. Default is 25."
														}
													]
												},
												"description": "Retrieve summary information about Live Mount activity."
											},
											"response": [
												{
													"name": "Summary information for all Live Mounts.",
													"originalRequest": {
														"method": "GET",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/snapshot/mount?vm_id=&offset=&limit=",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																"snapshot",
																"mount"
															],
															"query": [
																{
																	"key": "vm_id",
																	"value": ""
																},
																{
																	"key": "offset",
																	"value": ""
																},
																{
																	"key": "limit",
																	"value": ""
																}
															]
														}
													},
													"status": "OK",
													"code": 200,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										}
									],
									"protocolProfileBehavior": {},
									"_postman_isSubFolder": true
								},
								{
									"name": "{id}",
									"item": [
										{
											"name": "Get VM snapshot details",
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/snapshot/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														"snapshot",
														":id"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of a snapshot."
														}
													]
												},
												"description": "Retrieve detailed information about a virtual machine snapshot."
											},
											"response": [
												{
													"name": "Snapshot details.",
													"originalRequest": {
														"method": "GET",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/snapshot/:id",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																"snapshot",
																":id"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "OK",
													"code": 200,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "Delete VM snapshot",
											"request": {
												"method": "DELETE",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/snapshot/:id?location=",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														"snapshot",
														":id"
													],
													"query": [
														{
															"key": "location",
															"value": "",
															"description": "(Required) Location of the snapshot. Use **_local_** to delete only the local copy of the snapshot. Or use **_all_** to delete the snapshot locally, on a replication target, and at an archival location. (This can only be one of all,local)"
														}
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of snapshot."
														}
													]
												},
												"description": "Designate a snapshot as expired and available for garbage collection. The snapshot must be an on-demand snapshot or a snapshot from a virtual machine that is not assigned to an SLA Domain."
											},
											"response": [
												{
													"name": "Snapshot successfully deleted.",
													"originalRequest": {
														"method": "DELETE",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/snapshot/:id?location=",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																"snapshot",
																":id"
															],
															"query": [
																{
																	"key": "location",
																	"value": ""
																}
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "No Content",
													"code": 204,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "List files in VM snapshot",
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/snapshot/:id/browse?path=&offset=&limit=",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														"snapshot",
														":id",
														"browse"
													],
													"query": [
														{
															"key": "path",
															"value": "",
															"description": "(Required) The absolute path of the starting point for the directory listing."
														},
														{
															"key": "offset",
															"value": "",
															"description": "Starting position in the list of path entries contained in the query results, sorted by lexicographical order. The response includes the specified numbered entry and all higher numbered entries."
														},
														{
															"key": "limit",
															"value": "",
															"description": "Maximum number of entries in the response."
														}
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of snapshot"
														}
													]
												},
												"description": "For a virtual machine snapshot, list the directories and files that are beneath a specified file system path."
											},
											"response": [
												{
													"name": "List of files and directories at the specified path.",
													"originalRequest": {
														"method": "GET",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/snapshot/:id/browse?path=&offset=&limit=",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																"snapshot",
																":id",
																"browse"
															],
															"query": [
																{
																	"key": "path",
																	"value": ""
																},
																{
																	"key": "offset",
																	"value": ""
																},
																{
																	"key": "limit",
																	"value": ""
																}
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "OK",
													"code": 200,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "Download snapshot from archive",
											"request": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/snapshot/:id/download",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														"snapshot",
														":id",
														"download"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of snapshot"
														}
													]
												},
												"description": "Provides a method for retrieving a snapshot, that is not available locally, from an archival location."
											},
											"response": [
												{
													"name": "Status for the download request.",
													"originalRequest": {
														"method": "POST",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/snapshot/:id/download",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																"snapshot",
																":id",
																"download"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "Accepted",
													"code": 202,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "Download file from VM snapshot",
											"request": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/snapshot/:id/download_file",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														"snapshot",
														":id",
														"download_file"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of a snapshot."
														}
													]
												},
												"description": "Create a request to download a file from a virtual machine snapshot."
											},
											"response": [
												{
													"name": "Status of the file download request.",
													"originalRequest": {
														"method": "POST",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/snapshot/:id/download_file",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																"snapshot",
																":id",
																"download_file"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "Accepted",
													"code": 202,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "Export VM snapshot",
											"request": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/snapshot/:id/export",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														"snapshot",
														":id",
														"export"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of a snapshot."
														}
													]
												},
												"description": "Export a virtual machine from a snapshot, using a specified hypervisor host as the datastore."
											},
											"response": [
												{
													"name": "Status of the export request.",
													"originalRequest": {
														"method": "POST",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/snapshot/:id/export",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																"snapshot",
																":id",
																"export"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "Accepted",
													"code": 202,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "Instantly recover a VM",
											"request": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/snapshot/:id/instant_recover",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														"snapshot",
														":id",
														"instant_recover"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of Snapshot"
														}
													]
												},
												"description": "Instantly recovery a virtual machine from a snapshot. The Instant Recovery request starts the virtual machine with networking enabled and renames and powers off the source virtual machine, if it still exists."
											},
											"response": [
												{
													"name": "Status of the Instant Recovery request.",
													"originalRequest": {
														"method": "POST",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/snapshot/:id/instant_recover",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																"snapshot",
																":id",
																"instant_recover"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "Accepted",
													"code": 202,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "Live mount a VM from a snapshot",
											"request": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/snapshot/:id/mount",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														"snapshot",
														":id",
														"mount"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of a snapshot."
														}
													]
												},
												"description": "Create a request to Live Mount a virtual machine from a snapshot using a specified configuration."
											},
											"response": [
												{
													"name": "Status of the Live Mount request.",
													"originalRequest": {
														"method": "POST",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/snapshot/:id/mount",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																"snapshot",
																":id",
																"mount"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "Accepted",
													"code": 202,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "Restore file from VM snapshot",
											"request": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/snapshot/:id/restore_file",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														"snapshot",
														":id",
														"restore_file"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of a snapshot."
														}
													]
												},
												"description": "Create a request to restore a file or folder to the source virtual machine."
											},
											"response": [
												{
													"name": "Status of the restore request.",
													"originalRequest": {
														"method": "POST",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/snapshot/:id/restore_file",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																"snapshot",
																":id",
																"restore_file"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "Accepted",
													"code": 202,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										}
									],
									"protocolProfileBehavior": {},
									"_postman_isSubFolder": true
								}
							],
							"protocolProfileBehavior": {},
							"_postman_isSubFolder": true
						},
						{
							"name": "virtual disk/{id}",
							"item": [
								{
									"name": "Details about the specific Virtual Disk",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vm/virtual_disk/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vm",
												"virtual_disk",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the Virtual Disk"
												}
											]
										},
										"description": "Detailed about the specific Virtual Disk"
									},
									"response": [
										{
											"name": "Return details about the virtual disk",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/virtual_disk/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														"virtual_disk",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Update a specific Virtual Disk",
									"request": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vm/virtual_disk/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vm",
												"virtual_disk",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the Virtual Disk"
												}
											]
										},
										"description": "Update a specific Virtual Disk"
									},
									"response": [
										{
											"name": "The updated Virtual Disk",
											"originalRequest": {
												"method": "PATCH",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/virtual_disk/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														"virtual_disk",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								}
							],
							"protocolProfileBehavior": {},
							"_postman_isSubFolder": true
						},
						{
							"name": "{id}",
							"item": [
								{
									"name": "snapshot",
									"item": [
										{
											"name": "Get list of snapshots of VM",
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/:id/snapshot",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														":id",
														"snapshot"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of the virtual machine."
														}
													]
												},
												"description": "Retrieve summary information for the snapshots of a virtual machine."
											},
											"response": [
												{
													"name": "Summary snapshot information for a virtual machine.",
													"originalRequest": {
														"method": "GET",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/:id/snapshot",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																":id",
																"snapshot"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "OK",
													"code": 200,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "Create an on-demand snapshot for a VM",
											"request": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/:id/snapshot",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														":id",
														"snapshot"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) ID of the virtual machine."
														}
													]
												},
												"description": "Use the ID of a virtual machine to create an on-demand snapshot."
											},
											"response": [
												{
													"name": "On-demand snapshot status.",
													"originalRequest": {
														"method": "POST",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/:id/snapshot",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																":id",
																"snapshot"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "Accepted",
													"code": 202,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										},
										{
											"name": "Delete all snapshots of VM",
											"request": {
												"method": "DELETE",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/:id/snapshot",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														":id",
														"snapshot"
													],
													"variable": [
														{
															"key": "id",
															"value": "schema type not provided",
															"description": "(Required) Virtual machine ID."
														}
													]
												},
												"description": "Delete all of the snapshots from a virtual machine."
											},
											"response": [
												{
													"name": "Snapshots successfully deleted.",
													"originalRequest": {
														"method": "DELETE",
														"header": [],
														"url": {
															"raw": "{{baseUrl}}/vmware/vm/:id/snapshot",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"vmware",
																"vm",
																":id",
																"snapshot"
															],
															"variable": [
																{
																	"key": "id"
																}
															]
														}
													},
													"status": "No Content",
													"code": 204,
													"_postman_previewlanguage": "text",
													"header": [
														{
															"key": "Content-Type",
															"value": "text/plain"
														}
													],
													"cookie": [],
													"body": ""
												}
											]
										}
									],
									"protocolProfileBehavior": {},
									"_postman_isSubFolder": true
								},
								{
									"name": "Get VM details",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vm/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vm",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the virtual machine."
												}
											]
										},
										"description": "Retrieve details for a virtual machine."
									},
									"response": [
										{
											"name": "Virtual machine details.",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Update VM",
									"request": {
										"method": "PATCH",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vm/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vm",
												":id"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of virtual machine."
												}
											]
										},
										"description": "Update a virtual machine with specified properties. Use the guestCredential field to update the guest credential for a specified virtual machine."
									},
									"response": [
										{
											"name": "Virtual machine details.",
											"originalRequest": {
												"method": "PATCH",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/:id",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														":id"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Run guest OS script",
									"request": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vm/:id/guest_script/run",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vm",
												":id",
												"guest_script",
												"run"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the virtual machine."
												}
											]
										},
										"description": "Run the specified preBackup, postSnap, or postBackup script in the guest OS of a virtual machine. The script must exist and meet requirements."
									},
									"response": [
										{
											"name": "Guest OS script ran successfully and returned a 0 exit code.",
											"originalRequest": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/:id/guest_script/run",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														":id",
														"guest_script",
														"run"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "No Content",
											"code": 204,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Get missed time ranges for point in time recovery",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vm/:id/missed_recoverable_range?after_time=&before_time=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vm",
												":id",
												"missed_recoverable_range"
											],
											"query": [
												{
													"key": "after_time",
													"value": "",
													"description": "Filter ranges to end after this time. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`."
												},
												{
													"key": "before_time",
													"value": "",
													"description": "Filter ranges to start before this time. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`."
												}
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) The virtual machine ID."
												}
											]
										},
										"description": "Gets a list of time ranges to which a CDP-enabled virtual machine cannot perform a point-in-time recovery. The time ranges are indicated by start and end timestamps listed as date-time strings."
									},
									"response": [
										{
											"name": "Returns the missed recoverable ranges for the virtual machine.",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/:id/missed_recoverable_range?after_time=&before_time=",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														":id",
														"missed_recoverable_range"
													],
													"query": [
														{
															"key": "after_time",
															"value": ""
														},
														{
															"key": "before_time",
															"value": ""
														}
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Get details about missed snapshots for a VM",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vm/:id/missed_snapshot",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vm",
												":id",
												"missed_snapshot"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of a virtual machine."
												}
											]
										},
										"description": "Retrieve details about the missed snapshots for a virtual machine."
									},
									"response": [
										{
											"name": "Missed snapshot details for a virtual machine.",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/:id/missed_snapshot",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														":id",
														"missed_snapshot"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Get available time ranges for point in time recovery",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vm/:id/recoverable_range?after_time=&before_time=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vm",
												":id",
												"recoverable_range"
											],
											"query": [
												{
													"key": "after_time",
													"value": "",
													"description": "Filter ranges to end after this time. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`."
												},
												{
													"key": "before_time",
													"value": "",
													"description": "Filter ranges to start before this time. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`."
												}
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) The virtual machine ID."
												}
											]
										},
										"description": "Gets time ranges available for point-in-time recovery. The time ranges are indicated by start and end date-time strings."
									},
									"response": [
										{
											"name": "Returns the recoverable ranges for the virtual machine.",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/:id/recoverable_range?after_time=&before_time=",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														":id",
														"recoverable_range"
													],
													"query": [
														{
															"key": "after_time",
															"value": ""
														},
														{
															"key": "before_time",
															"value": ""
														}
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Register Rubrik Backup Service",
									"request": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vm/:id/register_agent",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vm",
												":id",
												"register_agent"
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID assigned to a virtual machine object."
												}
											]
										},
										"description": "Register the Rubrik Backup Service that is running on a specified host with the specified Rubrik cluster."
									},
									"response": [
										{
											"name": "Successfully registered the Rubrik Backup Service for a specified virtual machine.",
											"originalRequest": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/:id/register_agent",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														":id",
														"register_agent"
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "No Content",
											"code": 204,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								},
								{
									"name": "Search for a file from a VM",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vm/:id/search?path=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vm",
												":id",
												"search"
											],
											"query": [
												{
													"key": "path",
													"value": "",
													"description": "(Required) The path query. Use either a path prefix or a filename prefix."
												}
											],
											"variable": [
												{
													"key": "id",
													"value": "schema type not provided",
													"description": "(Required) ID of the virtual machine."
												}
											]
										},
										"description": "Search for a file in the snapshots of a a virtual machine. Specify the file by full path prefix or filename prefix."
									},
									"response": [
										{
											"name": "File search results.",
											"originalRequest": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{baseUrl}}/vmware/vm/:id/search?path=",
													"host": [
														"{{baseUrl}}"
													],
													"path": [
														"vmware",
														"vm",
														":id",
														"search"
													],
													"query": [
														{
															"key": "path",
															"value": ""
														}
													],
													"variable": [
														{
															"key": "id"
														}
													]
												}
											},
											"status": "OK",
											"code": 200,
											"_postman_previewlanguage": "text",
											"header": [
												{
													"key": "Content-Type",
													"value": "text/plain"
												}
											],
											"cookie": [],
											"body": ""
										}
									]
								}
							],
							"protocolProfileBehavior": {},
							"_postman_isSubFolder": true
						},
						{
							"name": "Get list of VMs",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/vmware/vm?effective_sla_domain_id=&primary_cluster_id=&limit=&offset=&is_relic=&name=&moid=&sla_assignment=&guest_os_name=&sort_by=&sort_order=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"vmware",
										"vm"
									],
									"query": [
										{
											"key": "effective_sla_domain_id",
											"value": "",
											"description": "Filter by ID of effective SLA Domain."
										},
										{
											"key": "primary_cluster_id",
											"value": "",
											"description": "Filter by primary cluster ID, or **local**."
										},
										{
											"key": "limit",
											"value": "",
											"description": "Limit the number of matches returned."
										},
										{
											"key": "offset",
											"value": "",
											"description": "Ignore these many matches in the beginning."
										},
										{
											"key": "is_relic",
											"value": "",
											"description": "Filter by the isRelic field of the virtual machine. When this parameter is not set, return both relic and non-relic virtual machines."
										},
										{
											"key": "name",
											"value": "",
											"description": "Search by using a virtual machine name."
										},
										{
											"key": "moid",
											"value": "",
											"description": "Search by using a virtual machine managed object ID."
										},
										{
											"key": "sla_assignment",
											"value": "",
											"description": "Filter by SLA Domain assignment type. (This can only be one of Derived,Direct,Unassigned)"
										},
										{
											"key": "guest_os_name",
											"value": "",
											"description": "Filters by the name of operating system using infix search."
										},
										{
											"key": "sort_by",
											"value": "",
											"description": "Sort results based on the specified attribute. (This can only be one of effectiveSlaDomainName,name,moid,folderPath,infraPath)"
										},
										{
											"key": "sort_order",
											"value": "",
											"description": "Sort order, either ascending or descending. (This can only be one of asc,desc)"
										}
									]
								},
								"description": "Get summary of all the VMs"
							},
							"response": [
								{
									"name": "Virtual machine summary.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vm?effective_sla_domain_id=&primary_cluster_id=&limit=&offset=&is_relic=&name=&moid=&sla_assignment=&guest_os_name=&sort_by=&sort_order=",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vm"
											],
											"query": [
												{
													"key": "effective_sla_domain_id",
													"value": ""
												},
												{
													"key": "primary_cluster_id",
													"value": ""
												},
												{
													"key": "limit",
													"value": ""
												},
												{
													"key": "offset",
													"value": ""
												},
												{
													"key": "is_relic",
													"value": ""
												},
												{
													"key": "name",
													"value": ""
												},
												{
													"key": "moid",
													"value": ""
												},
												{
													"key": "sla_assignment",
													"value": ""
												},
												{
													"key": "guest_os_name",
													"value": ""
												},
												{
													"key": "sort_by",
													"value": ""
												},
												{
													"key": "sort_order",
													"value": ""
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Live mount a snapshot each from a set of virtual machines",
							"request": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/vmware/vm/batch_mount",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"vmware",
										"vm",
										"batch_mount"
									]
								}
							},
							"response": [
								{
									"name": "Status of the Live Mount requests.",
									"originalRequest": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vm/batch_mount",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vm",
												"batch_mount"
											]
										}
									},
									"status": "Accepted",
									"code": 202,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Returns the live CDP info for a set of CDP-enabled virtual machines",
							"request": {
								"method": "POST",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/vmware/vm/cdp",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"vmware",
										"vm",
										"cdp"
									]
								}
							},
							"response": [
								{
									"name": "Returns the live CDP info for the CDP-enabled virtual machines.",
									"originalRequest": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vm/cdp",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vm",
												"cdp"
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Get asynchronous request details for VM",
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/vmware/vm/request/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"vmware",
										"vm",
										"request",
										":id"
									],
									"variable": [
										{
											"key": "id",
											"value": "schema type not provided",
											"description": "(Required) ID of an asynchronous request."
										}
									]
								},
								"description": "Get the details of an asynchronous request that involves a VMware virtual machine."
							},
							"response": [
								{
									"name": "Status of an asynchronous request.",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{baseUrl}}/vmware/vm/request/:id",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"vmware",
												"vm",
												"request",
												":id"
											],
											"variable": [
												{
													"key": "id"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "text",
									"header": [
										{
											"key": "Content-Type",
											"value": "text/plain"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						}
					],
					"protocolProfileBehavior": {},
					"_postman_isSubFolder": true
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "windows cluster",
			"item": [
				{
					"name": "Get summary information for Windows clusters",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/windows_cluster?primary_cluster_id=&is_agentless=&snappable_status=",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"windows_cluster"
							],
							"query": [
								{
									"key": "primary_cluster_id",
									"value": "",
									"description": "Filter by primary_cluster_id. Use **local** for the local cluster."
								},
								{
									"key": "is_agentless",
									"value": "",
									"description": "Filter by is_agentless flag."
								},
								{
									"key": "snappable_status",
									"value": "",
									"description": "Determines whether Windows clusters are fetched with additional privilege checks. (This can only be one of Protectable)"
								}
							]
						},
						"description": "Returns a list of summary information for Windows server failover clusters."
					},
					"response": [
						{
							"name": "Returned if the query was successful.",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/windows_cluster?primary_cluster_id=&is_agentless=&snappable_status=",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"windows_cluster"
									],
									"query": [
										{
											"key": "primary_cluster_id",
											"value": ""
										},
										{
											"key": "is_agentless",
											"value": ""
										},
										{
											"key": "snappable_status",
											"value": ""
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				},
				{
					"name": "Get detailed information for a Windows cluster",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/windows_cluster/:id",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"windows_cluster",
								":id"
							],
							"variable": [
								{
									"key": "id",
									"value": "schema type not provided",
									"description": "(Required) ID of the Windows cluster."
								}
							]
						},
						"description": "Returns a detailed view of a Windows server failover cluster."
					},
					"response": [
						{
							"name": "Returned if the query was successful.",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseUrl}}/windows_cluster/:id",
									"host": [
										"{{baseUrl}}"
									],
									"path": [
										"windows_cluster",
										":id"
									],
									"variable": [
										{
											"key": "id"
										}
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "text",
							"header": [
								{
									"key": "Content-Type",
									"value": "text/plain"
								}
							],
							"cookie": [],
							"body": ""
						}
					]
				}
			],
			"protocolProfileBehavior": {}
		},
		{
			"name": "Clear cached authorization information",
			"request": {
				"method": "DELETE",
				"header": [],
				"url": {
					"raw": "{{baseUrl}}/authorization/cache",
					"host": [
						"{{baseUrl}}"
					],
					"path": [
						"authorization",
						"cache"
					]
				},
				"description": "Clears the node of cached authorization information for the current user."
			},
			"response": [
				{
					"name": "Successfully deleted cached authorization information.",
					"originalRequest": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/authorization/cache",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"authorization",
								"cache"
							]
						}
					},
					"status": "No Content",
					"code": 204,
					"_postman_previewlanguage": "text",
					"header": [
						{
							"key": "Content-Type",
							"value": "text/plain"
						}
					],
					"cookie": [],
					"body": ""
				}
			]
		},
		{
			"name": "(DO NOT USE! WILL RELEASE IN FUTURE) Get all events and relevant information associated with an event series",
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "{{baseUrl}}/event_series/:id",
					"host": [
						"{{baseUrl}}"
					],
					"path": [
						"event_series",
						":id"
					],
					"variable": [
						{
							"key": "id",
							"value": "schema type not provided",
							"description": "(Required) The ID of the event series."
						}
					]
				},
				"description": "Get all the events associated with an event series. In addition, return information that is specific to the event series."
			},
			"response": [
				{
					"name": "Returns the list of events by event series ID and a summary of the event series.",
					"originalRequest": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/event_series/:id",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"event_series",
								":id"
							],
							"variable": [
								{
									"key": "id"
								}
							]
						}
					},
					"status": "OK",
					"code": 200,
					"_postman_previewlanguage": "text",
					"header": [
						{
							"key": "Content-Type",
							"value": "text/plain"
						}
					],
					"cookie": [],
					"body": ""
				}
			]
		},
		{
			"name": "Generate and download unified view script",
			"request": {
				"method": "POST",
				"header": [],
				"url": {
					"raw": "{{baseUrl}}/managed_volume/snapshot/export/:id/script",
					"host": [
						"{{baseUrl}}"
					],
					"path": [
						"managed_volume",
						"snapshot",
						"export",
						":id",
						"script"
					],
					"variable": [
						{
							"key": "id",
							"value": "schema type not provided",
							"description": "(Required) ID of snapshot export."
						}
					]
				},
				"description": "Start an asynchronous job to generate and download a script to unify export paths across channels in managed volume export."
			},
			"response": [
				{
					"name": "Status of an asynchronous job to generate unified view script.",
					"originalRequest": {
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/managed_volume/snapshot/export/:id/script",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"managed_volume",
								"snapshot",
								"export",
								":id",
								"script"
							],
							"variable": [
								{
									"key": "id"
								}
							]
						}
					},
					"status": "Accepted",
					"code": 202,
					"_postman_previewlanguage": "text",
					"header": [
						{
							"key": "Content-Type",
							"value": "text/plain"
						}
					],
					"cookie": [],
					"body": ""
				}
			]
		}
	],
	"variable": [
		{
			"id": "baseUrl",
			"key": "baseUrl",
			"value": "/",
			"type": "string"
		}
	],
	"protocolProfileBehavior": {}
}